diff --git a/src/2-structs-enums-lifetimes.md b/src/2-structs-enums-lifetimes.md
index 64f3113..4ece756 100644
--- a/src/2-structs-enums-lifetimes.md
+++ b/src/2-structs-enums-lifetimes.md
@@ -50,14 +50,10 @@ the copy will need its own allocated block.
     | addr | -------------------|
     | size |
 
-    | 8 bytes |
 ```
 The second value is a string slice (`&str`) which refers to the same memory as the string,
 with a size - just the guy's name. Cheap to copy!
 
-The third value is an `f64` - just 8 bytes. It does not refer to any other memory, so
-it's just as cheap to copy as to move.
-
 Re-writing with a function call reveals exactly the same error:
 
 ```rust
@@ -105,6 +101,10 @@ fn dump(s: &str) {
 
 And then both `dump(&s1)` and `dump("hello world")` work properly.
 
+To summarise, assignment of a non-trivial value moves the value from one location
+to another. Otherwise, Rust would be forced to _implicitly_ do a copy and break its
+promise to make allocations explicit.
+
 ## Lifetimes
 
 So, the rule of thumb is to prefer to keep references to the original data - to 'borrow'
@@ -133,8 +133,8 @@ block:
 }
 ```
 Loop variables (like `i`) are a little different, they are only visible in the loop
-block.  It is not an error to create a new variable using the same name ('shadowing')
-but it can be confusing.
+block.  It is not an error to create a new variable using the same name within
+a _nested_ scope ('shadowing') but this can confuse humans.
 
 When a variable 'goes out of scope' then it is _dropped_. Any memory used is reclaimed,
 and any other _resources_ owned by that variable are given back to the system - for
@@ -207,8 +207,6 @@ fn main() {
 // add 12 mul 20
 // add 12 mul 20
 ```
-The `let (add,mul) = t` construct is similar to that found in Python, except it only works
-with tuple values, not any source of values.
 
 Tuples may contain _different_ types, which is the main difference from arrays.
 
@@ -219,7 +217,7 @@ assert_eq!(tuple.0, "hello");
 assert_eq!(tuple.1, 5);
 assert_eq!(tuple.2, 'c');
 ```
-They appear in some `Iterator` methods. This is like the Python generator
+They appear in some `Iterator` methods. `enumerate` is like the Python generator
 of the same name:
 
 ```rust
@@ -315,8 +313,8 @@ impl Person {
     println!("fullname {}", p.full_name());
 // fullname John Smith
 ```
-The `self` is used explicitly (unlike the `this` of C++) and is passed as a reference.
-(You can think of `&self` as `self: &Person`.)
+The `self` is used explicitly and is passed as a reference.
+(You can think of `&self` as short for `self: &Person`.)
 
 The keyword `Self` refers to the struct type - you can mentally substitute `Person`
 for `Self` here:
@@ -512,6 +510,45 @@ fn main() {
 Lifetimes are conventionally called 'a','b',etc but you could just as well called it
 'me' here.
 
+With this definition, we would like to write a function that returns an `A` value:
+
+```rust
+fn makes_a() -> A {
+    let string = "I'm a little string".to_string();
+    A { s: &string }
+}
+```
+
+But `A` needs a lifetime - "expected lifetime parameter":
+
+```
+  = help: this function's return type contains a borrowed value,
+   but there is no value for it to be borrowed from
+  = help: consider giving it a 'static lifetime
+```
+`rustc` is giving advice, so we follow it:
+
+```rust
+fn makes_a() -> A<'static> {
+    let string = "I'm a little string".to_string();
+    A { s: &string }
+}
+```
+
+And now the error is
+
+```
+8 |      A { s: &string }
+  |              ^^^^^^ does not live long enough
+9 | }
+  | - borrowed value only lives until here
+```
+
+There is no way that this could safely work, because `string` will be dropped when the
+function ends, and no reference to `string` can outlast it.
+
+You can usefully think of lifetime parameters as being part of the type of a value.
+
 Sometimes it seems like a good idea for a struct to contain a value _and_ a reference
 that borrows from that value.
 It's basically impossible because structs must be _moveable_, and any move will
@@ -1089,7 +1126,7 @@ fn match_tuple(t: (i32,String)) {
         (0, s) => format!("zero {}", s),
         (1, ref s) if s == "hello" => format!("hello one!"),
         tt => format!("no match {:?}", tt),
-        // or say _ => format!("no match") if you're not interested in the value  
+        // or say _ => format!("no match") if you're not interested in the value
      };
     println!("{}", text);
 }
@@ -1349,7 +1386,7 @@ these boxed closures in a struct, then you will need a lifetime annotation, beca
 _closures borrow variables_ and so their lifetime is tied to the lifetime of those
 variables.
 
-(Unfortunately, you can't use `type` to declare a shorthand for function trait types; it's definitely a 
+(Unfortunately, you can't use `type` to declare a shorthand for function trait types; it's definitely a
 place where I miss a `typedef` statement.)
 
 Sometimes you don't want a closure to borrow those variables, but instead _move_ them.
