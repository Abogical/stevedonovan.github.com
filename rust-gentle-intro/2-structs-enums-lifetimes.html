<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Structs, Enums and Matching - A Gentle Introduction to Rust</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Introduction to the Rust language, standard library and ecosystem">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="./readme.html">Introduction</a></li><li><a href="./1-basics.html"><strong>1.</strong> Basics</a></li><li><a href="./2-structs-enums-lifetimes.html" class="active"><strong>2.</strong> Structs, Enums and Matching</a></li><li><a href="./3-filesystem.html"><strong>3.</strong> Filesystem and Processes</a></li><li><a href="./4-modules.html"><strong>4.</strong> Modules and Cargo</a></li><li><a href="./5-stdlib-containers.html"><strong>5.</strong> Standard Library Containers</a></li><li><a href="./6-error-handling.html"><strong>6.</strong> Error Handling</a></li><li><a href="./7-shared-and-networking.html"><strong>7.</strong> Threads, Networking and Sharing</a></li><li><a href="./object-orientation.html"><strong>8.</strong> Object-Oriented Programming</a></li><li><a href="./nom-intro.html"><strong>9.</strong> Parsing with Nom</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">A Gentle Introduction to Rust</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="./2-structs-enums-lifetimes.html#structs-enums-and-matching" name="structs-enums-and-matching"><h1>Structs, Enums and Matching</h1></a>
<a class="header" href="./2-structs-enums-lifetimes.html#rust-likes-to-move-it-move-it" name="rust-likes-to-move-it-move-it"><h2>Rust likes to Move It, Move It</h2></a>
<p>I'd like to move back a little, and show you something surprising:</p>
<pre><pre class="playpen"><code class="language-rust">// move1.rs
fn main() {
    let s1 = &quot;hello dolly&quot;.to_string();
    let s2 = s1;
    println!(&quot;s1 {}&quot;, s1);
}
</code></pre></pre>
<p>And we get the following error:</p>
<pre><code>error[E0382]: use of moved value: `s1`
 --&gt; move1.rs:5:22
  |
4 |     let s2 = s1;
  |         -- value moved here
5 |     println!(&quot;s1 {}&quot;, s1);
  |                      ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`,
  which does not implement the `Copy` trait
</code></pre>
<p>Rust has different behaviour than other languages. In a language where variables are
always references (like Java or Python), <code>s2</code> becomes yet another reference to the
string object referenced by <code>s1</code>. In C++, <code>s1</code> is a value, and it is <em>copied</em> to <code>s2</code>.
But Rust moves the value.  It doesn't see strings as copyable
(&quot;does not implement the Copy trait&quot;).</p>
<p>We would not see this with 'primitive' types like numbers, since they are just values;
they are allowed to be copyable because they are cheap to copy. But <code>String</code> has allocated
memory containing &quot;Hello dolly&quot;, and copying will involve allocating some more memory
and copying the characters. Rust will not do this silently.</p>
<p>Consider a <code>String</code> containing the whole text of 'Moby-Dick'. It's not a big struct,
just has the address in memory of the text, its size, and how big the allocated block is.
Copying this is going to be expensive, because that memory is allocated on the heap and
the copy will need its own allocated block.</p>
<pre><code>    | addr | ---------&gt; Call me Ishmael.....
    | size |                    |
    | cap  |                    |
                                |
    | addr | -------------------|
    | size |

    | 8 bytes |
</code></pre>
<p>The second value is a string slice (<code>&amp;str</code>) which refers to the same memory as the string,
with a size - just the guy's name. Cheap to copy!</p>
<p>The third value is an <code>f64</code> - just 8 bytes. It does not refer to any other memory, so
it's just as cheap to copy as to move.</p>
<p>Re-writing with a function call reveals exactly the same error:</p>
<pre><pre class="playpen"><code class="language-rust">// move2.rs

fn dump(s: String) {
    println!(&quot;{}&quot;, s);
}

fn main() {
    let s1 = &quot;hello dolly&quot;.to_string();
    dump(s1);
    println!(&quot;s1 {}&quot;, s1); // &lt;---error: 'value used here after move'
}
</code></pre></pre>
<p>Here, you have a choice. You may pass a reference to that string, or
explicitly copy it using its <code>clone</code> method.  Generally, the first is the better way
to go.</p>
<pre><pre class="playpen"><code class="language-rust">fn dump(s: &amp;String) {
    println!(&quot;{}&quot;, s);
}

fn main() {
    let s1 = &quot;hello dolly&quot;.to_string();
    dump(&amp;s1);
    println!(&quot;s1 {}&quot;, s1);
}
</code></pre></pre>
<p>The error goes away. But you'll rarely see a plain
<code>String</code> reference like this, since to pass a string literal is really ugly <em>and</em> involves
creating a temporary string.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    dump(&amp;&quot;hello world&quot;.to_string());

#}</code></pre></pre>
<p>So altogether the best way to declare that function is:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn dump(s: &amp;str) {
    println!(&quot;{}&quot;, s);
}

#}</code></pre></pre>
<p>And then both <code>dump(&amp;s1)</code> and <code>dump(&quot;hello world&quot;)</code> work properly. (Here <code>Deref</code>
coercion kicks in and Rust will convert <code>&amp;String</code> to <code>&amp;str</code> for you.)</p>
<p>To summarise, assignment of a non-trivial value moves the value from one location
to another. Otherwise, Rust would be forced to <em>implicitly</em> do a copy and break its
promise to make allocations explicit.</p>
<a class="header" href="./2-structs-enums-lifetimes.html#scope-of-variables" name="scope-of-variables"><h2>Scope of Variables</h2></a>
<p>So, the rule of thumb is to prefer to keep references to the original data - to 'borrow'
it.</p>
<p>But a reference must <em>not</em> outlive the owner!</p>
<p>First, Rust is a <em>block-scoped</em> language. Variables only exist for the duration of their
block:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
{
    let a = 10;
    let b = &quot;hello&quot;;
    {
        let c = &quot;hello&quot;.to_string();
        // a,b and c are visible
    }
    // the string c is dropped
    // a,b are visible
    for i in 0..a {
        let b = &amp;b[1..];
        // original b is no longer visible - it is shadowed.
    }
    // the slice b is dropped
    // i is _not_ visible!
}

#}</code></pre></pre>
<p>Loop variables (like <code>i</code>) are a little different, they are only visible in the loop
block.  It is not an error to create a new variable using the same name ('shadowing')
but it can be confusing.</p>
<p>When a variable 'goes out of scope' then it is <em>dropped</em>. Any memory used is reclaimed,
and any other <em>resources</em> owned by that variable are given back to the system - for
instance, dropping a <code>File</code> closes it.  This is a Good Thing. Unused resources are
reclaimed immediately when not needed.</p>
<p>(A further Rust-specific issue is that a variable may appear to be in scope, but its
value has moved.)</p>
<p>Here a reference <code>rs1</code> is made to a value <code>tmp</code> which only lives for the duration
of its block:</p>
<pre><pre class="playpen"><code class="language-rust">01 // ref1.rs
02 fn main() {
03    let s1 = &quot;hello dolly&quot;.to_string();
04    let mut rs1 = &amp;s1;
05    {
06        let tmp = &quot;hello world&quot;.to_string();
07        rs1 = &amp;tmp;
08    }
09    println!(&quot;ref {}&quot;, rs1);
10 }
</code></pre></pre>
<p>We borrow the value of <code>s1</code> and then borrow the value of <code>tmp</code>. But <code>tmp</code>'s value
does not exist outside that block!</p>
<pre><code>error: `tmp` does not live long enough
  --&gt; ref1.rs:8:5
   |
7  |         rs1 = &amp;tmp;
   |                --- borrow occurs here
8  |     }
   |     ^ `tmp` dropped here while still borrowed
9  |     println!(&quot;ref {}&quot;, rs1);
10 | }
   | - borrowed value needs to live until here
</code></pre>
<p>Where is <code>tmp</code>? Gone, dead, gone back to the Big Heap in the Sky: <em>dropped</em>.
Rust is here saving you from the dreaded 'dangling pointer' problem of C -
a reference that points to stale data.</p>
<a class="header" href="./2-structs-enums-lifetimes.html#tuples" name="tuples"><h2>Tuples</h2></a>
<p>It's sometimes very useful to return multiple values from a function. Tuples are
a convenient solution:</p>
<pre><pre class="playpen"><code class="language-rust">// tuple1.rs

fn add_mul(x: f64, y: f64) -&gt; (f64,f64) {
    (x + y, x * y)
}

fn main() {
    let t = add_mul(2.0,10.0);

    // can debug print
    println!(&quot;t {:?}&quot;, t);

    // can 'index' the values
    println!(&quot;add {} mul {}&quot;, t.0,t.1);

    // can _extract_ values
    let (add,mul) = t;
    println!(&quot;add {} mul {}&quot;, add,mul);
}
// t (12, 20)
// add 12 mul 20
// add 12 mul 20
</code></pre></pre>
<p>Tuples may contain <em>different</em> types, which is the main difference from arrays.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let tuple = (&quot;hello&quot;, 5, 'c');

assert_eq!(tuple.0, &quot;hello&quot;);
assert_eq!(tuple.1, 5);
assert_eq!(tuple.2, 'c');

#}</code></pre></pre>
<p>They appear in some <code>Iterator</code> methods. <code>enumerate</code> is like the Python generator
of the same name:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    for (i,s) in [&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;].iter().enumerate() {
        print!(&quot; {} {};&quot;,i,s);
    }
    //  0 zero; 1 one; 2 two;

#}</code></pre></pre>
<p><code>zip</code> combines two iterators into a single iterator of
tuples containing the values from both:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let names = [&quot;ten&quot;,&quot;hundred&quot;,&quot;thousand&quot;];
    let nums = [10,100,1000];
    for p in names.iter().zip(nums.iter()) {
        print!(&quot; {} {};&quot;, p.0,p.1);
    }
    //  ten 10; hundred 100; thousand 1000;

#}</code></pre></pre>
<a class="header" href="./2-structs-enums-lifetimes.html#structs" name="structs"><h2>Structs</h2></a>
<p>Tuples are convenient, but saying <code>t.1</code> and keeping track of the meaning of each part
is tedious for anything that isn't straightforward.</p>
<p>Rust <em>structs</em> contain named <em>fields</em>:</p>
<pre><pre class="playpen"><code class="language-rust">// struct1.rs

struct Person {
    first_name: String,
    last_name: String
}

fn main() {
    let p = Person {
        first_name: &quot;John&quot;.to_string(),
        last_name: &quot;Smith&quot;.to_string()
    };
    println!(&quot;person {} {}&quot;, p.first_name,p.last_name);
}
</code></pre></pre>
<p>The values of a struct will be placed next to each other in memory, although you should
not assume any particular memory layout, since the compiler will organize the memory for
efficiency, not size, and there may be padding.</p>
<p>Initializing this struct is a bit clumsy, so we want to move the construction of a <code>Person</code>
into its own function. This function can be made into a <em>method</em> of <code>Person</code> by putting
it into a <code>impl</code> block:</p>
<pre><pre class="playpen"><code class="language-rust">// struct2.rs

struct Person {
    first_name: String,
    last_name: String
}

impl Person {

    fn new(first: &amp;str, name: &amp;str) -&gt; Person {
        Person {
            first_name: first.to_string(),
            last_name: name.to_string()
        }
    }

}

fn main() {
    let p = Person::new(&quot;John&quot;,&quot;Smith&quot;);
    println!(&quot;person {} {}&quot;, p.first_name,p.last_name);
}
</code></pre></pre>
<p>There is nothing magic or reserved about the name <code>new</code> here. Note that it's accessed
using a C++-like notation using double-colon <code>::</code>.</p>
<p>Here's a another <code>Person</code> method, but with a <em>reference self</em> argument:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
impl Person {
    ...

    fn full_name(&amp;self) -&gt; String {
        format!(&quot;{} {}&quot;, self.first_name, self.last_name)
    }

}
...
    println!(&quot;fullname {}&quot;, p.full_name());
// fullname John Smith

#}</code></pre></pre>
<p>The <code>self</code> is used explicitly and is passed as a reference.
(You can think of <code>&amp;self</code> as short for <code>self: &amp;Person</code>.)</p>
<p>The keyword <code>Self</code> refers to the struct type - you can mentally substitute <code>Person</code>
for <code>Self</code> here:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn copy(&amp;self) -&gt; Self {
        Self::new(&amp;self.first_name,&amp;self.last_name)
    }

#}</code></pre></pre>
<p>Methods may allow the data to be modified using a <em>mutable self</em> argument:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn set_first_name(&amp;mut self, name: &amp;str) {
        self.first_name = name.to_string();
    }

#}</code></pre></pre>
<p>And the data will <em>move</em> into the method when a plain self argument is used:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn to_tuple(self) -&gt; (String,String) {
        (self.first_name, self.last_name)
    }

#}</code></pre></pre>
<p>(Try that with <code>&amp;self</code> - structs will not let go of their data without a fight!)</p>
<p>Note that after <code>v.to_tuple()</code> is called, then <code>v</code> has moved and is no longer
available.</p>
<p>To summarize:</p>
<ul>
<li>no <code>self</code> argument: you can associate functions with structs, like the <code>new</code> &quot;constructor&quot;.</li>
<li><code>&amp;self</code> argument: can use the values of the struct, but not change them</li>
<li><code>&amp;mut self</code> argument: can modify the values</li>
<li><code>self</code> argument: will consume the value, which will move.</li>
</ul>
<p>If you try to do a debug dump of a <code>Person</code>, you will get an informative error:</p>
<pre><code>error[E0277]: the trait bound `Person: std::fmt::Debug` is not satisfied
  --&gt; struct2.rs:23:21
   |
23 |     println!(&quot;{:?}&quot;, p);
   |                     ^ the trait `std::fmt::Debug` is not implemented for `Person`
   |
   = note: `Person` cannot be formatted using `:?`; if it is defined in your crate,
    add `#[derive(Debug)]` or manually implement it
   = note: required by `std::fmt::Debug::fmt`
</code></pre>
<p>The compiler is giving advice, so we put <code>#[derive(Debug)]</code> in front of <code>Person</code>, and now
there is sensible output:</p>
<pre><code>Person { first_name: &quot;John&quot;, last_name: &quot;Smith&quot; }
</code></pre>
<p>The <em>directive</em> makes the compiler generate a <code>Debug</code> implementation, which is very
helpful. It's good practice to do this for your structs, so they can be
printed out (or written as a string using <code>format!</code>).  (Doing so <em>by default</em> would be
very un-Rustlike.)</p>
<p>Here is the final little program:</p>
<pre><pre class="playpen"><code class="language-rust">// struct4.rs
use std::fmt;

#[derive(Debug)]
struct Person {
    first_name: String,
    last_name: String
}

impl Person {

    fn new(first: &amp;str, name: &amp;str) -&gt; Person {
        Person {
            first_name: first.to_string(),
            last_name: name.to_string()
        }
    }

    fn full_name(&amp;self) -&gt; String {
        format!(&quot;{} {}&quot;,self.first_name, self.last_name)
    }

    fn set_first_name(&amp;mut self, name: &amp;str) {
        self.first_name = name.to_string();
    }

    fn to_tuple(self) -&gt; (String,String) {
        (self.first_name, self.last_name)
    }
}

fn main() {
    let mut p = Person::new(&quot;John&quot;,&quot;Smith&quot;);

    println!(&quot;{:?}&quot;, p);

    p.set_first_name(&quot;Jane&quot;);

    println!(&quot;{:?}&quot;, p);

    println!(&quot;{:?}&quot;, p.to_tuple());
    // p has now moved.

}
// Person { first_name: &quot;John&quot;, last_name: &quot;Smith&quot; }
// Person { first_name: &quot;Jane&quot;, last_name: &quot;Smith&quot; }
// (&quot;Jane&quot;, &quot;Smith&quot;)
</code></pre></pre>
<a class="header" href="./2-structs-enums-lifetimes.html#lifetimes-start-to-bite" name="lifetimes-start-to-bite"><h2>Lifetimes Start to Bite</h2></a>
<p>Usually structs contain values, but often they also need to contain references.
Say we want to put a string slice, not a string value, in a struct.</p>
<pre><pre class="playpen"><code class="language-rust">// life1.rs

#[derive(Debug)]
struct A {
    s: &amp;str
}

fn main() {
    let a = A { s: &quot;hello dammit&quot; };

    println!(&quot;{:?}&quot;, a);
}
</code></pre></pre>
<pre><code>error[E0106]: missing lifetime specifier
 --&gt; life1.rs:5:8
  |
5 |     s: &amp;str
  |        ^ expected lifetime parameter
</code></pre>
<p>To understand the complaint, you have to see the problem from the point of view of Rust.
It will not allow a reference to be stored without knowing its lifetime. All
references are borrowed from some value, and all values have lifetimes. The lifetime of
a reference cannot be longer than the lifetime of that value.
Rust cannot allow
a situation where that reference could suddenly become invalid.</p>
<p>Now, string slices borrow from <em>string literals</em>
like &quot;hello&quot; or from <code>String</code> values. String literals exist for the duration
of the whole program, which is called the 'static' lifetime.</p>
<p>So this works - we assure Rust that the string slice always refers to such static strings:</p>
<pre><pre class="playpen"><code class="language-rust">// life2.rs

#[derive(Debug)]
struct A {
    s: &amp;'static str
}

fn main() {
    let a = A { s: &quot;hello dammit&quot; };

    println!(&quot;{:?}&quot;, a);
}
// A { s: &quot;hello dammit&quot; }
</code></pre></pre>
<p>It is not the most <em>pretty</em> notation, but sometimes ugliness is the necessary
price of being precise.</p>
<p>This can also be used to specify a string slice that is returned from a function:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn how(i: u32) -&gt; &amp;'static str {
    match i {
    0 =&gt; &quot;none&quot;,
    1 =&gt; &quot;one&quot;,
    _ =&gt; &quot;many&quot;
    }
}

#}</code></pre></pre>
<p>That works for the special case of static strings, but this is very restrictive.</p>
<p>However we can specify that the lifetime of the reference is <em>as least as long</em> as that of
the struct itself.</p>
<pre><pre class="playpen"><code class="language-rust">// life3.rs

#[derive(Debug)]
struct A &lt;'a&gt; {
    s: &amp;'a str
}

fn main() {
    let s = &quot;I'm a little string&quot;.to_string();
    let a = A { s: &amp;s };

    println!(&quot;{:?}&quot;, a);
}
</code></pre></pre>
<p>Lifetimes are conventionally called 'a','b',etc but you could just as well called it
'me' here.</p>
<p>After this point, our <code>a</code> struct and the <code>s</code> string are bound by a strict contract:
<code>a</code> borrows from <code>s</code>, and cannot outlive it.</p>
<p>With this struct definition, we would like to write a function that returns an <code>A</code> value:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn makes_a() -&gt; A {
    let string = &quot;I'm a little string&quot;.to_string();
    A { s: &amp;string }
}

#}</code></pre></pre>
<p>But <code>A</code> needs a lifetime - &quot;expected lifetime parameter&quot;:</p>
<pre><code>  = help: this function's return type contains a borrowed value,
   but there is no value for it to be borrowed from
  = help: consider giving it a 'static lifetime
</code></pre>
<p><code>rustc</code> is giving advice, so we follow it:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn makes_a() -&gt; A&lt;'static&gt; {
    let string = &quot;I'm a little string&quot;.to_string();
    A { s: &amp;string }
}

#}</code></pre></pre>
<p>And now the error is</p>
<pre><code>8 |      A { s: &amp;string }
  |              ^^^^^^ does not live long enough
9 | }
  | - borrowed value only lives until here
</code></pre>
<p>There is no way that this could safely work, because <code>string</code> will be dropped when the
function ends, and no reference to <code>string</code> can outlast it.</p>
<p>You can usefully think of lifetime parameters as being part of the type of a value.</p>
<p>Sometimes it seems like a good idea for a struct to contain a value <em>and</em> a reference
that borrows from that value.
It's basically impossible because structs must be <em>moveable</em>, and any move will
invalidate the reference.  It isn't necessary to do this - for instance, if your
struct has a string field, and needs to provide slices, then it could keep indices
and have a method to generate the actual slices.</p>
<a class="header" href="./2-structs-enums-lifetimes.html#traits" name="traits"><h2>Traits</h2></a>
<p>Please note that Rust does not spell <code>struct</code> <em>class</em>. The keyword <code>class</code> in other
languages is so overloaded with meaning that it effectively shuts down original thinking.</p>
<p>Let's put it like this: Rust structs cannot <em>inherit</em> from other structs; they are
all unique types. There is no <em>sub-typing</em>. They are dumb data.</p>
<p>So how <em>does</em> one establish relationships between types? This is where <em>traits</em> come in.</p>
<p><code>rustc</code> often talks about <code>implementing X trait</code> and so it's time to talk about traits
properly.</p>
<p>Here's a little example of defining a trait and <em>implementing</em> it for a particular type.</p>
<pre><pre class="playpen"><code class="language-rust">// trait1.rs

trait Show {
    fn show(&amp;self) -&gt; String;
}

impl Show for i32 {
    fn show(&amp;self) -&gt; String {
        format!(&quot;four-byte signed {}&quot;, self)
    }
}

impl Show for f64 {
    fn show(&amp;self) -&gt; String {
        format!(&quot;eight-byte float {}&quot;, self)
    }
}

fn main() {
    let answer = 42;
    let maybe_pi = 3.14;
    let s1 = answer.show();
    let s2 = maybe_pi.show();
    println!(&quot;show {}&quot;, s1);
    println!(&quot;show {}&quot;, s2);
}
// show four-byte signed 42
// show eight-byte float 3.14
</code></pre></pre>
<p>It's pretty cool; we have <em>added a new method</em> to both <code>i32</code> and <code>f64</code>!</p>
<p>Getting comfortable with Rust involves learning the basic traits of the
standard library (they tend to hunt in packs.)</p>
<p><code>Debug</code> is very common.
We gave <code>Person</code> a default implementation with the
convenient <code>#[derive(Debug)]</code>, but say we want a <code>Person</code> to display as its full name:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
use std::fmt;

impl fmt::Debug for Person {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{}&quot;, self.full_name())
    }
}
...
    println!(&quot;{:?}&quot;, p);
    // John Smith

#}</code></pre></pre>
<p><code>write!</code> is a very useful macro - here <code>f</code> is anything that implements <code>Write</code>.
(This would also work with a <code>File</code> - or even a <code>String</code>.)</p>
<p><code>Display</code> controls how values are printed out with &quot;{}&quot; and is implemented
just like <code>Debug</code>. As a useful side-effect, <code>ToString</code> is automatically
implemented for anything implementing <code>Display</code>. So if we implement
<code>Display</code> for <code>Person</code>, then <code>p.to_string()</code> also works.</p>
<p><code>Clone</code> defines the method <code>clone</code>, and can simply be defined with
&quot;#[derive(Clone)]&quot; if all the fields themselves implement <code>Clone</code>.</p>
<a class="header" href="./2-structs-enums-lifetimes.html#example-iterator-over-floating-point-range" name="example-iterator-over-floating-point-range"><h2>Example: iterator over floating-point range</h2></a>
<p>We have met ranges before (<code>0..n</code>) but they don't work for floating-point values. (You
can <em>force</em> this but you'll end up with a step of 1.0 which is uninteresting.)</p>
<p>Recall the informal definition of an iterator; it is an struct with a <code>next</code> method
which may return <code>Some</code>-thing or <code>None</code>. In the process, the iterator itself gets modified,
it keeps the state for the iteration (like next index and so forth.) The data that
is being iterated over doesn't change usually, (But see <code>Vec::drain</code> for an
interesting iterator that does modify its data.)</p>
<p>And here is the formal definition: the <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Iterator trait</a>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    ...
}

#}</code></pre></pre>
<p>Here we meet an <a href="https://doc.rust-lang.org/stable/book/associated-types.html">associated type</a> of the <code>Iterator</code> trait.
This trait must work for any type, so you must specify that return type somehow.
The method <code>next</code> can then be written without using a
particular type - instead it refers to that type parameter's <code>Item</code> via <code>Self</code>.</p>
<p>The iterator trait for <code>f64</code> is written <code>Iterator&lt;Item=f64&gt;</code>, which can be read as
&quot;an Iterator with its associated type Item set to f64&quot;.</p>
<p>The <code>...</code> refers to the <em>provided methods</em> of <code>Iterator</code>. You only need to define <code>Item</code>
and <code>next</code>, and the provided methods are defined for you.</p>
<pre><pre class="playpen"><code class="language-rust">// trait3.rs

struct FRange {
    val: f64,
    end: f64,
    incr: f64
}

fn range(x1: f64, x2: f64, skip: f64) -&gt; FRange {
    FRange {val: x1, end: x2, incr: skip}
}

impl Iterator for FRange {
    type Item = f64;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let res = self.val;
        if res &gt;= self.end {
            None
        } else {
            self.val += self.incr;
            Some(res)
        }
    }
}


fn main() {
    for x in range(0.0, 1.0, 0.1) {
        println!(&quot;{} &quot;, x);
    }
}
</code></pre></pre>
<p>And the rather messy looking result is</p>
<pre><code>0
0.1
0.2
0.30000000000000004
0.4
0.5
0.6
0.7
0.7999999999999999
0.8999999999999999
0.9999999999999999
</code></pre>
<p>This is because 0.1 is not precisely representable as a float, so a little formatting
help is needed. Replace the <code>println!</code> with this</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
println!(&quot;{:.1} &quot;, x);

#}</code></pre></pre>
<p>And we get cleaner output (this <a href="https://doc.rust-lang.org/std/fmt/index.html">format</a>
means 'one decimal after dot'.)</p>
<p>All of the default iterator methods are available, so we can collect these values into
a vector, map them, and so forth.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let v: Vec&lt;f64&gt; = range(0.0, 1.0, 0.1).map(|x| x.sin()).collect();

#}</code></pre></pre>
<a class="header" href="./2-structs-enums-lifetimes.html#generic-functions" name="generic-functions"><h2>Generic Functions</h2></a>
<p>We want a function which will dump out any value that implements <code>Debug</code>. Here is
a first attempt at a generic function, where we can pass a reference to <em>any</em> type
of value. <code>T</code> is a type parameter, which needs to be declared just after the
function name:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn dump&lt;T&gt; (value: &amp;T) {
    println!(&quot;value is {:?}&quot;,value);
}

let n = 42;
dump(&amp;n);

#}</code></pre></pre>
<p>However, Rust clearly knows nothing about this generic type <code>T</code>:</p>
<pre><code>error[E0277]: the trait bound `T: std::fmt::Debug` is not satisfied
...
   = help: the trait `std::fmt::Debug` is not implemented for `T`
   = help: consider adding a `where T: std::fmt::Debug` bound
</code></pre>
<p>For this to work, Rust needs to be told that <code>T</code> does in fact implement <code>Debug</code>!</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn dump&lt;T&gt; (value: &amp;T)
where T: std::fmt::Debug {
    println!(&quot;value is {:?}&quot;,value);
}

let n = 42;
dump(&amp;n);
// value is 42

#}</code></pre></pre>
<p>Rust generic functions need <em>trait bounds</em> on types - we are saying here that
&quot;T is any type that implements Debug&quot;. <code>rustc</code> is being very helpful, and
suggests exactly what bound needs to be provided.</p>
<p>Now that Rust knows the trait bounds for <code>T</code>, it can give you sensible compiler messages:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
struct Foo {
    name: String
}

let foo = Foo{name: &quot;hello&quot;.to_string()};

dump(&amp;foo)

#}</code></pre></pre>
<p>And the error is &quot;the trait <code>std::fmt::Debug</code> is not implemented for <code>Foo</code>&quot;.</p>
<p>Functions are already generic in dynamic languages because values carry their actual type around,
and the type checking happens at run-time - or fails miserably. For larger programs, we really
do want to know about problems at compile-time rather! Rather than sitting down calmly with
compiler errors, a programmer in these languages has to deal with problems that only
show up when the program is running. Murphy's Law then implies that these problems
will tend to happen at the most inconvenient/disastrous time.</p>
<p>The operation of squaring a number is generic:  <code>x*x</code> will work for integers,
floats and generally for anything that knows about the multiplication operator <code>*</code>.
But what are the type bounds?</p>
<pre><pre class="playpen"><code class="language-rust">// gen1.rs

fn sqr&lt;T&gt; (x: T) -&gt; T {
    x * x
}

fn main() {
    let res = sqr(10.0);
    println!(&quot;res {}&quot;,res);
}
</code></pre></pre>
<p>The first problem is that Rust does not know that <code>T</code> can be multiplied:</p>
<pre><code>error[E0369]: binary operation `*` cannot be applied to type `T`
 --&gt; gen1.rs:4:5
  |
4 |     x * x
  |     ^
  |
note: an implementation of `std::ops::Mul` might be missing for `T`
 --&gt; gen1.rs:4:5
  |
4 |     x * x
  |     ^
</code></pre>
<p>Following the advice of the compiler, let's constrain that type parameter using
<a href="https://doc.rust-lang.org/std/ops/trait.Mul.html">that trait</a>, which is used to implement the multiplication operator <code>*</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn sqr&lt;T&gt; (x: T) -&gt; T
where T: std::ops::Mul {
    x * x
}

#}</code></pre></pre>
<p>Which still doesn't work:</p>
<pre><code>rror[E0308]: mismatched types
 --&gt; gen2.rs:6:5
  |
6 |     x * x
  |     ^^^ expected type parameter, found associated type
  |
  = note: expected type `T`
  = note:    found type `&lt;T as std::ops::Mul&gt;::Output`
</code></pre>
<p>What <code>rustc</code> is saying that the type of <code>x*x</code> is the associated type <code>T::Output</code>, not <code>T</code>.
There's actually no reason that the type of <code>x*x</code> is the same as the type of <code>x</code>, e.g. the dot product
of two vectors is a scalar.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn sqr&lt;T&gt; (x: T) -&gt; T::Output
where T: std::ops::Mul {
    x * x
}

#}</code></pre></pre>
<p>and now the error is:</p>
<pre><code>error[E0382]: use of moved value: `x`
 --&gt; gen2.rs:6:7
  |
6 |     x * x
  |     - ^ value used here after move
  |     |
  |     value moved here
  |
  = note: move occurs because `x` has type `T`, which does not implement the `Copy` trait
</code></pre>
<p>So, we need to constrain the type even further!</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn sqr&lt;T&gt; (x: T) -&gt; T::Output
where T: std::ops::Mul + Copy {
    x * x
}

#}</code></pre></pre>
<p>And that (finally) works. Calmly listening to the compiler will often get you closer
to the magic point when ... things compile cleanly.</p>
<p>It <em>is</em> a bit simpler in C++:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
T sqr(x: T) {
    return x * x;
}
</code></pre>
<p>but (to be honest) C++ is adopting cowboy tactics here. C++ template errors are famously
bad, because all the compiler knows (ultimately) is that some operator or method is
not defined. The C++ committee knows this is a problem and so they are working
toward <a href="https://en.wikipedia.org/wiki/Concepts_(C%2B%2B)">concepts</a>, which are pretty
much like trait-constrained type parameters in Rust.</p>
<p>Rust generic functions may look a bit overwhelming at first, but being explicit means
you will know exactly what kind of values you can safely feed it, just by looking at the
definition.</p>
<p>These functions are called <em>monomorphic</em>, in constrast to <em>polymorphic</em>. The body of
the function is compiled separately for each unique type.  With polymorphic functions,
the same machine code works with each matching type, dynamically <em>dispatching</em>
the correct method.</p>
<p>Monomorphic produces faster code,
specialized for the particular type, and can often be <em>inlined</em>.  So when <code>sqr(x)</code> is
seen, it's effectively replaced with <code>x*x</code>.  The downside is that large generic
functions produce a lot of code, for each type used, which can result in <em>code bloat</em>.
As always, there are trade-offs; an experienced person learns to make the right choice
for the job.</p>
<a class="header" href="./2-structs-enums-lifetimes.html#simple-enums" name="simple-enums"><h2>Simple Enums</h2></a>
<p>Enums are types which have a few definite values. For instance, a direction has
only four possible values.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
enum Direction {
    Up,
    Down,
    Left,
    Right
}
...
    // `start` is type `Direction`
    let start = Direction::Left;

#}</code></pre></pre>
<p>They can have methods defined on them, just like structs.
The  <code>match</code> expression is the basic way to handle <code>enum</code> values.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
impl Direction {
    fn as_str(&amp;self) -&gt; &amp;'static str {
        match *self { // *self has type Direction
            Direction::Up =&gt; &quot;Up&quot;,
            Direction::Down =&gt; &quot;Down&quot;,
            Direction::Left =&gt; &quot;Left&quot;,
            Direction::Right =&gt; &quot;Right&quot;
        }
    }
}

#}</code></pre></pre>
<p>Punctuation matters. Note that <code>*</code> before <code>self</code>. It's easy to forget, because often
Rust will assume it (we said <code>self.first_name</code>, not <code>(*self).first_name</code>). However,
matching is a more exact business. Leaving it out would give a whole spew of messages,
which boil down to this type mismatch:</p>
<pre><code>   = note: expected type `&amp;Direction`
   = note:    found type `Direction`
</code></pre>
<p>This is because <code>self</code> has type <code>&amp;Direction</code>, so we have to throw in the <code>*</code> to
<em>deference</em> the type.</p>
<p>Like structs, enums can implement traits, and our friend <code>#[derive(Debug)]</code> can
be added to <code>Direction</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
        println!(&quot;start {:?}&quot;,start);
        // start Left

#}</code></pre></pre>
<p>So that <code>as_str</code> method isn't really necessary, since we can always get the name from <code>Debug</code>.
(But <code>as_str</code> does <em>not allocate</em>, which may be important.)</p>
<p>You should not assume any particular ordering here - there's no implied integer
'ordinal' value.</p>
<p>Here's a method which defines the 'successor' of each <code>Direction</code> value. The
very handy <em>wildcard use</em> temporarily puts the enum names into the method context:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn next(&amp;self) -&gt; Direction {
        use Direction::*;
        match *self {
            Up =&gt; Right,
            Right =&gt; Down,
            Down =&gt; Left,
            Left =&gt; Up
        }
    }
    ...

    let mut d = start;
    for _ in 0..8 {
        println!(&quot;d {:?}&quot;, d);
        d = d.next();
    }
    // d Left
    // d Up
    // d Right
    // d Down
    // d Left
    // d Up
    // d Right
    // d Down

#}</code></pre></pre>
<p>So this will cycle endlessly through the various directions in this particular, arbitrary,
order. It is (in fact) a very simple <em>state machine</em>.</p>
<p>These enum values can't be compared:</p>
<pre><code>assert_eq!(start, Direction::Left);

error[E0369]: binary operation `==` cannot be applied to type `Direction`
  --&gt; enum1.rs:42:5
   |
42 |     assert_eq!(start, Direction::Left);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
note: an implementation of `std::cmp::PartialEq` might be missing for `Direction`
  --&gt; enum1.rs:42:5
</code></pre>
<p>The solution is to say <code>#[derive(Debug,PartialEq)]</code> in front of <code>enum Direction</code>.</p>
<p>This is an important point - Rust user-defined types start out fresh and unadorned.
You give them sensible default behaviours by implementing the common traits. This
applies also to structs - if you ask for Rust to derive <code>PartialEq</code> for a struct it
will do the sensible thing, assume that all fields implement it and build up
a comparison. If this isn't so, or you want to redefine equality, then you are free
to define <code>PartialEq</code> explicitly.</p>
<p>Rust does 'C style enums' as well:</p>
<pre><pre class="playpen"><code class="language-rust">// enum2.rs

enum Speed {
    Slow = 10,
    Medium = 20,
    Fast = 50
}

fn main() {
    let s = Speed::Slow;
    let speed = s as u32;
    println!(&quot;speed {}&quot;, speed);
}
</code></pre></pre>
<p>They are initialized with an integer value, and can be converted into that integer
with a type cast.</p>
<p>You only need to give the first name a value, and thereafter the
value goes up by one each time:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
enum Difficulty {
    Easy = 1,
    Medium,  // is 2
    Hard   // is 3
}

#}</code></pre></pre>
<p>By the way, 'name' is too vague, like saying 'thingy' all the time. The proper term here
is <em>variant</em> - <code>Speed</code> has variants <code>Slow</code>,<code>Medium</code> and <code>Fast</code>.</p>
<p>These enums <em>do</em> have a natural ordering, but you have to ask nicely.
After placing <code>#[derive(PartialEq,PartialOrd)]</code> in front of <code>enum Speed</code>, then it's indeed
true that <code>Speed::Fast &gt; Speed::Slow</code> and <code>Speed::Medium != Speed::Slow</code>.</p>
<a class="header" href="./2-structs-enums-lifetimes.html#enums-in-their-full-glory" name="enums-in-their-full-glory"><h2>Enums in their Full Glory</h2></a>
<p>Rust enums in their full form are like C unions on steroids, like a Ferrari compared
to a Fiat Uno. Consider the problem of storing different values in a type-safe way.</p>
<pre><pre class="playpen"><code class="language-rust">// enum3.rs

#[derive(Debug)]
enum Value {
    Number(f64),
    Str(String),
    Bool(bool)
}

fn main() {
    use Value::*;
    let n = Number(2.3);
    let s = Str(&quot;hello&quot;.to_string());
    let b = Bool(true);

    println!(&quot;n {:?} s {:?} b {:?}&quot;, n,s,b);
}
// n Number(2.3) s Str(&quot;hello&quot;) b Bool(true)
</code></pre></pre>
<p>Again, this enum can only contain <em>one</em> of these values; its size will be the size of
the largest variant.</p>
<p>So far, not really a supercar, although it's cool that enums know how to print themselves
out. But they also know how <em>what kind</em> of value they contain, and <em>that</em> is the
superpower of <code>match</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn eat_and_dump(v: Value) {
    use Value::*;
    match v {
        Number(n) =&gt; println!(&quot;number is {}&quot;, n),
        Str(s) =&gt; println!(&quot;string is '{}'&quot;, s),
        Bool(b) =&gt; println!(&quot;boolean is {}&quot;, b)
    }
}
....
eat_and_dump(n);
eat_and_dump(s);
eat_and_dump(b);
//number is 2.3
//string is 'hello'
//boolean is true

#}</code></pre></pre>
<p>We like this <code>eat_and_dump</code> function, but we want to pass the value as a reference, because currently
a move takes place and the value is 'eaten':</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn dump(v: &amp;Value) {
    use Value::*;
    match *v {  // type of *v is Value
        Number(n) =&gt; println!(&quot;number is {}&quot;, n),
        Str(s) =&gt; println!(&quot;string is '{}'&quot;, s),
        Bool(b) =&gt; println!(&quot;boolean is {}&quot;, b)
    }
}

error[E0507]: cannot move out of borrowed content
  --&gt; enum3.rs:12:11
   |
12 |     match *v {
   |           ^^ cannot move out of borrowed content
13 |     Number(n) =&gt; println!(&quot;number is {}&quot;,n),
14 |     Str(s) =&gt; println!(&quot;string is '{}'&quot;,s),
   |         - hint: to prevent move, use `ref s` or `ref mut s`

#}</code></pre></pre>
<p>There are things you cannot do with borrowed references. Rust is not letting
you <em>extract</em> the string contained in the original value. It did not complain about <code>Number</code>
because it's happy to copy <code>f64</code>, but <code>String</code> does not implement <code>Copy</code>.</p>
<p>I mentioned earlier that <code>match</code> is picky about <em>exact</em> types;
here we follow the hint and things will work; now we are just borrowing a reference
to that contained string.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn dump(v: &amp;Value) {
    use Value::*;
    match *v {
        Number(n) =&gt; println!(&quot;number is {}&quot;, n),
        Str(ref s) =&gt; println!(&quot;string is '{}'&quot;, s),
        Bool(b) =&gt; println!(&quot;boolean is {}&quot;, b)
    }
}
    ....

    dump(&amp;s);
    // string is 'hello'

#}</code></pre></pre>
<p>Before we move on, filled with the euphoria of a successful Rust compilation, let's
pause a little. <code>rustc</code> is unusually good at generating errors that have enough
context for a human to <em>fix</em> the error without necessarily <em>understanding</em> the error.</p>
<p>The issue is a combination of the exactness of matching, with the determination of the
borrow checker to foil any attempt to break the Rules.  One of those Rules is that
you cannot yank out a value which belongs to some owning type. Some knowledge of
C++ is a hindrance here, since C++ will copy its way out of the problem, whether that
copy even <em>makes sense</em>.  You will get exactly the same error if you try to pull out
a string from a vector, say with <code>*v.get(0).unwrap()</code> (<code>*</code> because indexing returns references.)
It will simply not let you do this. (Sometimes <code>clone</code> isn't such a bad solution to this.)</p>
<p>(By the way, <code>v[0]</code> does not work for non-copyable values like strings for precisely this reason.
You must either borrow with <code>&amp;v[0]</code> or clone with <code>v[0].clone()</code>)</p>
<p>As for <code>match</code>, you can see <code>Str(s) =&gt;</code> as short for <code>Str(s: String) =&gt;</code>. A local variable
(often called a <em>binding</em>) is created.  Often that inferred type is cool, when you
eat up a value and extract its contents. But here we really needed is <code>s: &amp;String</code>, and the
<code>ref</code> is a hint that ensures this: we just want to borrow that string.</p>
<p>Here we do want to extract that string, and don't care about
the enum value afterwards. <code>_</code> as usual will match anything.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
impl Value {
    fn to_str(self) -&gt; Option&lt;String&gt; {
        match self {
        Value::Str(s) =&gt; Some(s),
        _ =&gt; None
        }
    }
}
    ...
    println!(&quot;s? {:?}&quot;, s.to_str());
    // s? Some(&quot;hello&quot;)
    // println!(&quot;{:?}&quot;, s) // error! s has moved...

#}</code></pre></pre>
<p>Naming matters - this is called <code>to_str</code>, not <code>as_str</code>. You can write a
method that just borrows that string as an <code>Option&lt;&amp;String&gt;</code> (The reference will need
the same lifetime as the enum value.)  But you would not call it <code>to_str</code>.</p>
<p>You can write <code>to_str</code> like this - it is completely equivalent:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn to_str(self) -&gt; Option&lt;String&gt; {
        if let Value::Str(s) = self {
            Some(s)
        } else {
            None
        }
    }

#}</code></pre></pre>
<a class="header" href="./2-structs-enums-lifetimes.html#more-about-matching" name="more-about-matching"><h2>More about Matching</h2></a>
<p>Recall that the values of a tuple can be extracted with '()':</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let t = (10,&quot;hello&quot;.to_string());
    ...
    let (n,s) = t;
    // t has been moved. It is No More
    // n is i32, s is String

#}</code></pre></pre>
<p>This is a special case of <em>destructuring</em>; we have some
data and wish to either pull it apart (like here) or just borrow its values.
Either way, we get the parts of a structure.</p>
<p>The syntax is like that used in <code>match</code>. Here
we are explicitly borrowing the values.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let (ref n,ref s) = t;
    // n and s are borrowed from t. It still lives!
    // n is &amp;i32, s is &amp;String

#}</code></pre></pre>
<p>Destructuring works with structs as well:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    struct Point {
        x: f32,
        y: f32
    }

    let p = Point{x:1.0,y:2.0};
    ...
    let Point{x,y} = p;
    // p still lives, since x and y can and will be copied
    // both x and y are f32

#}</code></pre></pre>
<p>Time to revisit <code>match</code> with some new patterns. The first two patterns are exactly like <code>let</code>
destructuring - it only matches tuples with first element zero, but <em>any</em> string;
the second adds an <code>if</code> so that it only matches <code>(1,&quot;hello&quot;)</code>.
Finally, just a variable matches <em>anything</em>. This is useful if the <code>match</code> applies
to an expression and you don't want to bind a variable to that expression. <code>_</code> works
like a variable but is ignored. It's a common
way to finish off a <code>match</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn match_tuple(t: (i32,String)) {
    let text = match t {
        (0, s) =&gt; format!(&quot;zero {}&quot;, s),
        (1, ref s) if s == &quot;hello&quot; =&gt; format!(&quot;hello one!&quot;),
        tt =&gt; format!(&quot;no match {:?}&quot;, tt),
        // or say _ =&gt; format!(&quot;no match&quot;) if you're not interested in the value
     };
    println!(&quot;{}&quot;, text);
}

#}</code></pre></pre>
<p>Why not just match against <code>(1,&quot;hello&quot;)</code>? Matching is an exact business, and the compiler
will complain:</p>
<pre><code>  = note: expected type `std::string::String`
  = note:    found type `&amp;'static str`
</code></pre>
<p>Why do we need <code>ref s</code>? It's a slightly obscure gotcha (look up the E00008 error) where
if you have an <em>if guard</em> you need to borrow, since the if guard happens in a different
context, a move will take place otherwise. It's a case of the implementation leaking
ever so slightly.</p>
<p>If the type <em>was</em> <code>&amp;str</code> then we match it directly:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    match (42,&quot;answer&quot;) {
        (42,&quot;answer&quot;) =&gt; println!(&quot;yes&quot;),
        _ =&gt; println!(&quot;no&quot;)
    };

#}</code></pre></pre>
<p>What applies to <code>match</code> applies to <code>if let</code>. This is a cool example, since if we
get a <code>Some</code>, we can match inside it and only extract the string from the tuple. So it
isn't necessary to have nested <code>if let</code> statements here. We use <code>_</code> because we aren't interested
in the first part of the tuple.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let ot = Some((2,&quot;hello&quot;.to_string());

    if let Some((_,ref s)) = ot {
        assert_eq!(s, &quot;hello&quot;);
    }
    // we just borrowed the string, no 'destructive destructuring'

#}</code></pre></pre>
<p>An interesting problem happens when using <code>parse</code> (or any function which needs to work
out its return type from context)</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    if let Ok(n) = &quot;42&quot;.parse() {
        ...
    }

#}</code></pre></pre>
<p>So what's the type of <code>n</code>? You have to give a hint somehow - what kind of integer? Is it
even an integer?</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    if let Ok(n) = &quot;42&quot;.parse::&lt;i32&gt;() {
        ...
    }

#}</code></pre></pre>
<p>This somewhat non-elegant syntax is called the 'turbofish operator'.</p>
<p>If you are in a function returning <code>Result</code>, then the question-mark operator provides a much
more elegant solution:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let n: i32 = &quot;42&quot;.parse()?;

#}</code></pre></pre>
<p>However, the parse error needs to be convertible to the error type of the <code>Result</code>, which is a topic
we'll take up later when discussing <a href="6-error-handling.html">error handling</a>.</p>
<a class="header" href="./2-structs-enums-lifetimes.html#closures" name="closures"><h2>Closures</h2></a>
<p>A great deal of Rust's power comes from <em>closures</em>. In their simplest form, they
act like shortcut functions:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let f = |x| x * x;

    let res = f(10);

    println!(&quot;res {}&quot;, res);
    // res 100

#}</code></pre></pre>
<p>There are no explicit types in this example - everything is deduced, starting with the
integer literal 10.</p>
<p>We get an error if we call <code>f</code> on different types - Rust has already decided that
<code>f</code> must be called on an integer type:</p>
<pre><code>    let res = f(10);

    let resf = f(1.2);
  |
8 |     let resf = f(1.2);
  |                  ^^^ expected integral variable, found floating-point variable
  |
  = note: expected type `{integer}`
  = note:    found type `{float}`

</code></pre>
<p>So, the first call fixes the type of the argument <code>x</code>. It's equivalent to this function:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn f (x: i32) -&gt; i32 {
        x * x
    }

#}</code></pre></pre>
<p>But there's a big difference between functions and closures, <em>apart</em> from the need for explicit typing.
Here we evaluate a linear function:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let m = 2.0;
    let c = 1.0;

    let lin = |x| m*x + c;

    println!(&quot;res {} {}&quot;, lin(1.0), lin(2.0));
    // res 3 5

#}</code></pre></pre>
<p>You cannot do this with the explicit <code>fn</code> form - it does not know about variables
in the enclosing scope. The closure has <em>borrowed</em> <code>m</code> and <code>c</code> from its context.</p>
<p>Now, what's the type of <code>lin</code>? Only <code>rustc</code> knows.
Under the hood, a closure is a <em>struct</em> that is callable ('implements the call operator').
It behaves as if it was written out like this:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
struct MyAnonymousClosure1&lt;'a&gt; {
    m: &amp;'a f64,
    c: &amp;'a f64
}

impl MyAnonymousClosure1 {
    fn call(&amp;self, x: f64) {
        self.m * x  + self.c
    }
}

#}</code></pre></pre>
<p>The compiler is certainly being helpful, turning simple closure syntax into all
that code! You do need to know that a closure is a <em>struct</em> and it <em>borrows</em> values
from its environment. And that therefore it has a <em>lifetime</em>.</p>
<p>All closures are unique types, but they have traits in common.
So even though we don't know the exact type, we know the generic constraint:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn apply&lt;F&gt;(x: f64, f: F) -&gt; f64
where F: Fn(f64)-&gt;f64  {
    f(x)
}
...
    let res1 = apply(3.0,lin);
    let res2 = apply(3.14, |x| x.sin());

#}</code></pre></pre>
<p>In English: <code>apply</code> works for <em>any</em> type <code>T</code> such that <code>T</code> implements <code>Fn(f64)-&gt;f64</code> - that
is, is a function which takes <code>f64</code> and returns <code>f64</code>.</p>
<p>After the call to <code>apply(3.0,lin)</code>, trying to access <code>lin</code> gives an interesting error:</p>
<pre><code>    let l = lin;
error[E0382]: use of moved value: `lin`
  --&gt; closure2.rs:22:9
   |
16 |     let res = apply(3.0,lin);
   |                         --- value moved here
...
22 |     let l = lin;
   |         ^ value used here after move
   |
   = note: move occurs because `lin` has type
    `[closure@closure2.rs:12:15: 12:26 m:&amp;f64, c:&amp;f64]`,
     which does not implement the `Copy` trait

</code></pre>
<p>That's it, <code>apply</code> ate our closure. And there's the actual type of the struct that
<code>rustc</code> made up to implement it. Always thinking of closures as structs is helpful.</p>
<p>Calling a closure is a <em>method call</em>:  the three kinds of function traits
correspond to the three kinds of methods:</p>
<ul>
<li><code>Fn</code> struct passed as <code>&amp;self</code></li>
<li><code>FnMut</code> struct passed as <code>&amp;mut self</code></li>
<li><code>FnOnce</code> struct passed as <code>self</code></li>
</ul>
<p>So it's possible for a closure to mutate its <em>captured</em> references:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn mutate&lt;F&gt;(mut f: F)
    where F: FnMut() {
        f()
    }
    let mut s = &quot;world&quot;;
    mutate(|| s = &quot;hello&quot;);
    assert_eq!(s, &quot;hello&quot;);

#}</code></pre></pre>
<p>Note that <code>mut</code> - <code>f</code> needs to be mutable for this to work.</p>
<p>However, you cannot escape the rules for borrowing. Consider this:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let mut s = &quot;world&quot;;

// closure does a mutable borrow of s
let mut changer = || s = &quot;world&quot;;

changer();
// does an immutable borrow of s
assert_eq!(s, &quot;world&quot;);

#}</code></pre></pre>
<p>Can't be done! The error is that we cannot borrow <code>s</code>
in the assert statement, because it has been previously borrowed by the
closure <code>changer</code> as mutable. As long as that closure lives, no other
code can access <code>s</code>, so the solution is to control that lifetime by
putting the closure in a limited scope:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let mut s = &quot;world&quot;;
{
    let mut changer = || s = &quot;world&quot;;
    changer();
}
assert_eq!(s, &quot;world&quot;);

#}</code></pre></pre>
<p>At this point, if you are used to languages like JavaScript or Lua, you may wonder at the
complexity of Rust closures compared with how straightforward they are in those languages.
This is the necessary cost of Rust's promise to not sneakily make any allocations. In JavaScript,
the equivalent <code>mutate(function() {s = &quot;hello&quot;;})</code> will always result in a dynamically
allocated closure.</p>
<p>Sometimes you don't want a closure to borrow those variables, but instead <em>move</em> them.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let name = &quot;dolly&quot;.to_string();
    let age = 42;

    let c = move || {
        println!(&quot;name {} age {}&quot;, name,age);
    };

    c();

    println!(&quot;name {}&quot;,name);

#}</code></pre></pre>
<p>And the error at the last <code>println</code> is: &quot;use of moved value: <code>name</code>&quot;. So one solution
here - if we <em>did</em> want to keep <code>name</code> alive - is to move a cloned copy into the closure:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let cname = name.to_string();
    let c = move || {
        println!(&quot;name {} age {}&quot;,cname,age);
    };

#}</code></pre></pre>
<p>Why are moved closures needed? Because we might need to call them at a point where
the original context no longer exists.
A classic case is when creating a <em>thread</em>.
A moved closure does not borrow, so does not have a lifetime.</p>
<p>A major use of closures is within iterator methods. Recall the <code>range</code> iterator we
defined to go over a range of floating-point numbers. It's straightforward to operate
on this (or any other iterator) using closures:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let sine: Vec&lt;f64&gt; = range(0.0,1.0,0.1).map(|x| x.sin()).collect();

#}</code></pre></pre>
<p><code>map</code> isn't defined on vectors (although it's easy enough to create a trait that does this),
because then <em>every</em> map  will create a new vector.  This way, we have a choice. In this
sum, no temporary objects are created:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
 let sum: f64 = range(0.0,1.0,0.1).map(|x| x.sin()).sum();

#}</code></pre></pre>
<p>It will (in fact) be as fast as writing it out as an explicit loop! That performance
guarantee would be impossible if Rust closures were as 'frictionless'
as Javascript closures.</p>
<p><code>filter</code> is another useful iterator method - it only lets through values that match
a condition:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let tuples = [(10,&quot;ten&quot;),(20,&quot;twenty&quot;),(30,&quot;thirty&quot;),(40,&quot;forty&quot;)];
    let iter = tuples.iter().filter(|t| t.0 &gt; 20).map(|t| t.1);

    for name in iter {
        println!(&quot;{} &quot;, name);
    }
    // thirty
    // forty

#}</code></pre></pre>
<a class="header" href="./2-structs-enums-lifetimes.html#the-three-kinds-of-iterators" name="the-three-kinds-of-iterators"><h2>The Three Kinds of Iterators</h2></a>
<p>The three kinds correspond (again) to the three basic argument types. Assume we
have a vector of <code>String</code> values. Here are the iterator types explicitly, and
then <em>implicitly</em>, together with the actual type returned by the iterator.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
for s in vec.iter() {...} // &amp;String
for s in vec.iter_mut() {...} // &amp;mut String
for s in vec.into_iter() {...} // String

// implicit!
for s in &amp;vec {...} // &amp;String
for s in &amp;mut vec {...} // &amp;mut String
for s in vec {...} // String

#}</code></pre></pre>
<p>Personally I prefer being explicit, but it's important to understand both forms,
and their implications.</p>
<p><code>into_iter</code> <em>consumes</em> the vector and extracts its strings,
and so afterwards the vector is no longer available - it has been moved. It's
a definite gotcha for Pythonistas used to saying <code>for s in vec</code>!</p>
<p>So the
implicit form <code>for s in &amp;vec</code> is usually the one you want, just as <code>&amp;T</code> is a good
default in passing arguments to functions.</p>
<p>It's important to understand how the three kinds works because Rust relies heavily
on type deduction - you won't often see explicit types in closure arguments. And this
is a Good Thing, because it would be noisy if all those types were explicitly
<em>typed out</em>. However, the price of this compact code is that you need to know
what the implicit types actually are!</p>
<p><code>map</code> takes whatever value the iterator returns and converts it into something else,
but <code>filter</code> takes a <em>reference</em> to that value. In this case, we're using <code>iter</code> so
the iterator item type is <code>&amp;String</code>. Note that <code>filter</code> receives a reference to this type.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
for n in vec.iter().map(|x: &amp;String| x.len()) {...} // n is usize
for s in vec.iter().filter(|x: &amp;&amp;String| x.len() &gt; 2) { // s is &amp;String
...
}

#}</code></pre></pre>
<p>When calling methods, Rust will derefence automatically, so the problem isn't obvious.
But <code>|x: &amp;&amp;String| x == &quot;one&quot;|</code> will <em>not</em> work, because operators are more strict
about type matching. <code>rustc</code> will complain that there is no such operator that
compares <code>&amp;&amp;String</code> and <code>&amp;str</code>. So you need an explicit deference to make that <code>&amp;&amp;String</code>
into a <code>&amp;String</code> which <em>does</em> match.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
for s in vec.iter().filter(|x: &amp;&amp;String| *x == &quot;one&quot;) {...}
// same as
for s in vec.iter().filter(|x| *x == &quot;one&quot;) {...}

#}</code></pre></pre>
<p>If you leave out the explicit type, you can modify the argument so that the type of <code>s</code>
is now <code>&amp;String</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
for s in vec.iter().filter(|&amp;x| x == &quot;one&quot;)

#}</code></pre></pre>
<p>And that's usually how you will see it written.</p>
<a class="header" href="./2-structs-enums-lifetimes.html#structs-with-dynamic-data" name="structs-with-dynamic-data"><h2>Structs with Dynamic Data</h2></a>
<p>A most powerful technique is <em>a struct that contain references to itself</em>.</p>
<p>Here is the basic building block of a <em>binary tree</em>, expressed in C (everyone's
favourite old relative with a frightening fondness for using power tools without
protection.)</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    struct Node {
        const char *payload;
        struct Node *left;
        struct Node *right;
    };

#}</code></pre></pre>
<p>You can not do this by <em>directly</em> including <code>Node</code> fields, because then the size of
<code>Node</code> depends on the size of <code>Node</code>... it just doesn't compute. So we use pointers
to <code>Node</code> structs, since the size of a pointer is always known.</p>
<p>If <code>left</code> isn't <code>NULL</code>, the <code>Node</code> will have a left pointing to another node, and so
moreorless indefinitely.</p>
<p>Rust does not do <code>NULL</code> (at least not <em>safely</em>) so it's clearly a job for <code>Option</code>.
But you cannot just put a <code>Node</code> in that <code>Option</code>, because we don't know the size
of <code>Node</code> (and so forth.)  This is a job for <code>Box</code>, since it contains an allocated
pointer to the data, and always has a fixed size.</p>
<p>So here's the Rust equivalent, using <code>type</code> to create an alias:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
type NodeBox = Option&lt;Box&lt;Node&gt;&gt;;

#[derive(Debug)]
struct Node {
    payload: String,
    left: NodeBox,
    right: NodeBox
}

#}</code></pre></pre>
<p>(Rust is forgiving in this way - no need for forward declarations.)</p>
<p>And a first test program:</p>
<pre><pre class="playpen"><code class="language-rust">impl Node {
    fn new(s: &amp;str) -&gt; Node {
        Node{payload: s.to_string(), left: None, right: None}
    }

    fn boxer(node: Node) -&gt; NodeBox {
        Some(Box::new(node))
    }

    fn set_left(&amp;mut self, node: Node) {
        self.left = Self::boxer(node);
    }

    fn set_right(&amp;mut self, node: Node) {
        self.right = Self::boxer(node);
    }

}


fn main() {
    let mut root = Node::new(&quot;root&quot;);
    root.set_left(Node::new(&quot;left&quot;));
    root.set_right(Node::new(&quot;right&quot;));

    println!(&quot;arr {:#?}&quot;, root);
}
</code></pre></pre>
<p>The output is surprisingly pretty, thanks to &quot;{:#?}&quot; ('#' means 'extended'.)</p>
<pre><code>root Node {
    payload: &quot;root&quot;,
    left: Some(
        Node {
            payload: &quot;left&quot;,
            left: None,
            right: None
        }
    ),
    right: Some(
        Node {
            payload: &quot;right&quot;,
            left: None,
            right: None
        }
    )
}
</code></pre>
<p>Now, what happens when <code>root</code> is dropped? All fields are dropped; if the 'branches' of
the tree are dropped, they drop <em>their</em> fields and so on. <code>Box::new</code> may be the
closest you will get to a <code>new</code> keyword, but we have no need for <code>delete</code> or <code>free</code>.</p>
<p>We must now work out a use for this tree. Note that strings can be ordered:
'bar' &lt; 'foo', 'abba' &gt; 'aardvark'; so-called 'alphabetical order'. (Strictly speaking, this
is <em>lexical order</em>, since human languages are very diverse and have strange rules.)</p>
<p>Here is a method which inserts nodes in lexical order of the strings. We compare the new data
to the current node - if it's less, then we try to insert on the left, otherwise try to insert
on the right. There may be no node on the left, so then <code>set_left</code> and so forth.</p>
<pre><pre class="playpen"><code class="language-rust">    fn insert(&amp;mut self, data: &amp;str) {
        if data &lt; &amp;self.payload {
            match self.left {
                Some(ref mut n) =&gt; n.insert(data),
                None =&gt; self.set_left(Self::new(data)),
            }
        } else {
            match self.right {
                Some(ref mut n) =&gt; n.insert(data),
                None =&gt; self.set_right(Self::new(data)),
            }
        }
    }

    ...
    fn main() {
        let mut root = Node::new(&quot;root&quot;);
        root.insert(&quot;one&quot;);
        root.insert(&quot;two&quot;);
        root.insert(&quot;four&quot;);

        println!(&quot;root {:#?}&quot;, root);
    }
</code></pre></pre>
<p>Note the <code>match</code> - we're pulling out a mutable reference to the box, if the <code>Option</code>
is <code>Some</code>, and applying the <code>insert</code> method. Otherwise, we need to create a new <code>Node</code>
for the left side and so forth. <code>Box</code> is a <em>smart</em> pointer; note that no 'unboxing' was
needed to call <code>Node</code> methods on it!</p>
<p>And here's the output tree:</p>
<pre><code>root Node {
    payload: &quot;root&quot;,
    left: Some(
        Node {
            payload: &quot;one&quot;,
            left: Some(
                Node {
                    payload: &quot;four&quot;,
                    left: None,
                    right: None
                }
            ),
            right: None
        }
    ),
    right: Some(
        Node {
            payload: &quot;two&quot;,
            left: None,
            right: None
        }
    )
}
</code></pre>
<p>The strings that are 'less' than other strings get put down the left side, otherwise
the right side.</p>
<p>Time for a visit. This is <em>in-order traversal</em> - we visit the left, do something on
the node, and then visit the right.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn visit(&amp;self) {
        if let Some(ref left) = self.left {
            left.visit();
        }
        println!(&quot;'{}'&quot;, self.payload);
        if let Some(ref right) = self.right {
            right.visit();
        }
    }
    ...
    ...
    root.visit();
    // 'four'
    // 'one'
    // 'root'
    // 'two'

#}</code></pre></pre>
<p>So we're visiting the strings in order! Please note the reappearance of <code>ref</code> - <code>if let</code>
uses exactly the same rules as <code>match</code>.</p>
<a class="header" href="./2-structs-enums-lifetimes.html#generic-structs" name="generic-structs"><h2>Generic Structs</h2></a>
<p>Consider the previous example of a binary tree. It would be <em>seriously irritating</em> to
have to rewrite it for all possible kinds of payload.
So here's our generic <code>Node</code> with its type parameter <code>T</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
type NodeBox&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

#[derive(Debug)]
struct Node&lt;T&gt; {
    payload: T,
    left: NodeBox&lt;T&gt;,
    right: NodeBox&lt;T&gt;
}

#}</code></pre></pre>
<p>The implementation shows the difference between the languages. The fundamental operation
on the payload is comparison, so T must be comparable with <code>&lt;</code>, i.e. implements <code>PartialOrd</code>.
The type parameter must be declared in the <code>impl</code> block with its constraints:</p>
<pre><pre class="playpen"><code class="language-rust">impl &lt;T: PartialOrd&gt; Node&lt;T&gt; {
    fn new(s: T) -&gt; Node&lt;T&gt; {
        Node{payload: s, left: None, right: None}
    }

    fn boxer(node: Node&lt;T&gt;) -&gt; NodeBox&lt;T&gt; {
        Some(Box::new(node))
    }

    fn set_left(&amp;mut self, node: Node&lt;T&gt;) {
        self.left = Self::boxer(node);
    }

    fn set_right(&amp;mut self, node: Node&lt;T&gt;) {
        self.right = Self::boxer(node);
    }

    fn insert(&amp;mut self, data: T) {
        if data &lt; self.payload {
            match self.left {
                Some(ref mut n) =&gt; n.insert(data),
                None =&gt; self.set_left(Self::new(data)),
            }
        } else {
            match self.right {
                Some(ref mut n) =&gt; n.insert(data),
                None =&gt; self.set_right(Self::new(data)),
            }
        }
    }
}


fn main() {
    let mut root = Node::new(&quot;root&quot;.to_string());
    root.insert(&quot;one&quot;.to_string());
    root.insert(&quot;two&quot;.to_string());
    root.insert(&quot;four&quot;.to_string());

    println!(&quot;root {:#?}&quot;, root);
}
</code></pre></pre>
<p>So generic structs need their type parameter(s) specified
in angle brackets, like C++. Rust is usually smart enough to work out
that type parameter from context - it knows it has a <code>Node&lt;T&gt;</code>, and knows
that its <code>insert</code> method is passed <code>T</code>. The first call of <code>insert</code> nails
down <code>T</code> to be <code>String</code>. If any further calls are inconsistent it will complain.</p>
<p>But you do need to constrain that type appropriately!</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="./1-basics.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="./3-filesystem.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="./1-basics.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="./3-filesystem.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
