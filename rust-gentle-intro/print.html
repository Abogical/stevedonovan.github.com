<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Threads, Networking and Sharing - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="./readme.html">Introduction</a></li><li><a href="./1-basics.html"><strong>1.</strong> Basics</a></li><li><a href="./2-structs-enums-lifetimes.html"><strong>2.</strong> Structs, Enums and Matching</a></li><li><a href="./3-filesystem.html"><strong>3.</strong> Filesystem and Processes</a></li><li><a href="./4-modules.html"><strong>4.</strong> Modules and Cargo</a></li><li><a href="./5-stdlib-containers.html"><strong>5.</strong> Standard Library Containers</a></li><li><a href="./6-error-handling.html"><strong>6.</strong> Error Handling</a></li><li><a href="./7-shared-and-networking.html"><strong>7.</strong> Threads, Networking and Sharing</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#a-gentle-introduction-to-rust" name="a-gentle-introduction-to-rust"><h1>A Gentle Introduction To Rust</h1></a>
<a class="header" href="print.html#why-learn-a-new-programming-language" name="why-learn-a-new-programming-language"><h2>Why learn a new Programming Language?</h2></a>
<p>The aim of this tutorial is to take you to a place where you can read and write
enough Rust to fully appreciate the excellent learning resources available
online, in particular <a href="https://doc.rust-lang.org/stable/book/">The Book</a>.
It's an opportunity to <em>try before you buy</em>, and get enough feeling for the
power of the language to want to go deeper.</p>
<p>As Einstein might have said, &quot;As gentle as possible, but no gentler.&quot;. There is a
lot of new stuff to learn here, and it's different enough to require some
rearrangement of your mental furniture. By 'gentle' I mean that the features are
presented practically with examples; as we encounter difficulties, I hope to
show how Rust solves these problems. It is important to understand the problems before
the solutions make sense. To put it in flowery language, we are going for a hike
in hilly country and I will point out some interesting rock formations on the way,
with only a few geology lectures. There will be some uphill but the view will be
inspiring; the community is unusually pleasant and happy to help.</p>
<p>Why learn a new programming language? It is an investment of time and energy
and that needs some justification. Even if you do not immediately land
a cool job using that language, it stretches the mental muscles and makes you a
better programmer. That seems a poor kind of return-on-investment but if you're
not learning something <em>genuinely</em> new all the time then you will stagnate and be
like the person who has ten years of experience in doing the same thing over and over.</p>
<a class="header" href="print.html#where-rust-shines" name="where-rust-shines"><h2>Where Rust Shines</h2></a>
<p>Rust is a statically and strongly typed systems programming language. <em>statically</em>
means that all types are known at compile-time, <em>strongly</em> means that these types
are designed to make it harder to write incorrect programs. A successful compilation
means you have a much better guarantee of correctness than with a cowboy language
like C. <em>systems</em> means generating the best possible machine code with full control
of memory use.  So the uses are pretty hardcore: operating systems, device drivers
and embedded systems that might not even have an operating system.  However, it's
actually a very pleasant language to write normal application code in as well.</p>
<p>The big difference from C and C++ is that Rust is <em>safe by default</em>; all memory accesses
are checked. It is not possible to corrupt memory by accident.</p>
<p>The unifying principles behind Rust are:</p>
<ul>
<li>strictly enforcing <em>safe borrowing</em> of data</li>
<li>functions, methods and closures to operate on data</li>
<li>tuples, structs and enums to aggregate data</li>
<li>pattern matching to select and destructure data</li>
<li>traits to define <em>behaviour</em> on data</li>
</ul>
<p>There is a fast-growing ecosystem of available libraries through Cargo
but here we will concentrate on the core principles of the language
by learning to use the standard library. My advice is to write <em>lots of small programs</em>,
so learning to use <code>rustc</code> directly is a core skill. When doing the examples in this
tutorial I defined a little script called <code>rrun</code> which does a compilation and runs
the result:</p>
<pre><code>rustc $1.rs &amp;&amp; ./$1
</code></pre>
<a class="header" href="print.html#setting-up" name="setting-up"><h2>Setting Up</h2></a>
<p>This tutorial assumes that you have Rust installed locally. Fortunately this is
<a href="https://www.rust-lang.org/en-US/downloads.html">very straightforward</a>.</p>
<pre><code>$ curl https://sh.rustup.rs -sSf | sh
$ rustup component add rust-docs
</code></pre>
<p>I would recommend getting the default stable version; it's easy to switch later.</p>
<p>This gets the compiler, the Cargo package manager, the API documentation, and the Rust Book.
The journey of a thousand miles starts with one step, and this first step is painless.</p>
<p>You will probably already have an editor you like, and <a href="https://areweideyet.com/">basic Rust support</a>
is good. I'd suggest you start out with basic syntax highlighting at first, and
work up as your programs get larger.</p>
<p>Personally I'm a fan of <a href="https://www.geany.org/Download/Releases">Geany</a> which is
one of the few editors with Rust support out-of-the-box; it's particularly easy
on Linux since it's available through the package manager, but it works fine on
other platforms.</p>
<p>The main thing is knowing how to edit, compile and run Rust programs.
You learn to program with your <em>fingers</em>; type in
the code yourself, and learn to rearrange things efficiently with your editor.</p>
<p>Zed Shaw's <a href="https://learnpythonthehardway.org/book/intro.html">advice</a> about learning
to program in Python remains good, whatever the language. He says learning to program
is like learning a musical instrument - the secret is practice and persistence.
There's also good advice from Yoga and the soft martial arts like Tai Chi;
feel the strain, but don't over-strain. You are not building dumb muscle here.</p>
<a class="header" href="print.html#basics" name="basics"><h1>Basics</h1></a>
<a class="header" href="print.html#hello-world" name="hello-world"><h2>Hello, World!</h2></a>
<p>The original purpose of &quot;hello world&quot;, ever since the first C version was written,
was to test the compiler and run an actual program.</p>
<pre><pre class="playpen"><code class="language-rust">// hello.rs
fn main() {
    println!(&quot;Hello, World!&quot;);
}
</code></pre></pre>
<pre><code>$ rustc hello.rs
$ ./hello
Hello, World!
</code></pre>
<p>Rust is a curly-braces language with semicolons, C++-style comments and a <code>main</code>
function - so far, so familiar.  The exclamation mark indicates that this is a
<em>macro</em> call. For C++ programmers, this can be a turn-off, since they are used to
seriously stupid C macros - but I can ensure you that these are altogether more
capable and sane.</p>
<p>For anybody else,
it's probably &quot;Great, now I have to remember when to say bang!&quot;.  However, the
compiler is unusually helpful; if you leave out that exclamation, you get:</p>
<pre><code>error[E0425]: unresolved name `println`
 --&gt; hello2.rs:2:5
  |
2 |     println(&quot;Hello, World!&quot;);
  |     ^^^^^^^ did you mean the macro `println!`?

</code></pre>
<p>Learning a language means getting comfortable with its errors. Try to see the compiler
as a strict but friendly helper rather than a computer <em>shouting</em> at you, because you are
going to see a lot of red ink in the beginning.  It's much better for the compiler
to catch you out than for your program to blow up in front of actual humans.</p>
<p>The next step is to introduce a <em>variable</em>:</p>
<pre><pre class="playpen"><code class="language-rust">// let1.rs
fn main() {
    let answer = 42;
    println!(&quot;Hello {}&quot;, answer);
}

</code></pre></pre>
<p>Spelling mistakes are <em>compile</em> errors, not runtime errors like with dynamic languages
like Python or JavaScript.  This will save you a lot of stress later! And if I wrote
'answr' instead of 'answer', the compiler is actually <em>nice</em> about it:</p>
<pre><code>4 |     println!(&quot;Hello {}&quot;, answr);
  |                         ^^^^^ did you mean `answer`?

</code></pre>
<p>The <code>println!</code> macro takes a <a href="https://doc.rust-lang.org/std/fmt/index.html">format string</a>
and some values; it's very similar to the formatting used by Python 3.</p>
<p>Another very useful macro is <code>assert_eq!</code>. This is the workhorse of testing
in Rust; you <em>assert</em> that two things must be equal, and if not, <em>panic</em>.</p>
<pre><pre class="playpen"><code class="language-rust">// let2.rs
fn main() {
    let answer = 42;
    assert_eq!(answer,42);
}
</code></pre></pre>
<p>Which won't produce any input. But change 42 to 40:</p>
<pre><code>thread 'main' panicked at
'assertion failed: `(left == right)` (left: `42`, right: `40`)',
let2.rs:4
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>And that's our first <em>runtime error</em> in Rust.</p>
<a class="header" href="print.html#looping-and-ifing" name="looping-and-ifing"><h2>Looping and Ifing</h2></a>
<p>Anything interesting can be done more than once:</p>
<pre><pre class="playpen"><code class="language-rust">// for1.rs
fn main() {
    for i in 0..5 {
        println!(&quot;Hello {}&quot;, i);
    }
}
</code></pre></pre>
<p>The <em>range</em> is not inclusive, so <code>i</code> goes from 0 to 4. This is convenient in a
language which <em>indexes</em> things like arrays from 0.</p>
<p>And interesting things have to be done <em>conditionally</em>:</p>
<pre><pre class="playpen"><code class="language-rust">// for2.rs
fn main() {
    for i in 0..5 {
        if i % 2 == 0 {
            println!(&quot;even {}&quot;, i);
        } else {
            println!(&quot;odd {}&quot;, i);
        }
    }
}
</code></pre></pre>
<pre><code>even 0
odd 1
even 2
odd 3
even 4
</code></pre>
<p><code>i % 2</code> is zero if 2 can divide into <code>i</code> cleanly; Rust uses C-style operators.
There are <em>no</em> brackets around the condition, just like in Go, but
you <em>must</em> use curly brackets around the block.</p>
<p>This does the same, written in a more interesting way:</p>
<pre><pre class="playpen"><code class="language-rust">// for3.rs
fn main() {
    for i in 0..5 {
        let even_odd = if i % 2 == 0 {&quot;even&quot;} else {&quot;odd&quot;};
        println!(&quot;{} {}&quot;, even_odd, i);
    }
}
</code></pre></pre>
<p>Traditionally, programming languages have <em>statements</em> (like <code>if</code>) and
<em>expressions</em> (like <code>1+i</code>). In Rust, nearly everything has a value and can
be an expression.  The seriously ugly C 'ternary operator' <code>i % 2 == 0 ? &quot;even&quot; : &quot;odd&quot;</code>
is not needed.</p>
<p>Note that there aren't any semi-colons in those blocks!</p>
<a class="header" href="print.html#adding-things-up" name="adding-things-up"><h2>Adding Things Up</h2></a>
<p>Computers are very good at arithmetic. Here is a first attempt at adding all
the numbers from 0 to 4:</p>
<pre><pre class="playpen"><code class="language-rust">// add1.rs
fn main() {
    let sum = 0;
    for i in 0..5 {
        sum += i;
    }
    println!(&quot;sum is {}&quot;, sum);
}
</code></pre></pre>
<p>But it fails to compile:</p>
<pre><code>error[E0384]: re-assignment of immutable variable `sum`
 --&gt; add1.rs:5:9
3 |     let sum = 0;
  |         --- first assignment to `sum`
4 |     for i in 0..5 {
5 |         sum += i;
  |         ^^^^^^^^ re-assignment of immutable variable

</code></pre>
<p>'Immutable'? A variable that cannot <em>vary</em>?  <code>let</code> variables by default can only
be assigned a value when declared. Adding the magic word <code>mut</code> (<em>please</em> make
this variable mutable) does the trick:</p>
<pre><pre class="playpen"><code class="language-rust">// add2.rs
fn main() {
    let mut sum = 0;
    for i in 0..5 {
        sum += i;
    }
    println!(&quot;sum is {}&quot;, sum);
}
</code></pre></pre>
<p>This can be puzzling when coming from other languages, where variables can be
re-written by default. What makes something a 'variable' is that it gets assigned
a computed value at run-time - it is not a <em>constant</em>.
It is pretty much how the word is used in mathematics, like when we say
'let n be the largest number in set S'.</p>
<p>There is a reason for declaring variables to be <em>read-only</em> by default. In a larger
program, it gets hard to track where writes are taking place. So Rust makes things
like mutability ('write-ability') explicit. There's a lot of cleverness in the
language, but it never hides anything.</p>
<p>Rust is both statically-typed and strongly-typed - these are often confused, but
think of C (statically but weakly typed) and Python (dynamically but strongly typed).
In static types the type is known at compile time, and dynamic types are only known
at run time.</p>
<p>At the moment, it feels like Rust is <em>hiding</em> those types from you. What
exactly is the type of <code>i</code>?  The compiler can work it out, starting with 0,
with <em>type inference</em>, and comes up with <code>i32</code> (four byte signed integer.)</p>
<p>Let's make exactly one change - turn that <code>0</code> into <code>0.0</code>. Then we get errors:</p>
<pre><code>error[E0277]: the trait bound `{float}: std::ops::AddAssign&lt;{integer}&gt;` is not satisfied
 --&gt; add3.rs:5:9
  |
5 |         sum += i;
  |         ^^^^^^^^ the trait `std::ops::AddAssign&lt;{integer}&gt;` is not implemented for `{float}`
  |

</code></pre>
<p>Ok, so the honeymoon is over: what does this mean? Each operator (like <code>+=</code>) corresponds
to a <em>trait</em>, which is like an abstract interface that must be implemented for each concrete type.
We'll deal with traits in detail later, but here all you need to know is that
<code>AddAssign</code> is the name of the trait implementing the <code>+=</code> operator, and the error is saying
that floating point numbers do not implement this operator for a integer. (The full list of
operator traits is <a href="https://doc.rust-lang.org/std/ops/index.html">here</a>.</p>
<p>Again, Rust likes to be explicit - it will not silently convert that integer into a float for you.</p>
<p>We have to <em>cast</em> that value to a floating-point value explicitly.</p>
<pre><pre class="playpen"><code class="language-rust">// add3.rs
fn main() {
    let mut sum = 0.0;
    for i in 0..5 {
        sum += i as f64;
    }
    println!(&quot;sum is {}&quot;, sum);
}
</code></pre></pre>
<a class="header" href="print.html#get-explicit" name="get-explicit"><h2>Get Explicit</h2></a>
<p><em>Functions</em> are one place where the compiler will not work out types for you.
And this in fact was a deliberate decision, since languages like Haskell have
such powerful type inference that there are hardly any explicit type names. It's
a case of the language being somewhat more intelligent than its users, since
it's good Haskell style to put in a comment giving the function argument types. This feels
self-defeating.</p>
<p>Here is a simple user-defined function:</p>
<pre><pre class="playpen"><code class="language-rust">// fun1.rs

fn sqr(x: f64) -&gt; f64 {
    return x * x;
}

fn main() {
    let res = sqr(2.0);
    println!(&quot;square is {}&quot;, res);
}
</code></pre></pre>
<p>Rust (like Go, which it superficially resembles in many ways) goes back to an
older style of argument declaration, where the type follows the name. This is
how it was done in Algol-derived languages like Pascal.</p>
<p>Again, no integer-to-float conversions - if you replace the <code>0.0</code> with <code>0</code> then we
get a clear error:</p>
<pre><code>8 |     let res = sqr(0);
  |                   ^ expected f64, found integral variable
  |
</code></pre>
<p>You will actually rarely see functions written using a <code>return</code> statement. More
often, it will look like this:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn sqr(x: f64) -&gt; f64 {
    x * x
}

#}</code></pre></pre>
<p>This is because the body of the function (inside <code>{}</code>) has the value of its
last expression, just like with if-as-an-expression.</p>
<p>Since semicolons are inserted semi-automatically by human fingers, you might add it
here and get the following error:</p>
<pre><code>  |
3 | fn sqr(x: f64) -&gt; f64 {
  |                       ^ expected f64, found ()
  |
  = note: expected type `f64`
  = note:    found type `()`
help: consider removing this semicolon:
 --&gt; fun2.rs:4:8
  |
4 |     x * x;
  |       ^

</code></pre>
<p>The <code>()</code> type is the empty type, nada, <code>void</code>, zilch, nothing. Everything in Rust
has a value, but sometimes it's just nothing.  The compiler knows this is
a common mistake, and actually <em>helps</em> you.  (Anybody who has spent time with a
C++ compiler will know how <em>damn unusual</em> this is.)</p>
<p>A few more examples of this no-return expression style:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// absolute value of a floating-point number
fn abs(x: f64) -&gt; f64 {
    if x &gt; 0.0 {
        x
    } else {
        -x
    }
}

// ensure the number always falls in the given range
fn clamp(x: f64, x1: f64, x2: f64) -&gt; f64 {
    if x &lt; x1 {
        x1
    } else if x &gt; x2 {
        x2
    } else {
        x
    }
}

#}</code></pre></pre>
<p>It's not wrong to use <code>return</code>, but code is cleaner without it. You will still
use <code>return</code> for <em>returning early</em> from a function.</p>
<p>Some operations can be elegantly expressed <em>recursively</em>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn factorial(n: u64) -&gt; u64 {
    if n == 0 {
        1
    } else {
        n * factorial(n-1)
    }
}

#}</code></pre></pre>
<p>This can be a little strange at first, and the best thing is then to use pencil and paper
and work out some examples. It isn't usually the most <em>efficient</em> way to do that
operation however.</p>
<p>What if you want a function to modify one of its arguments?  Enter <em>mutable references</em>:</p>
<pre><pre class="playpen"><code class="language-rust">// fun4.rs

fn modifies(x: &amp;mut f64) {
    *x = 1.0;
}

fn main() {
    let mut res = 0.0;
    modifies(&amp;mut res);
    println!(&quot;res is {}&quot;, res);
}
</code></pre></pre>
<p>This is more how C would do it than C++. You have to explicitly pass the
reference (with <code>&amp;</code>) and explicitly <em>dereference</em> with <code>*</code>. And then throw in <code>mut</code>
because it's not the default. (I've always felt that C++ references are
too easy to miss compared to C.)</p>
<p>Basically, Rust is introducing some <em>friction</em> here, and not-so-subtly pushing
you towards returning values from functions directly.  Fortunately, Rust has
powerful ways to express things like &quot;operation succeeded and here's the result&quot;
so <code>&amp;mut</code> isn't needed that often.</p>
<p>The type-after-variable style applies to <code>let</code> as well, when you really want to nail
down the type of a variable:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let bigint: i64 = 0;

#}</code></pre></pre>
<a class="header" href="print.html#learning-where-to-find-the-ropes" name="learning-where-to-find-the-ropes"><h2>Learning Where to Find the Ropes</h2></a>
<p>It's time to start using the documentation. This will be installed on your machine,
and you can use <code>rustup doc --std</code> to open it in a browser.</p>
<p>Note the <em>search</em> field at the top, since this
is going to be your friend; it operates completely offline.</p>
<p>Let's say we want to see where the mathematical
functions are, so search for 'cos'. The first two hits show it defined for both
single and double-precision floating point numbers.  It is defined on the
<em>value itself</em> as a method, like so:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let pi = 3.1416;
let x = pi/2.0;
let cosine = x.cos();

#}</code></pre></pre>
<p>And the result will be sort-of zero; we obviously need a more authoritative source
of pi-ness!</p>
<p>Let me quote the example given for <code>cos</code>, but written as a complete program
( <code>assert!</code> is a cousin of <code>assert_eq!</code>; the expression must be true):</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 2.0 * std::f64::consts::PI;

    let abs_difference = (x.cos() - 1.0).abs();

    assert!(abs_difference &lt; 1e-10);
}
</code></pre></pre>
<p><code>std::f64::consts::PI</code> is a mouthful! <code>::</code> means much the same as it does in C++,
(often written using '.' in other languages) - it is a <em>fully qualified name</em>. We get
this full name from the second hit on searching for <code>PI</code>.</p>
<p>Up to now, our little Rust programs have been free of all that <code>import</code> and
<code>include</code> stuff that tends to slow down the discussion of 'Hello World' programs.
Let's make this program more readable with a <code>use</code> statement:</p>
<pre><pre class="playpen"><code class="language-rust">use std::f64::consts;

fn main() {
    let x = 2.0 * consts::PI;

    let abs_difference = (x.cos() - 1.0).abs();

    assert!(abs_difference &lt; 1e-10);
}
</code></pre></pre>
<p>Why haven't we needed to do this up to now?
This is because Rust helpfully makes a lot of basic functionality visible without
explicit <code>use</code> statements.</p>
<a class="header" href="print.html#arrays-and-slices" name="arrays-and-slices"><h2>Arrays and Slices</h2></a>
<p>All statically-typed languages have <em>arrays</em>, which are values packed nose to tail
in memory. Arrays are <em>indexed</em> from zero:</p>
<pre><pre class="playpen"><code class="language-rust">// array1.rs
fn main() {
    let arr = [10, 20, 30, 40];
    let first = arr[0];
    println!(&quot;first {}&quot;, first);

    for i in 0..4 {
        println!(&quot;[{}] = {}&quot;, i,arr[i]);
    }
    println!(&quot;length {}&quot;, arr.len());
}
</code></pre></pre>
<p>And the output is:</p>
<pre><code>first 10
[0] = 10
[1] = 20
[2] = 30
[3] = 40
length 4
</code></pre>
<p>In this case, Rust knows <em>exactly</em> how big the array is and if you try to
access <code>arr[4]</code> it will be a <em>compile error</em>.</p>
<p>Learning a new language often involves <em>unlearning</em> mental habits from languages
you already know; if you are a Pythonista, then those brackets say <code>List</code>. We will
come to the Rust equivalent of <code>List</code> soon, but arrays are not the droids you're looking
for; they are <em>fixed in size</em>. They can be <em>mutable</em> (if we ask nicely) but you
cannot add new elements.</p>
<p>Arrays are not used that often in Rust, because the type of an array includes its
size.  The type of the array in the example is
<code>[i32; 4]</code>; the type of <code>[10, 20]</code> would be <code>[i32; 2]</code> and so forth: they
have <em>different types</em>.  So they are basically bastards to pass around as
function arguments.</p>
<p>What <em>are</em> used often are <em>slices</em>. You can think of these as <em>views</em> into
an underlying array of values. They otherwise behave very much like an array, and
<em>know their size</em>, unlike those dangerous animals C pointers.</p>
<p>Note two important things here - how to write an slice type, and that
you have to use <code>&amp;</code> to pass it to the function.</p>
<pre><pre class="playpen"><code class="language-rust">// array2.rs
// read as: slice of i32 array
fn sum(values: &amp;[i32]) -&gt; i32 {
    let mut res = 0;
    for i in 0..values.len() {
        res += values[i]
    }
    res
}

fn main() {
    let arr = [10,20,30,40];
    // look at that &amp;
    let res = sum(&amp;arr);
    println!(&quot;sum {}&quot;, res);
}
</code></pre></pre>
<p>Ignore the code of <code>sum</code> for a while, and look at <code>&amp;[i32]</code>. The relationship between
Rust arrays and slices is similar to that between C arrays and pointers, except for
two important differences - Rust slices keep track of their size (and will
panic if you try to access outside that size) and you have to explicitly say that
you want to pass an array as a slice using the <code>&amp;</code> operator.</p>
<p>A C programmer pronounces <code>&amp;</code> as 'address of'; a Rust programmer pronounces it
'borrow'. This is going to be the key word when learning Rust. Borrowing is the name
given to a common pattern in programming; whenever you pass something by reference
(as nearly always happens in dynamic languages) or pass a pointer in C. Anything
borrowed remains the 'property' of the original owner.</p>
<a class="header" href="print.html#slicing-and-dicing" name="slicing-and-dicing"><h2>Slicing and Dicing</h2></a>
<p>You cannot print out an array in the usual way with <code>{}</code> but you can do a <em>debug</em>
print with <code>{:?}</code>.</p>
<pre><pre class="playpen"><code class="language-rust">// array3.rs
fn main() {
    let ints = [1, 2, 3];
    let floats = [1.1, 2.1, 3.1];
    let strings = [&quot;hello&quot;, &quot;world&quot;];
    let ints_ints = [[1, 2], [10, 20]];
    println!(&quot;ints {:?}&quot;, ints);
    println!(&quot;floats {:?}&quot;, floats);
    println!(&quot;strings {:?}&quot;, strings);
    println!(&quot;ints_ints {:?}&quot;, ints_ints);
}
</code></pre></pre>
<p>Which gives:</p>
<pre><code>ints [1, 2, 3]
floats [1.1, 2.1, 3.1]
strings [&quot;hello&quot;, &quot;world&quot;]
ints_ints [[1, 2], [10, 20]]
</code></pre>
<p>So, arrays of arrays are no problem, but the important thing is that an array contains
values of <em>only one type</em>.  The values in an array are arranged next to each other
in memory so that <code>[10, 20]</code> takes 8 bytes (two 4-byte signed integers). This makes
them <em>very</em> efficient to access.</p>
<p>If you are curious about the actual types of these variables, here is a useful trick.
Just declare a variable with an explicit type which you know will be wrong:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let var: () = [1.1, 1.2];

#}</code></pre></pre>
<p>Here is the informative error:</p>
<pre><code>3 |     let var: () = [1.1, 1.2];
  |                   ^^^^^^^^^^ expected (), found array of 2 elements
  |
  = note: expected type `()`
  = note:    found type `[{float}; 2]`
</code></pre>
<p>Slices give you different <em>views</em> of the <em>same</em> array:</p>
<pre><pre class="playpen"><code class="language-rust">// slice1.rs
fn main() {
    let ints = [1, 2, 3, 4, 5];
    let slice1 = &amp;ints[0..2];
    let slice2 = &amp;ints[1..];  // open range!

    println!(&quot;ints {:?}&quot;, ints);
    println!(&quot;slice1 {:?}&quot;, slice1);
    println!(&quot;slice2 {:?}&quot;, slice2);
}
</code></pre></pre>
<pre><code>ints [1, 2, 3, 4, 5]
slice1 [1, 2]
slice2 [2, 3, 4, 5]
</code></pre>
<p>This is a neat notation which looks similar to Python slices but with a big difference:
a copy of the data is never made.  These slices all <em>borrow</em> their data from their
arrays. They have a very intimate relationship with that array, and Rust spends a lot
of effort to make sure that relationship does not break down.</p>
<a class="header" href="print.html#optional-values" name="optional-values"><h2>Optional Values</h2></a>
<p>Slices, like arrays, can be <em>indexed</em>. Rust knows the size of an array at
compile-time, but the size of a slice is only known at run-time. So <code>s[i]</code> can
cause an out-of-bounds error when running and will <em>panic</em>.  This is really not
what you want to happen - it can be the difference between a safe launch abort and
scattering pieces of a very expensive satellite all over Florida. And there are
<em>no exceptions</em>.</p>
<p>Let that sink in, because it comes as a shock. You cannot wrap dodgy-may-panic
code in some try-block and 'catch the error' - at least not in a way you'd want to use
every day. So how can Rust be safe?</p>
<p>There is a slice method <code>get</code> which does not panic. But what does it return?</p>
<pre><pre class="playpen"><code class="language-rust">// slice2.rs
fn main() {
    let ints = [1, 2, 3, 4, 5];
    let slice = &amp;ints;
    let first = slice.get(0);
    let last = slice.get(5);

    println!(&quot;first {:?}&quot;, first);
    println!(&quot;last {:?}&quot;, last);
}
// first Some(1)
// last None
</code></pre></pre>
<p><code>last</code> failed (forgot zero-based indexing), but returned something called <code>None</code>.
<code>first</code> is fine, but appears as a value wrapped in <code>Some</code>.  Welcome to the <code>Option</code>
type!  It may be <em>either</em> <code>Some</code> or <code>None</code>.</p>
<p>The <code>Option</code> type has some useful methods:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    println!(&quot;first {} {}&quot;, first.is_some(), first.is_none());
    println!(&quot;last {} {}&quot;, last.is_some(), last.is_none());
    println!(&quot;first value {}&quot;, first.unwrap());

// first true false
// last false true
// first value 1

#}</code></pre></pre>
<p>If you were to <em>unwrap</em> <code>last</code>, you would get a panic. But at least you can call
<code>is_some</code> first to make sure - for instance, if you had a distinct no-value default:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let maybe_last = slice.get(5);
    let last = if maybe_last.is_some() {
        maybe_last.unwrap()
    } else {
        -1
    };

#}</code></pre></pre>
<p>Which is long-winded, so there's a shortcut:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let last = slice.get(5).unwrap_or(-1);

#}</code></pre></pre>
<p>You can think of <code>Option</code> as a box which may contain a value, or nothing (<code>None</code>).
(It is called <code>Maybe</code> in Haskell). It may contain <em>any</em> kind of value, which is
its <em>type parameter</em>. In this case, the full type is <code>Option&lt;i32&gt;</code>, using
C++-style notation for <em>generics</em>.  Unwrapping this box may cause an explosion,
but unlike Schroedinger's Cat, we know if it contains a value up-front.</p>
<p>It is very common for Rust functions/methods to return such maybe-boxes, so learn
how to use them safely!</p>
<a class="header" href="print.html#vectors" name="vectors"><h2>Vectors</h2></a>
<p>We'll return to slice methods again, but first: vectors. These are <em>re-sizeable</em>
arrays and behave much like Python <code>List</code> and C++ <code>std::vector</code>. The Rust type
<code>Vec</code> (pronounced 'vector') behaves very much like an slice in fact; the
difference is that you can append extra values to a vector - note that it must
be declared as mutable.</p>
<pre><pre class="playpen"><code class="language-rust">// vec1.rs
fn main() {
    let mut v = Vec::new();
    v.push(10);
    v.push(20);
    v.push(30);

    let first = v[0];  // will panic if out-of-range
    let maybe_first = v.get(0);

    println!(&quot;v is {:?}&quot;, v);
    println!(&quot;first is {}&quot;, first);
    println!(&quot;maybe_first is {:?}&quot;, maybe_first);
}
// v is [10, 20, 30]
// first is 10
// maybe_first is Some(10)
</code></pre></pre>
<p>A common beginner mistake is to forget the <code>mut</code>; you will get a helpful error
message:</p>
<pre><code>3 |     let v = Vec::new();
  |         - use `mut v` here to make mutable
4 |     v.push(10);
  |     ^ cannot borrow mutably
</code></pre>
<p>There is a very intimate relation between vectors and slices:</p>
<pre><pre class="playpen"><code class="language-rust">// vec2.rs
fn dump(arr: &amp;[i32]) {
    println!(&quot;arr is {:?}&quot;, arr);
}

fn main() {
    let mut v = Vec::new();
    v.push(10);
    v.push(20);
    v.push(30);

    dump(&amp;v);

    let slice = &amp;v[1..];
    println!(&quot;slice is {:?}&quot;, slice);
}
</code></pre></pre>
<p>That little, so-important borrow operator <code>&amp;</code> is <em>coercing</em> the vector into a
slice. And it makes complete sense, because the vector is looking after an array of
values, with the difference that the array is allocated <em>dynamically</em>.</p>
<p>If you come from a dynamic language, now is time for that little talk. In systems
languages, program memory comes in two kinds: the stack and the heap. It is very fast
to allocate data on the stack, but the stack is limited; typically of the order of
megabytes. The heap can be gigabytes, but allocating is relatively expensive, and
such memory must be <em>freed</em> later. In so-called 'managed' languages (like Java, Go
and the so-called 'scripting' languages) these details are hidden from you by that
convenient municipal utility called the <em>garbage collector</em>. Once the system is sure
that data is no longer referenced by other data, it goes back into the pool
of available memory.</p>
<p>Generally, this is a price worth paying. Playing with the stack is terribly unsafe,
because if you make one mistake you can override the return address of the current
function, and you die an ignominious death or (worse) got pwned by some guy living
in his Mom's basement in Minsk.</p>
<p>The first C program I wrote (on an DOS PC)
took out the whole computer. Unix systems always behaved better, and only the process died
with a <em>segfault</em>. Why is this worse than a Rust (or Go) program panicking?
Because the panic happens when the original problem happens, not when the program
has become hopelessly confused and eaten all your homework. Panics are <em>memory safe</em>
because they happen before any illegal access to memory. This is a common cause of
security problems in C, because all memory accesses are unsafe and a cunning attacker
can exploit this weakness.</p>
<p>Panicking sounds desperate and unplanned, but Rust panics are structured - the stack is <em>unwound</em>
just as with exceptions. All allocated objects are dropped, and a backtrace is generated.</p>
<p>The downsides of garbage collection? The first is that it is wasteful of memory, which
matters in those small embedded microchips which increasingly rule our world. The
second is that it will decide, at the worst possible time, that a clean up must happen
<em>now</em>. (The Mom analogy is that she wants to clean your room when you are at a
delicate stage with a new lover). Those embedded systems need to respond to things
<em>when they happen</em> ('real-time') and can't tolerate unscheduled outbreaks of
cleaning. Roberto Ierusalimschy, the chief designer of Lua (one of the most elegant
dynamic languages ever) said that he would not like to fly on an airplane that
relied on garbage-collected software.</p>
<p>Back to vectors: when a vector is modified or created, it allocates from the heap and becomes
the <em>owner</em> of that memory. The slice <em>borrows</em> the array from the vector.
When the vector dies or <em>drops</em>, it lets the memory go.</p>
<a class="header" href="print.html#iterators" name="iterators"><h2>Iterators</h2></a>
<p>We have got so far without mentioning a key part of the Rust puzzle - iterators.
The for-loop over a range was using an iterator (<code>0..n</code> is actually similar to the
Python 3 <code>range</code> function).</p>
<p>An iterator is easy to define informally. It is an 'object' with a <code>next</code> method
which returns an <code>Option</code>. As long as that value is not <code>None</code>, we keep calling
<code>next</code>:</p>
<pre><pre class="playpen"><code class="language-rust">// iter1.rs
fn main() {
    let mut iter = 0..3;
    assert_eq!(iter.next(), Some(0));
    assert_eq!(iter.next(), Some(1));
    assert_eq!(iter.next(), Some(2));
    assert_eq!(iter.next(), None);
}
</code></pre></pre>
<p>And that is exactly what <code>for var in iter {}</code> does.</p>
<p>This may seem an inefficient way to define a for-loop, but <code>rustc</code> does crazy-ass
optimizations in release mode and it will be just as fast as a <code>while</code> loop. (Contrast
with the situation on the JVM, where iterators always require allocation. The consequence
is that funky functional stuff in Scala is <em>always</em> going to be significantly slower
than in Rust).</p>
<p>Here is the first attempt to iterate over an array:</p>
<pre><pre class="playpen"><code class="language-rust">// iter2.rs
fn main() {
    let arr = [10, 20, 30];
    for i in arr {
        println!(&quot;{}&quot;, i);
    }
}
</code></pre></pre>
<p>which fails, but helpfully:</p>
<pre><code>4 |     for i in arr {
  |     ^ the trait `std::iter::Iterator` is not implemented for `[{integer}; 3]`
  |
  = note: `[{integer}; 3]` is not an iterator; maybe try calling
   `.iter()` or a similar method
  = note: required by `std::iter::IntoIterator::into_iter`
</code></pre>
<p>Following <code>rustc</code>'s advice, the following program works as expected.</p>
<pre><pre class="playpen"><code class="language-rust">// iter3.rs
fn main() {
    let arr = [10, 20, 30];
    for i in arr.iter() {
        println!(&quot;{}&quot;, i);
    }

    // slices can be converted implicitly to iterators...
    let slice = &amp;arr;
    for i in slice {
        println!(&quot;{}&quot;, i);
    }
}
</code></pre></pre>
<p>In fact, it is more efficient to iterate over an array or slice this way
than to use <code>for i in 0..slice.len() {}</code> because Rust does not have to obsessively
check every index operation.</p>
<p>We had an example of summing up a range of integers earlier. It involved a <code>mut</code>
variable and a loop. Here's the <em>idiomatic</em>, pro-level way of doing the sum:</p>
<pre><pre class="playpen"><code class="language-rust">// sum1.rs
fn main() {
    let sum: i32  = (0..5).sum();
    println!(&quot;sum was {}&quot;, sum);

    let sum: i64 = [10, 20, 30].iter().sum();
    println!(&quot;sum was {}&quot;, sum);
}
</code></pre></pre>
<p>Note that this is one of those cases where you need to be explicit about
the <em>type</em> of the variable, since otherwise Rust doesn't have enough information.
Here we do sums with two different integer sizes, no problem. (It is also no
problem to create a new variable of the same name if you run out of names to
give things.)</p>
<p>With this background, some more of the slice methods will make more sense.
Another documentation tip; on the right-hand side of every page there's a '[-]' which you can
click to collapse the method list. You can then expand the details of anything
that looks interesting. (Anything that looks too weird, just ignore for now.)</p>
<p>The <code>windows</code> method gives you an iterator of slices - overlapping windows of
values!</p>
<pre><pre class="playpen"><code class="language-rust">// slice4.rs
fn main() {
    let ints = [1, 2, 3, 4, 5];
    let slice = &amp;ints;

    for s in slice.windows(2) {
        println!(&quot;window {:?}&quot;, s);
    }
}
// window [1, 2]
// window [2, 3]
// window [3, 4]
// window [4, 5]
</code></pre></pre>
<p>Or <code>chunks</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    for s in slice.chunks(2) {
        println!(&quot;chunks {:?}&quot;, s);
    }
// chunks [1, 2]
// chunks [3, 4]
// chunks [5]

#}</code></pre></pre>
<a class="header" href="print.html#more-about-vectors" name="more-about-vectors"><h2>More about vectors...</h2></a>
<p>There is a useful little macro <code>vec!</code> for initializing a vector. Note that you
can <em>remove</em> values from the end of a vector using <code>pop</code>, and <em>extend</em> a vector
using any compatible iterator.</p>
<pre><pre class="playpen"><code class="language-rust">// vec3.rs
fn main() {
    let mut v1 = vec![10, 20, 30, 40];
    v1.pop();

    let mut v2 = Vec::new();
    v2.push(10);
    v2.push(20);
    v2.push(30);

    assert_eq!(v1, v2);

    v2.extend(0..2);
    assert_eq!(v2, &amp;[10, 20, 30, 0, 1]);
}
</code></pre></pre>
<p>Vectors compare with each other and with slices by value.</p>
<p>You can insert values into a vector at arbitrary positions with <code>insert</code>,
and remove with <code>remove</code>. This is not as efficient as pushing and popping since
the values will have to be moved to make room, so watch out for these operations on big
vectors.</p>
<p>Vectors have a size and a <em>capacity</em>. If you <code>clear</code> a vector, its size becomes zero,
but it still retains its old capacity. So refilling it with <code>push</code>, etc only requires
reallocation when the size gets larger than that capacity.</p>
<p>Vectors can be sorted, and then duplicates can be removed - these operate in-place
on the vector. (If you want to make a copy first, use <code>clone</code>.)</p>
<pre><pre class="playpen"><code class="language-rust">// vec4.rs
fn main() {
    let mut v1 = vec![1, 10, 5, 1, 2, 11, 2, 40];
    v1.sort();
    v1.dedup();
    assert_eq!(v1, &amp;[1, 2, 5, 10, 11, 40]);
}
</code></pre></pre>
<a class="header" href="print.html#strings" name="strings"><h2>Strings</h2></a>
<p>Strings in Rust are a little more involved than in dynamic languages; the <code>String</code> type,
like <code>Vec</code>, allocates dynamically and is resizeable. (So it's like C++'s <code>std::string</code>
but not like the immutable strings of Java and Python.) A program may contain a lot
of <em>string literals</em> (like &quot;hello&quot;) and a system language should be able to store
these statically in the executable itself. In embedded micros, that could mean putting
them in cheap ROM rather than expensive RAM (for low-power devices, RAM is
also expensive in terms of power consumption.)</p>
<p>So &quot;hello&quot; is not of type <code>String</code>. It is of type <code>&amp;str</code> (pronounced 'string slice').
It's like the distinction between <code>const char*</code> and <code>std::string</code> in C++, except
<code>&amp;str</code> is much more intelligent.  In fact, <code>&amp;str</code> and <code>String</code> have a very
similar relationship to each other as do <code>&amp;[T]</code> to <code>Vec&lt;T&gt;</code>.</p>
<pre><pre class="playpen"><code class="language-rust">// string1.rs
fn dump(s: &amp;str) {
    println!(&quot;str '{}'&quot;, s);
}

fn main() {
    let text = &quot;hello dolly&quot;;  // the string slice
    let s = text.to_string();  // it's now an allocated string

    dump(text);
    dump(&amp;s);
}
</code></pre></pre>
<p>Again, the borrow operator can coerce <code>String</code> into <code>&amp;str</code>, just as <code>Vec</code> could
be coerced into <code>&amp;[]</code>.</p>
<p>In C++, char pointers can become strings implicitly through the constructor and
through assignment,  but you need the ugly <code>c_str</code>
method to get the owned char pointer of the string. And that's an important difference
in emphasis; Rust is making the <em>allocation</em> obvious, but makes it easier to borrow
the characters as a string slice.</p>
<p>Like a vector, you can <code>push</code> a character and <code>pop</code> one off the end.</p>
<pre><pre class="playpen"><code class="language-rust">// string5.rs
fn main() {
    let mut s = String::new();
    // initially empty!
    s.push('H');
    s.push_str(&quot;ello&quot;);
    s.push(' ');
    s += &quot;World!&quot;; // short for `push_str`
    // remove the last char
    s.pop();

    assert_eq!(s, &quot;Hello World&quot;);
}
</code></pre></pre>
<p>You can convert many types to strings using <code>to_string</code>
(essentially, if you can display them with '{}' then they can be converted).
The <code>format!</code> macro is a very useful way to build
up more complicated strings using the same format strings as <code>println!</code>.</p>
<pre><pre class="playpen"><code class="language-rust">// string5.rs
fn array_to_str(arr: &amp;[i32]) -&gt; String {
    let mut res = '['.to_string();
    for v in arr {
        res += &amp;v.to_string();
        res.push(',');
    }
    res.pop();
    res.push(']');
    res
}

fn main() {
    let arr = array_to_str(&amp;[10, 20, 30]);
    let res = format!(&quot;hello {}&quot;, arr);

    assert_eq!(res, &quot;hello [10,20,30]&quot;);
}
</code></pre></pre>
<p>Note the <code>&amp;</code> in front of <code>v.to_string()</code> - the operator is defined on a string
slice, not a <code>String</code> itself, so it needs a little persuasion to match.</p>
<p>The notation used for slices works with strings as well:</p>
<pre><pre class="playpen"><code class="language-rust">// string2.rs
fn main() {
    let text = &quot;static&quot;;
    let string = &quot;dynamic&quot;.to_string();

    let text_s = &amp;text[1..];
    let string_s = &amp;string[2..4];

    println!(&quot;slices {:?} {:?}&quot;, text_s, string_s);
}
// slices &quot;tatic&quot; &quot;na&quot;
</code></pre></pre>
<p>Again, this is superior to the C++ approach, which is to use the <code>substr</code>
method - which <em>makes a copy</em>. In the Rust case, it's just a borrow.</p>
<p>But, you cannot index strings!  This is because they use the One True Encoding,
UTF-8, where a 'character' may be a number of bytes.</p>
<pre><pre class="playpen"><code class="language-rust">// string3.rs
fn main() {
    let multilingual = &quot;Hi! ¡Hola! привет!&quot;;
    for ch in multilingual.chars() {
        print!(&quot;'{}' &quot;, ch);
    }
    println!(&quot;&quot;);
    println!(&quot;len {}&quot;, multilingual.len());
    println!(&quot;count {}&quot;, multilingual.chars().count());

    let maybe = multilingual.find('п');
    if maybe.is_some() {
        let hi = &amp;multilingual[maybe.unwrap()..];
        println!(&quot;Russian hi {}&quot;, hi);
    }
}
// 'H' 'i' '!' ' ' '¡' 'H' 'o' 'l' 'a' '!' ' ' 'п' 'р' 'и' 'в' 'е' 'т' '!'
// len 25
// count 18
// Russian hi привет!
</code></pre></pre>
<p>Now, let that sink in - there are 25 bytes, but only 18 characters! However, if
you use a method like <code>find</code>, you will get a valid index (if found) and then
any slice will be fine.</p>
<p>(The Rust <code>char</code> type is a 4-byte Unicode code point. Strings are <em>not</em> arrays
of chars!)</p>
<p>String slicing may explode like vector indexing, because it uses byte offsets. In this case,
the string consists of two bytes, so trying to pull out the first byte is a Unicode error. So be
careful to only slice strings using valid offsets that come from string methods.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let s = &quot;¡&quot;;
    println!(&quot;{}&quot;, &amp;s[0..1]); &lt;-- bad, first byte of a multibyte character

#}</code></pre></pre>
<p>Breaking up strings is a popular and useful pastime. The string <code>split_whitespace</code>
method returns an <em>iterator</em>, and we then choose what to do with it. <code>collect</code>
is very general and so needs some clues about <em>what</em> it is collecting - hence
the explicit type.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let text = &quot;the red fox and the lazy dog&quot;;
    let words: Vec&lt;&amp;str&gt; = text.split_whitespace().collect();
    // [&quot;the&quot;, &quot;red&quot;, &quot;fox&quot;, &quot;and&quot;, &quot;the&quot;, &quot;lazy&quot;, &quot;dog&quot;]

#}</code></pre></pre>
<p>You could also say it like this, passing the iterator into the <code>extend</code> method:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let mut words = Vec::new();
    words.extend(text.split_whitespace());

#}</code></pre></pre>
<p>If written in C++, we would have to make these <em>allocated strings</em>, whereas
here each slice in the vector is borrowing from the original string. All we
allocate is the space to keep the slices.</p>
<p>Have a look at this cute two-liner; we get an iterator over the chars,
and only take those characters which are not space. Again, <code>collect</code> needs
a clue (we may have wanted a vector of chars, say):</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let stripped: String = text.chars()
        .filter(|ch| !ch.is_whitespace()).collect();
    // theredfoxandthelazydog

#}</code></pre></pre>
<p>The <code>filter</code> method takes a <em>closure</em>, which is Rust-speak for what C++ calls
lambdas or anonymous functions.  Here the argument type is clear from the
context, so the explicit rule is relaxed.</p>
<p>Yes, you can do this as an explicit loop over chars, pushing the returned slices
into a mutable vector, but this is shorter, reads well (<em>when</em> you are used to it,
of course) and just as fast. It is not a <em>sin</em> to use a loop, however, and I encourage
you to write that version as well.</p>
<a class="header" href="print.html#interlude-getting-command-line-arguments" name="interlude-getting-command-line-arguments"><h2>Interlude: Getting Command Line Arguments</h2></a>
<p>Up to now our programs have lived in blissful ignorance of the outside world; now
it's time to feed them data.</p>
<p><code>std::env::args</code> is how you access command-line arguments; it returns an iterator
over the arguments as strings, including the program name.</p>
<pre><pre class="playpen"><code class="language-rust">// args0.rs
fn main() {
    for arg in std::env::args() {
        println!(&quot;'{}&quot;, arg);
    }
}
</code></pre></pre>
<pre><code>src$ rustc args0.rs
src$ ./args0 42 'hello dolly' frodo
'./args0'
'42'
'hello dolly'
'frodo'
</code></pre>
<p>Would it have been better to return a <code>Vec</code>? It's easy enough to use <code>collect</code> to
make that vector, using the iterator <code>skip</code> method to move past the program
name.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let args: Vec&lt;String&gt; = std::env::args().skip(1).collect();
    if args.len() &gt; 0 { // we have args!
        ...
    }

#}</code></pre></pre>
<p>Which is fine; it's pretty much how you would do it in C.</p>
<p>A more Rust-y approach to reading a single argument (together with parsing an
integer value):</p>
<pre><pre class="playpen"><code class="language-rust">// args1.rs
use std::env;

fn main() {
    let first = env::args().nth(1).expect(&quot;please supply an argument&quot;);
    let n: i32 = first.parse().expect(&quot;not an integer!&quot;);
    // do your magic
}
</code></pre></pre>
<p><code>nth(1)</code> gives you the second argument from the iterator, and <code>expect</code>
is like an <code>unwrap</code> with a readable message.</p>
<p>Converting a string into a number is straightforward, but you do need to specify
the type of the value - how else could <code>parse</code> know?</p>
<p>This program can panic, which is fine for dinky test programs. But don't get too
comfortable with this convenient habit.</p>
<a class="header" href="print.html#matching" name="matching"><h2>Matching</h2></a>
<p>The code in <code>string3.rs</code> where we extract the Russian greeting is not how it would
be usually written. Enter <em>match</em>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    match multilingual.find('п') {
        Some(idx) =&gt; {
            let hi = &amp;multilingual[idx..];
            println!(&quot;Russian hi {}&quot;, hi);
        },
        None =&gt; println!(&quot;couldn't find the greeting, Товарищ&quot;)
    };

#}</code></pre></pre>
<p><code>match</code> consists of several <em>patterns</em> with a matching value following the fat arrow,
separated by commas.  It has conveniently unwrapped the value from the <code>Option</code> and
bound it to <code>idx</code>.  You <em>must</em> specify all the possibilities, so we have to handle
<code>None</code>.</p>
<p>Once you are used to it (and by that I mean, typed it out in full a few times) it
feels more natural than the explicit <code>is_some</code> check which needed an extra
variable to store the <code>Option</code>.</p>
<p>But if you're not interested in failure here, then <code>if let</code> is your friend:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    if let Some(idx) = multilingual.find('п') {
        println!(&quot;Russian hi {}&quot;, &amp;multilingual[idx..]);
    }

#}</code></pre></pre>
<p>This is convenient if you want to do a match and are <em>only</em> interested in one possible
result.</p>
<p><code>match</code> can also operate like a C <code>switch</code> statement, and like other Rust constructs
can return a value:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let text = match n {
        0 =&gt; &quot;zero&quot;,
        1 =&gt; &quot;one&quot;,
        2 =&gt; &quot;two&quot;,
        _ =&gt; &quot;many&quot;,
    };

#}</code></pre></pre>
<p>The <code>_</code> is like C <code>default</code> - it's a fall-back case. If you don't provide one then
<code>rustc</code> will consider it an error. (In C++ the best you can expect is a warning, which
says a lot about the respective languages).</p>
<p>Rust <code>match</code> statements are more powerful than <code>switch</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let text = match n {
        0...3 =&gt; &quot;small&quot;,
        4...6 =&gt; &quot;medium&quot;,
        _ =&gt; &quot;large&quot;,
     };

#}</code></pre></pre>
<a class="header" href="print.html#reading-from-files" name="reading-from-files"><h2>Reading from Files</h2></a>
<p>The next step to exposing our programs to the world is to <em>reading files</em>.</p>
<p>Recall that <code>expect</code> is like <code>unwrap</code> but gives a custom error message. We are
going to throw any a few errors here:</p>
<pre><pre class="playpen"><code class="language-rust">// file1.rs
use std::env;
use std::fs::File;
use std::io::Read;

fn main() {
    let first = env::args().nth(1).expect(&quot;please supply a filename&quot;);

    let mut file = File::open(&amp;first).expect(&quot;can't open the file&quot;);

    let mut text = String::new();
    file.read_to_string(&amp;mut text).expect(&quot;can't read the file&quot;);

    println!(&quot;file had {} bytes&quot;, text.len());

}
</code></pre></pre>
<pre><code>src$ file1 file1.rs
file had 366 bytes
src$ ./file1 frodo.txt
thread 'main' panicked at 'can't open the file: Error { repr: Os { code: 2, message: &quot;No such file or directory&quot; } }', ../src/libcore/result.rs:837
note: Run with `RUST_BACKTRACE=1` for a backtrace.
src$ file1 file1
thread 'main' panicked at 'can't read the file: Error { repr: Custom(Custom { kind: InvalidData, error: StringError(&quot;stream did not contain valid UTF-8&quot;) }) }', ../src/libcore/result.rs:837
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>So <code>open</code> can fail because the file doesn't exist or we aren't allowed to read it,
and <code>read_to_string</code> can fail because the file doesn't contain valid UTF-8. (Which is
fair enough, you can use <code>read_to_end</code> and put the contents into a vector of bytes
instead.) For files that aren't too big, reading them in one gulp is useful and
straightforward.</p>
<p>If you know anything about file handling in other languages, you may wonder when
the file is <em>closed</em>. If we were writing to this file, then not closing it could
result in loss of data.
But the file here is closed when the function ends and the <code>file</code> variable is <em>dropped</em>.</p>
<p>This 'throwing away errors' thing is getting too much of a habit. You do not
want to put this code into a function, knowing that it could so easily crash
the whole program.  So now we have to talk about exactly what <code>File::open</code> returns.
If <code>Option</code> is a value that may contain something or nothing, then <code>Result</code> is a value
that may contain something or an error. They both understand <code>unwrap</code> (and its cousin
<code>expect</code>) but they are quite different.</p>
<p>This version defines a function that does not crash. It passes on a <code>Result</code> and
it is the <em>caller</em> who must decide how to handle the error.</p>
<pre><pre class="playpen"><code class="language-rust">// file2.rs
use std::env;
use std::fs::File;
use std::io::Read;
use std::io;

fn read_to_string(filename: &amp;str) -&gt; io::Result&lt;String&gt; {
    let mut file = match File::open(&amp;filename) {
        Ok(f) =&gt; f,
        Err(e) =&gt; return Err(e),
    };
    let mut text = String::new();
    match file.read_to_string(&amp;mut text) {
        Ok(_) =&gt; Ok(text),
        Err(e) =&gt; Err(e),
    }
}

fn main() {
    let file = env::args().nth(1).expect(&quot;please supply a filename&quot;);

    let text = read_to_string(&amp;file).expect(&quot;bad file man!&quot;);

    println!(&quot;file had {} bytes&quot;, text.len());
}
</code></pre></pre>
<p>The <code>Result</code> 'box' has two compartments, one labelled <code>Ok</code>
and the other <code>Err</code>.</p>
<p>The first match safely extracts the value from <code>Ok</code>, which
becomes the value of the match. If it's <code>Err</code> it just returns the error.
The second match returns the string, wrapped up as an <code>Ok</code>, otherwise
(again) the error. The actual value in the <code>Ok</code> is unimportant, so we ignore
it with <code>_</code>.</p>
<p>This is not so pretty; when most of a function is error handling, then
the 'happy path' gets lost. Go tends to have this problem, with lots of
explicit early returns, or just <em>ignoring errors</em>.  (That is, by the way,
the closest thing to evil in the Rust universe.)</p>
<p>Fortunately, there is a shortcut:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn read_to_string(filename: &amp;str) -&gt; io::Result&lt;String&gt; {
    let mut file = File::open(&amp;filename)?;
    let mut text = String::new();
    file.read_to_string(&amp;mut text)?;
    Ok(text)
}

#}</code></pre></pre>
<p>That <code>?</code> operator does almost exactly what the first match did; if the
result was an error, then it will immediately return that error. At the end, we
still need to wrap up the string as a result.</p>
<p>It's been a good year in Rust, and <code>?</code> was one of the cool things that
became stable recently. You will still see the macro <code>try!</code> used in older code:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn read_to_string(filename: &amp;str) -&gt; io::Result&lt;String&gt; {
    let mut file = try!(File::open(&amp;filename));
    let mut text = String::new();
    try!(file.read_to_string(&amp;mut text));
    Ok(text)
}

#}</code></pre></pre>
<p>In summary, it's possible to write perfectly safe Rust that isn't ugly, without
needing exceptions.</p>
<a class="header" href="print.html#structs-enums-and-matching" name="structs-enums-and-matching"><h1>Structs, Enums and Matching</h1></a>
<a class="header" href="print.html#rust-likes-to-move-it-move-it" name="rust-likes-to-move-it-move-it"><h2>Rust likes to Move It, Move It</h2></a>
<p>I'd like to move back a little, and show you something surprising:</p>
<pre><pre class="playpen"><code class="language-rust">// move1.rs
fn main() {
    let s1 = &quot;hello dolly&quot;.to_string();
    let s2 = s1;
    println!(&quot;s1 {}&quot;, s1);
}
</code></pre></pre>
<p>And we get the following error:</p>
<pre><code>error[E0382]: use of moved value: `s1`
 --&gt; move1.rs:5:22
  |
4 |     let s2 = s1;
  |         -- value moved here
5 |     println!(&quot;s1 {}&quot;, s1);
  |                      ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`,
  which does not implement the `Copy` trait
</code></pre>
<p>Rust has different behaviour than other languages. In a language where variables are
always references (like Java or Python), <code>s2</code> becomes yet another reference to the
string object referenced by <code>s1</code>. In C++, <code>s1</code> is a value, and it is <em>copied</em> to <code>s2</code>.
But Rust moves the value.  It doesn't see strings as copyable
(&quot;does not implement the Copy trait&quot;).</p>
<p>We would not see this with 'primitive' types like numbers, since they are just values;
they are allowed to be copyable because they are cheap to copy. But <code>String</code> has allocated
memory containing &quot;Hello dolly&quot;, and copying will involve allocating some more memory
and copying the characters. Rust will not do this silently.</p>
<p>Consider a <code>String</code> containing the whole text of 'Moby-Dick'. It's not a big struct,
just has the address in memory of the text, its size, and how big the allocated block is.
Copying this is going to be expensive, because that memory is allocated on the heap and
the copy will need its own allocated block.</p>
<pre><code>    | addr | ---------&gt; Call me Ishmael.....
    | size |                    |
    | cap  |                    |
                                |
    | addr | -------------------|
    | size |

    | 8 bytes |
</code></pre>
<p>The second value is a string slice (<code>&amp;str</code>) which refers to the same memory as the string,
with a size - just the guy's name. Cheap to copy!</p>
<p>The third value is an <code>f64</code> - just 8 bytes. It does not refer to any other memory, so
it's just as cheap to copy as to move.</p>
<p>Re-writing with a function call reveals exactly the same error:</p>
<pre><pre class="playpen"><code class="language-rust">// move2.rs

fn dump(s: String) {
    println!(&quot;{}&quot;, s);
}

fn main() {
    let s1 = &quot;hello dolly&quot;.to_string();
    dump(s1);
    println!(&quot;s1 {}&quot;, s1);
}
</code></pre></pre>
<p>Here, you have a choice. You may explicitly create a reference to that string, or
explicitly copy it using its <code>clone</code> method.  Generally, the first is the better way
to go.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn dump(s: &amp;String) {
    println!(&quot;{}&quot;, s);
}

#}</code></pre></pre>
<p>The call becomes <code>dump(&amp;s1)</code>, and the error goes away. But you'll rarely see a plain
<code>String</code> reference like this, since to pass a string literal is really ugly <em>and</em> involves
creating a temporary string.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    dump(&amp;&quot;hello world&quot;.to_string());

#}</code></pre></pre>
<p>So altogether the best way to declare that function is:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn dump(s: &amp;str) {
    println!(&quot;{}&quot;, s);
}

#}</code></pre></pre>
<p>And then both <code>dump(&amp;s1)</code> and <code>dump(&quot;hello world&quot;)</code> work properly.</p>
<a class="header" href="print.html#lifetimes" name="lifetimes"><h2>Lifetimes</h2></a>
<p>So, the rule of thumb is to prefer to keep references to the original data - to 'borrow'
it.</p>
<p>But a reference must <em>not</em> outlive the owner!</p>
<p>First, Rust is a <em>block-scoped</em> language. Variables only exist for the duration of their
block:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
{
    let a = 10;
    let b = &quot;hello&quot;;
    {
        let c = &quot;hello&quot;.to_string();
        // a,b and c are visible
    } // the string c is dropped
    // a,b are visible
    for i in 0..a {
        let b = &amp;b[1..];
        // original b is no longer visible - it is shadowed.
    }
    // the slice b is dropped
    // i is _not_ visible!
}

#}</code></pre></pre>
<p>Loop variables (like <code>i</code>) are a little different, they are only visible in the loop
block.  It is not an error to create a new variable using the same name ('shadowing')
but it can be confusing.</p>
<p>When a variable 'goes out of scope' then it is <em>dropped</em>. Any memory used is reclaimed,
and any other <em>resources</em> owned by that variable are given back to the system - for
instance, dropping a <code>File</code> closes it.  This is a Good Thing. Unused resources are
reclaimed immediately when not needed.</p>
<p>(A further Rust-specific issue is that a variable may appear to be in scope, but its
value has moved.)</p>
<p>Here a reference <code>rs1</code> is made to a value <code>tmp</code> which only lives for the duration
of its block:</p>
<pre><pre class="playpen"><code class="language-rust">01 // ref1.rs
02 fn main() {
03    let s1 = &quot;hello dolly&quot;.to_string();
04    let mut rs1 = &amp;s1;
05    {
06        let tmp = &quot;hello world&quot;.to_string();
07        rs1 = &amp;tmp;
08    }
09    println!(&quot;ref {}&quot;, rs1);
10 }
</code></pre></pre>
<p>We borrow the value of <code>s1</code> and then borrow the value of <code>tmp</code>. But <code>tmp</code>'s value
does not exist outside that block:</p>
<pre><code>error: `tmp` does not live long enough
  --&gt; ref1.rs:8:5
   |
7  |         rs1 = &amp;tmp;
   |                --- borrow occurs here
8  |     }
   |     ^ `tmp` dropped here while still borrowed
9  |     println!(&quot;ref {}&quot;, rs1);
10 | }
   | - borrowed value needs to live until here
</code></pre>
<p>Where is <code>tmp</code>? Gone, dead, gone back to the Big Heap in the Sky: <em>dropped</em>.
Rust is here saving you from the dreaded 'dangling pointer' problem of C -
a reference that points to stale data.</p>
<a class="header" href="print.html#tuples" name="tuples"><h2>Tuples</h2></a>
<p>It's sometimes very useful to return multiple values from a function. Tuples are
the solution:</p>
<pre><pre class="playpen"><code class="language-rust">// tuple1.rs

fn add_mul(x: f64, y: f64) -&gt; (f64,f64) {
    (x + y, x * y)
}

fn main() {
    let t = add_mul(2.0,10.0);

    // can debug print
    println!(&quot;t {:?}&quot;, t);

    // can 'index' the values
    println!(&quot;add {} mul {}&quot;, t.0,t.1);

    // can _extract_ values
    let (add,mul) = t;
    println!(&quot;add {} mul {}&quot;, add,mul);
}
// t (12, 20)
// add 12 mul 20
// add 12 mul 20
</code></pre></pre>
<p>The <code>let (add,mul) = t</code> construct is similar to that found in Python, except it only works
with tuple values, not any source of values.</p>
<p>Tuples may contain <em>different</em> types, which is the main difference from arrays.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let tuple = (&quot;hello&quot;, 5, 'c');

assert_eq!(tuple.0, &quot;hello&quot;);
assert_eq!(tuple.1, 5);
assert_eq!(tuple.2, 'c');

#}</code></pre></pre>
<p>They appear in some <code>Iterator</code> methods. This is like the Python generator
of the same name:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    for (i,s) in [&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;].iter().enumerate() {
        print!(&quot; {} {};&quot;,i,s);
    }
    //  0 zero; 1 one; 2 two;

#}</code></pre></pre>
<p><code>zip</code> is specifically for combining two iterators into a single iterator of
tuples containing the values:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let names = [&quot;ten&quot;,&quot;hundred&quot;,&quot;thousand&quot;];
    let nums = [10,100,1000];
    for (name,num) in names.iter().zip(nums.iter()) {
        print!(&quot; {} {};&quot;, name,num);
    }
    //  ten 10; hundred 100; thousand 1000;

#}</code></pre></pre>
<a class="header" href="print.html#structs" name="structs"><h2>Structs</h2></a>
<p>Tuples are convenient, but saying <code>t.1</code> and keeping track of the meaning of each part
is tedious for anything that isn't straightforward.</p>
<p>Rust <em>structs</em> contain named <em>fields</em>:</p>
<pre><pre class="playpen"><code class="language-rust">// struct1.rs

struct Person {
    first_name: String,
    last_name: String
}

fn main() {
    let p = Person {
        first_name: &quot;John&quot;.to_string(),
        last_name: &quot;Smith&quot;.to_string()
    };
    println!(&quot;person {} {}&quot;, p.first_name,p.last_name);
}
</code></pre></pre>
<p>The values of a struct will be placed next to each other in memory, although you should
not assume any particular memory layout - the compiler will organize the memory for
efficiency, not size, and so there will be padding. A <code>struct</code> should be familiar to C or
C++ programmers.</p>
<p>Initializing this struct is a bit clumsy, so we want to move the construction of a <code>Person</code>
into its own function. This function can be made into a <em>method</em> of <code>Person</code> by putting
it into a <code>impl</code> block:</p>
<pre><pre class="playpen"><code class="language-rust">// struct2.rs

struct Person {
    first_name: String,
    last_name: String
}

impl Person {

    fn new(first: &amp;str, name: &amp;str) -&gt; Person {
        Person {
            first_name: first.to_string(),
            last_name: name.to_string()
        }
    }

}

fn main() {
    let p = Person::new(&quot;John&quot;,&quot;Smith&quot;);
    println!(&quot;person {} {}&quot;, p.first_name,p.last_name);
}
</code></pre></pre>
<p>There is nothing magic or reserved about the name <code>new</code> here. Note that it's accessed
using a C++-like notation (what C++ would call in its usual clunky way a 'static member
function'.)</p>
<p>Here's a another <code>Person</code> method, but with a <em>reference self</em> argument:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
impl Person {
    ...

    fn full_name(&amp;self) -&gt; String {
        format!(&quot;{} {}&quot;, self.first_name, self.last_name)
    }

}
...
    println!(&quot;fullname {}&quot;, p.full_name());
// fullname John Smith

#}</code></pre></pre>
<p>The <code>self</code> is used explicitly (unlike the <code>this</code> of C++) and is passed as a reference.
(You can think of <code>&amp;self</code> as <code>self: &amp;Person</code>.)</p>
<p>The keyword <code>Self</code> refers to the struct type - you can mentally substitute <code>Person</code>
for <code>Self</code> here:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn copy(&amp;self) -&gt; Self {
        Self::new(&amp;self.first_name,&amp;self.last_name)
    }

#}</code></pre></pre>
<p>Methods may allow the data to be modified using a <em>mutable self</em> argument:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn set_first_name(&amp;mut self, name: &amp;str) {
        self.first_name = name.to_string();
    }

#}</code></pre></pre>
<p>And the data will <em>move</em> into the method when a plain self argument is used:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn to_tuple(self) -&gt; (String,String) {
        (self.first_name, self.last_name)
    }

#}</code></pre></pre>
<p>(Try that with <code>&amp;self</code> - structs will not let go of their data without a fight!)</p>
<p>If you try to do a debug dump of a <code>Person</code>, you will get an informative error:</p>
<pre><code>error[E0277]: the trait bound `Person: std::fmt::Debug` is not satisfied
  --&gt; struct2.rs:23:21
   |
23 |     println!(&quot;{:?}&quot;, p);
   |                     ^ the trait `std::fmt::Debug` is not implemented for `Person`
   |
   = note: `Person` cannot be formatted using `:?`; if it is defined in your crate,
    add `#[derive(Debug)]` or manually implement it
   = note: required by `std::fmt::Debug::fmt`
</code></pre>
<p>The compiler is giving advice, so we put <code>#[derive(Debug)]</code> in front of <code>Person</code>, and now
there is sensible output:</p>
<pre><code>Person { first_name: &quot;John&quot;, last_name: &quot;Smith&quot; }
</code></pre>
<p>The <em>directive</em> makes the compiler generate a <code>Debug</code> implementation, which is very
helpful. It's good practice to do this for your structs, so they can be
printed out (or written as a string using <code>format!</code>).  (Doing so <em>by default</em> would be
very un-Rustlike.)</p>
<a class="header" href="print.html#lifetimes-start-to-bite" name="lifetimes-start-to-bite"><h2>Lifetimes Start to Bite</h2></a>
<p>Usually structs contain values, but often they also need to contain references.
Say we want to put a string slice, not a string value, in a struct.</p>
<pre><pre class="playpen"><code class="language-rust">// life1.rs

#[derive(Debug)]
struct A {
    s: &amp;str
}

fn main() {
    let a = A { s: &quot;hello dammit&quot; };

    println!(&quot;{:?}&quot;, a);
}
</code></pre></pre>
<pre><code>error[E0106]: missing lifetime specifier
 --&gt; life1.rs:5:8
  |
5 |     s: &amp;str
  |        ^ expected lifetime parameter
</code></pre>
<p>To understand the complaint, you have to see the problem from the point of view of Rust.
It will not allow a reference to be stored without knowing its lifetime. Because all
references are borrowed from some value, and values have lifetimes. The lifetime of
a reference cannot be longer than the lifetime of that value.
Rust cannot allow
a situation where that reference could suddenly become invalid.</p>
<p>Now, there are basically two kinds of string slices; those that refer to <em>string literals</em>
like &quot;hello&quot; and those that borrow from <code>String</code> values. String literals exist for the duration
of the whole program, which is called the 'static' lifetime.</p>
<p>So this works - we assure Rust that the string slice always refers to such static strings:</p>
<pre><pre class="playpen"><code class="language-rust">// life2.rs

#[derive(Debug)]
struct A {
    s: &amp;'static str
}

fn main() {
    let a = A { s: &quot;hello dammit&quot; };

    println!(&quot;{:?}&quot;, a);
}
// A { s: &quot;hello dammit&quot; }
</code></pre></pre>
<p>It is not the most <em>pretty</em> notation, but sometimes ugliness is the necessary
price of being precise.</p>
<p>This can also be used to specify a string slice that is returned from a function:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn how(i: u32) -&gt; &amp;'static str {
    match i {
    0: 'none',
    1: 'one',
    _: 'many'
    }
}

#}</code></pre></pre>
<p>That works for the special case of static strings, but this is very restrictive.</p>
<p>However we can specify that the lifetime of the reference is <em>as least as long</em> as that of
the struct itself.</p>
<pre><pre class="playpen"><code class="language-rust">// life3.rs

#[derive(Debug)]
struct A &lt;'a&gt; {
    s: &amp;'a str
}

fn main() {
    let string = &quot;I'm a little string&quot;.to_string();
    let a = A { s: &amp;string };

    println!(&quot;{:?}&quot;, a);
}
</code></pre></pre>
<p>Lifetimes are conventionally called 'a','b',etc but you could just as well called it
'me' here.</p>
<p>Sometimes it seems like a good idea for a struct to contain a value <em>and</em> a reference
that borrows from that value.
It's basically impossible because structs must be <em>moveable</em>, and any move will
invalidate the reference.  It isn't necessary to do this - for instance, if your
struct has a string field, and needs to provide slices, then it could keep indices
and have a method to generate the actual slices.</p>
<a class="header" href="print.html#traits" name="traits"><h2>Traits</h2></a>
<p>Please note that Rust does not spell <code>struct</code> <em>class</em>. The keyword <code>class</code> in other
languages is so overloaded with meaning that it effectively shuts down original thinking.</p>
<p>Let's put it like this: Rust structs cannot <em>inherit</em> from other structs; they are
all unique types. There is no <em>sub-typing</em>. They are dumb data.</p>
<p>So how <em>does</em> one establish relationships between types? This is where <em>traits</em> come in.</p>
<p><code>rustc</code> often talks about <code>implementing X trait</code> and so it's time to talk about traits
properly.</p>
<p>Here's a little example of defining a trait and <em>implementing</em> it for a particular type.</p>
<pre><pre class="playpen"><code class="language-rust">// trait1.rs

trait Show {
    fn show(&amp;self) -&gt; String;
}

impl Show for i32 {
    fn show(&amp;self) -&gt; String {
        format!(&quot;four-byte unsigned {}&quot;, self)
    }
}

impl Show for f64 {
    fn show(&amp;self) -&gt; String {
        format!(&quot;eight-byte float {}&quot;, self)
    }
}

fn main() {
    let answer = 42;
    let maybe_pi = 3.14;
    let s1 = answer.show();
    let s2 = maybe_pi.show();
    println!(&quot;show {}&quot;, s1);
    println!(&quot;show {}&quot;, s2);
}
// show four-byte signed 42
// show eight-byte float 3.14
</code></pre></pre>
<p>It's pretty cool; we have <em>added a new method</em> to both <code>i32</code> and <code>f64</code>!</p>
<p>Getting comfortable with Rust involves learning the basic traits of the
standard library (they tend to hunt in packs.)</p>
<p><code>Debug</code> is very common.
We gave <code>Person</code> a default implementation with the
convenient <code>#[derive(Debug)]</code>, but say we want a <code>Person</code> to display as its full name:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
use std::fmt;

impl fmt::Debug for Person {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{}&quot;, self.full_name())
    }
}
...
    println!(&quot;{:?}&quot;, p);
    // John Smith

#}</code></pre></pre>
<p><code>write!</code> is a very useful macro - here <code>f</code> is anything that implements <code>Write</code>.
(This would also work with a <code>File</code> - or even a <code>String</code>.)</p>
<p>Now, with the implementations of <code>Show</code> in <code>trait1.rs</code>, here's a
little main program with big implications:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let answer = 42;
    let maybe_pi = 3.14;
    let v: Vec&lt;&amp;Show&gt; = vec![&amp;answer,&amp;maybe_pi];
    for d in v.iter() {
        println!(&quot;show {}&quot;,d.show());
    }
}
// show four-byte signed 42
// show eight-byte float 3.14
</code></pre></pre>
<p>This is a case where Rust needs some type guidance - I specifically want a vector
of references to anything that implements <code>Show</code>.  Now note that <code>i32</code> and <code>f64</code>
have no relationship to each other, but they both understand the <code>show</code> method
because they both implement the same trait. This method is <em>virtual</em>, because
the actual function has different code for different types, and yet the correct
method is invoked based on <em>runtime</em> information. These references
are called <a href="https://doc.rust-lang.org/stable/book/trait-objects.html">trait objects</a>.</p>
<p>And <em>that</em> is how you can put objects of different types in the same vector. If
you come from a Java background, you can think of <code>Show</code> as an interface; the
nearest C++ equivalent is &quot;abstract base class&quot;.</p>
<a class="header" href="print.html#example-iterator-over-floating-point-range" name="example-iterator-over-floating-point-range"><h2>Example: iterator over floating-point range</h2></a>
<p>We have met ranges before (<code>0..n</code>) but they don't work for floating-point values. (You
can <em>force</em> this but you'll end up with a step of 1.0 which is uninteresting.)</p>
<p>Recall the informal definition of an iterator; it is an struct with a <code>next</code> method
which may return <code>Some</code>-thing or <code>None</code>. In the process, the iterator itself gets modified,
it keeps the state for the iteration (like next index and so forth.) The data that
is being iterated over doesn't change usually, (But see <code>std::vec::Vec::drain</code> for an
interesting iterator that does modify its data.)</p>
<p>And here is the formal definition: the <code>Iterator</code> trait:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    ...
}

#}</code></pre></pre>
<p>Here we meet an <a href="https://doc.rust-lang.org/stable/book/associated-types.html">associated type</a> of the <code>Iterator</code> trait.
This trait must work for any type, so you must specify that return type somehow.
The method can then be written without using a
particular type - instead it refers to that type parameter's <code>Item</code> via <code>Self</code>.</p>
<p>The iterator trait for <code>f64</code> is written <code>Iterator&lt;Item=f64&gt;</code>, which can be read as
&quot;an Iterator with its associated type Item set to f64&quot;.</p>
<p>The <code>...</code> refers to the <em>default methods</em> of <code>Iterator</code>. You only need to define <code>Item</code>
and <code>next</code>, and the default methods are defined for you.</p>
<pre><pre class="playpen"><code class="language-rust">// trait3.rs

struct FRange {
    val: f64,
    end: f64,
    incr: f64
}

fn range(x1: f64, x2: f64, skip: f64) -&gt; FRange {
    FRange {val: x1, end: x2, incr: skip}
}

impl Iterator for FRange {
    type Item = f64;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let res = self.val;
        if res &gt;= self.end {
            None
        } else {
            self.val += self.incr;
            Some(res)
        }
    }
}


fn main() {
    for x in range(0.0, 1.0, 0.1) {
        println!(&quot;{} &quot;, x);
    }
}
</code></pre></pre>
<p>And the rather messy looking result is</p>
<pre><code>0
0.1
0.2
0.30000000000000004
0.4
0.5
0.6
0.7
0.7999999999999999
0.8999999999999999
0.9999999999999999
</code></pre>
<p>This is because 0.1 is not precisely representable as a float, so a little formatting
help is needed. Replace the <code>println!</code> with this</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
println!(&quot;{:.1} &quot;, x);

#}</code></pre></pre>
<p>And we get cleaner output (this format means 'one decimal after dot'.)</p>
<p>All of the default iterator methods are available, so we can collect these values into
a vector:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let v: Vec&lt;f64&gt; = range(0.0, 1.0, 0.1).collect();

#}</code></pre></pre>
<p>This is a common pattern and it gets irritating. Fortunately, it's easy to
add new 'consumers' of iterators. These are those methods that end the chain and
'pull' all the values of the iterator, like <code>count</code> - or <code>collect</code>.</p>
<p>We will define a new trait <code>ToVec</code> which has an associated type, just like an <code>Iterator</code>.
It will be the type contained in the returned vector.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
trait ToVec {
    type Item;

    fn to_vec(self) -&gt; Vec&lt;Self::Item&gt;;
}

#}</code></pre></pre>
<p>And now we'll implement <code>ToVec</code> for <code>Iterator</code>. All that <code>Vec</code> requires of its elements is that they
have a size. (Traits, being abstract, have no size.) The actual iterator type <code>I</code>
must implement <code>Iterator</code> with its associated type <code>Item</code> set to <code>T</code>, the element
type. There is only one free type parameter <code>T</code> since <code>I</code> is defined in terms of <code>T</code>.</p>
<p>Alternatively: This implementation of <code>ToVec</code> has type parameters <code>T</code> and <code>I</code>. <code>T</code> must implement <code>Size</code> to
make <code>Vec</code> happy. <code>I</code> is any concrete type that implements an iterator for values of the type <code>T</code>.</p>
<p>The actual implementation is delegated to the <code>FromIterator</code> trait, which is
defined for vectors and constructs a vector by consuming an iterator (it's exactly how <code>collect</code> is
implemented)</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
impl &lt;T,I&gt; ToVec for I
where T: Sized, I: Iterator&lt;Item=T&gt; {
    type Item = T;

    fn to_vec(self) -&gt; Vec&lt;Self::Item&gt; {
        FromIterator::from_iter(self)
    }
}
    ....
    let v = range(0.0, 1.0, 0.1).to_vec();

#}</code></pre></pre>
<p>Et voilà! No more awkwardness! The implementation was a little scary, but familiarity
breeds acceptance.</p>
<a class="header" href="print.html#simple-enums" name="simple-enums"><h2>Simple Enums</h2></a>
<p>Enums are types which have a few definite values. For instance, a direction has
only four possible values.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
enum Direction {
    Up,
    Down,
    Left,
    Right
}
...
    // `start` is type `Direction`
    let start = Direction::Left;

#}</code></pre></pre>
<p>They can have methods defined on them, just like structs.
The  <code>match</code> expression is the basic way to handle <code>enum</code> values.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
impl Direction {
    fn as_str(&amp;self) -&gt; &amp;'static str {
        match *self {
        Direction::Up =&gt; &quot;Up&quot;,
        Direction::Down =&gt; &quot;Down&quot;,
        Direction::Left =&gt; &quot;Left&quot;,
        Direction::Right =&gt; &quot;Right&quot;
        }
    }
}

#}</code></pre></pre>
<p>Both the typename and <code>self</code> are explicit in Rust, unlike C++. This is generally a
good idea, because the baroque way C++ resolves names is a little too clever for normal
humans. (And there is a shortcut, as we will see.)</p>
<p>Punctuation matters. Note that <code>*</code> before <code>self</code>. It's easy to forget, because often
Rust will assume it (we said <code>self.first_name</code>, not <code>*self.first_name</code>). However,
matching is a more exact business. Leaving it out would give a whole spew of messages,
which boil down to this type mismatch:</p>
<pre><code>   = note: expected type `&amp;Direction`
   = note:    found type `Direction`
</code></pre>
<p>This is because <code>self</code> has type <code>&amp;Direction</code>, so we have to throw in the <code>*</code> to
<em>deference</em> the type.</p>
<p>Like structs, enums can implement traits, and our friend <code>#[derive(Debug)]</code> can
be added to <code>Direction</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
        println!(&quot;start {:?}&quot;,start);
        // start Left

#}</code></pre></pre>
<p>So that <code>as_str</code> method isn't really necessary, since we can always get the name from <code>Debug</code>.
(But <code>as_str</code> does <em>not allocate</em>, which may be important.)</p>
<p>You should not assume any particular ordering here - there's no implied integer
'ordinal' value.</p>
<p>Here's a method which defines the 'successor' of each <code>Direction</code> value. The
very handy <em>wildcard use</em> temporarily puts the enum names into the method context:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn inc(&amp;self) -&gt; Direction {
        use Direction::*;
        match *self {
        Up =&gt; Right,
        Right =&gt; Down,
        Down =&gt; Left,
        Left =&gt; Up
        }
    }
    ...

    let mut d = start;
    for _ in 0..8 {
        println!(&quot;d {:?}&quot;, d);
        d = d.inc();
    }
    // d Left
    // d Up
    // d Right
    // d Down
    // d Left
    // d Up
    // d Right
    // d Down

#}</code></pre></pre>
<p>So this will cycle endlessly through the various directions in this particular, arbitrary,
order. It is (in fact) a very simple <em>state machine</em>.</p>
<p>Out of the box, these values can't be compared:</p>
<pre><code>assert_eq!(start, Direction::Left);

error[E0369]: binary operation `==` cannot be applied to type `Direction`
  --&gt; enum1.rs:42:5
   |
42 |     assert_eq!(start, Direction::Left);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
note: an implementation of `std::cmp::PartialEq` might be missing for `Direction`
  --&gt; enum1.rs:42:5
</code></pre>
<p>The solution is to say <code>#[derive(Debug,PartialEq)]</code> in front of <code>enum Direction</code>.</p>
<p>This is an important point - Rust user-defined types start out fresh and unadorned.
You give them sensible default behaviours by implementing the common traits. This
applies also to structs - if you ask for Rust to derive <code>PartialEq</code> for a struct it
will do the sensible thing, assume that all fields implement it and build up
a comparison. If this isn't so, or you want to redefine equality, then you are free
to define <code>PartialEq</code> explicitly.</p>
<p>Rust does 'C style enums' as well:</p>
<pre><pre class="playpen"><code class="language-rust">// enum2.rs

enum Speed {
    Slow = 10,
    Medium = 20,
    Fast = 50
}

fn main() {
    let s = Speed::Slow;
    let speed = s as u32;
    println!(&quot;speed {}&quot;, speed);
}
</code></pre></pre>
<p>They are initialized with an integer value, and can be converted into that integer
with a type cast. It's essentially a convenient way to create a set of constants.</p>
<p>Like with C enums, you only need to give the first name a value, and thereafter the
value goes up by one each time.</p>
<p>(By the way, 'name' is too vague, like saying 'thingy' all the time. The proper term here
is <em>variant</em> - <code>Speed</code> has variants <code>Slow</code>,<code>Medium</code> and <code>Fast</code>.)</p>
<p>These enums <em>do</em> have a natural ordering, but you have to ask nicely.
After placing <code>#[derive(PartialEq,PartialOrd)]</code> in front of <code>enum Speed</code>, then it's indeed
true that <code>Speed::Fast &gt; Speed::Slow</code> and <code>Speed::Medium != Speed::Slow</code>.</p>
<a class="header" href="print.html#enums-in-their-full-glory" name="enums-in-their-full-glory"><h2>Enums in their Full Glory</h2></a>
<p>Rust enums in their full form are like C unions on steroids, like a Ferrari compared
to a Fiat Uno. Consider the problem of storing different values in a type-safe way.</p>
<pre><pre class="playpen"><code class="language-rust">// enum3.rs

#[derive(Debug)]
enum Value {
    Number(f64),
    Str(String),
    Bool(bool)
}

fn main() {
    use Value::*;
    let n = Number(2.3);
    let s = Str(&quot;hello&quot;.to_string());
    let b = Bool(true);

    println!(&quot;n {:?} s {:?} b {:?}&quot;, n,s,b);
}
// n Number(2.3) s Str(&quot;hello&quot;) b Bool(true)
</code></pre></pre>
<p>Again, this enum can only contain <em>one</em> of these values; its size will be the size of
the largest variant.</p>
<p>So far, not really a supercar, although it's cool that they know how to print themselves
out. But they also know how <em>what kind</em> of value they contain, and <em>that</em> is the
superpower of <code>match</code>.</p>
<p>Let me give you a function with a mistake. We want to print out a custom string based
on the <em>Value</em>'s contained type, and we want to pass it as a reference, because otherwise
a move would take place and the value would be eaten:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn dump(v: &amp;Value) {
    use Value::*;
    match *v {
        Number(n) =&gt; println!(&quot;number is {}&quot;, n),
        Str(s) =&gt; println!(&quot;string is '{}'&quot;, s),
        Bool(b) =&gt; println!(&quot;boolean is {}&quot;, b)
    }
}

#}</code></pre></pre>
<pre><code>error[E0507]: cannot move out of borrowed content
  --&gt; enum3.rs:12:11
   |
12 |     match *v {
   |           ^^ cannot move out of borrowed content
13 |     Number(n) =&gt; println!(&quot;number is {}&quot;,n),
14 |     Str(s) =&gt; println!(&quot;string is '{}'&quot;,s),
   |         - hint: to prevent move, use `ref s` or `ref mut s`
</code></pre>
<p>There are things you cannot do with borrowed references. Rust is not letting
you <em>extract</em> the string contained in the original value. It did not complain about <code>Number</code>
because it's happy to copy <code>f64</code>, but <code>String</code> does not implement <code>Copy</code>.</p>
<p>I mentioned earlier that <code>match</code> is picky about <em>exact</em> types</p>
<ul>
<li>here we follow the hint and things will work; now we are just borrowing a reference
to that contained string.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn dump(v: &amp;Value) {
    use Value::*;
    match *v {
    Number(n) =&gt; println!(&quot;number is {}&quot;, n),
    Str(ref s) =&gt; println!(&quot;string is '{}'&quot;, s),
    Bool(b) =&gt; println!(&quot;boolean is {}&quot;, b)
    }
}
    ....

    dump(&amp;s);
    // string is 'hello'

#}</code></pre></pre>
<p>Before we move on, filled with the euphoria of a successful Rust compilation, let's
pause a little. <code>rustc</code> is unusually good at generating errors that have enough
context for a human to fix the error without necessarily <em>understanding</em> the error.</p>
<p>The issue is a combination of the exactness of matching, with the determination of the
borrow checker to foil any attempt to break the Rules.  One of those Rules is that
you cannot yank out a value which belongs to some owning type. Some knowledge of
C++ is a hindrance here, since <code>c++</code> will copy its way out of the problem, whether that
copy even <em>makes sense</em>.  You will get exactly the same error if you try to pull out
a value from a vector, say with <code>*v[0]</code> (<code>*</code> because indexing returns references.)
It will simply not let you do this. (Sometimes <code>clone</code> isn't such a bad solution to this.)</p>
<p>As for <code>match</code>, you can see <code>Str(s) =&gt;</code> as short for <code>Str(s: String) =&gt;</code>. A local variable
(often called a <em>binding</em>) is created.  Often that inferred type is cool, when you
eat up a value and extract its contents. But here we really needed is <code>s: &amp;String</code>, and the
<code>ref</code> is a hint that ensures this: we just want to borrow that string.</p>
<p>Here is a method that really does eat up a <code>Value</code>. It's a classic use of <code>Option</code>,
because either that value contained a string, or it didn't.</p>
<p>Look carefully (punctuation matters!) - the method signature is now plain <code>self</code>, and
the <code>*</code> has dropped. The <code>self</code> argument is <em>moved</em> into the method.</p>
<p>Here we do want to extract that string, and don't care about
the enum value afterwards.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
impl Value {
    fn to_str(self) -&gt; Option&lt;String&gt; {
        match self {
        Value::Str(s) =&gt; Some(s),
        _ =&gt; None
        }
    }
}
    ...
    println!(&quot;s? {:?}&quot;, s.to_str());
    // s? Some(&quot;hello&quot;)
    // println!(&quot;{:?}&quot;, s) // error! s has moved...

#}</code></pre></pre>
<p>Naming also matters - this is called <code>to_str</code>, not <code>as_str</code>. You can write a
method that just borrows that string as an <code>Option&lt;&amp;String&gt;</code> (The reference will need
the same lifetime as the enum value.)  But you would not call it <code>to_str</code>.</p>
<p>You can write <code>to_str</code> like this - it is completely equivalent:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn to_str(self) -&gt; Option&lt;String&gt; {
        if let Value::Str(s) = self {
            Some(s)
        } else {
            None
        }
    }

#}</code></pre></pre>
<a class="header" href="print.html#more-about-matching" name="more-about-matching"><h2>More about Matching</h2></a>
<p>Recall that the values of a tuple can be extracted with '()':</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let t = (10,&quot;hello&quot;.to_string());
    ...
    let (n,s) = t;
    // t has been moved. It is No More
    // n is i32, s is String

#}</code></pre></pre>
<p>This is a special case of <em>destructuring</em>; we have some
data and wish to either pull it apart (like here) or just borrow its values.
Either way, we get the parts of a structure.</p>
<p>The syntax used for borrowing is just like that used in <code>match</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let (ref n,ref s) = t;
    // n and s are borrowed from t. It still lives!
    // n is &amp;i32, s is &amp;String

#}</code></pre></pre>
<p>Destructuring works with structs as well:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    struct Point {
        x: f32,
        y: f32
    }

    let p = Point{x:1.0,y:2.0};
    ...
    let Point{x,y} = p;
    // p still lives, since x and y can be copied
    // both x and y are f32

#}</code></pre></pre>
<p>Time to revisit <code>match</code> with some new patterns. The first two patterns are exactly like <code>let</code>
destructuring - it only matches tuples with first element zero, but <em>any</em> string;
the second adds an <code>if</code> so that it only matches <code>(1,&quot;hello&quot;)</code>.</p>
<p>Finally, just a variable matches <em>anything</em>. This is useful if the <code>match</code> applies
to an expression and you don't want to bind a variable to that expression. <code>_</code> works
like a variable but is ignored (<code>_</code> behaves rather like it does in Go.) It's a common
way to finish off a <code>match</code>, like <code>default</code> in C <code>switch</code> statements.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn match_tuple(t: (i32,String)) {
    let text = match t {
        (0, s) =&gt; format!(&quot;zero {}&quot;, s),
        (1, ref s) if s == &quot;hello&quot; =&gt; format!(&quot;hello one!&quot;),
        tt =&gt; format!(&quot;no match {:?}&quot;, tt)
     };
    println!(&quot;{}&quot;, text);
}

#}</code></pre></pre>
<p>Why not just match against <code>(1,&quot;hello&quot;)</code>? Matching is an exact business, and the compiler
will complain:</p>
<pre><code>  = note: expected type `std::string::String`
  = note:    found type `&amp;'static str`
</code></pre>
<p>Why do we need <code>ref s</code>? It's a slightly obscure gotcha (look up the E00008 error) where
if you have an <em>if guard</em> you need to borrow, since the if guard happens in a different
context, a move will take place otherwise. It's a case of the implementation leaking
ever so slightly.</p>
<p>If the type <em>was</em> <code>&amp;str</code> then we match it directly:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    match (42,&quot;answer&quot;) {
        (42,&quot;answer&quot;) =&gt; println!(&quot;yes&quot;),
        _ =&gt; println!(&quot;no&quot;)
    };

#}</code></pre></pre>
<p>What applies to <code>match</code> applies to <code>if let</code>. This is a cool example, since if we
get a <code>Some</code>, we can match inside it and only extract the string from the tuple. So it
isn't necessary to have nested <code>if let</code> statements here.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let ot = Some((2,&quot;hello&quot;.to_string());

    if let Some((_,ref s)) = ot {
        assert_eq!(s, &quot;hello&quot;);
    }
    // we just borrowed the string, no 'destructive destructuring'

#}</code></pre></pre>
<p>An interesting problem happens when using <code>parse</code> (or any function which needs to work
out its return type from context)</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    if let Ok(n) = &quot;42&quot;.parse() {
        ...
    }

#}</code></pre></pre>
<p>So what's the type of <code>n</code>? You have to give a hint somehow - what kind of integer? Is it
even an integer?</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    if let Ok(n) = &quot;42&quot;.parse::&lt;i32&gt;() {
        ...
    }

#}</code></pre></pre>
<p>This somewhat non-elegant syntax is called the 'turbofish operator'.</p>
<p>If you are in a function returning <code>Result</code>, then the question-mark operator provides a much
more elegant solution:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let n: i32 = &quot;42&quot;.parse()?;

#}</code></pre></pre>
<p>However, the parse error needs to be convertible to the error type of the <code>Result</code>, which is a topic
we'll take up later when discussing error handling.</p>
<a class="header" href="print.html#closures" name="closures"><h2>Closures</h2></a>
<p>A great deal of Rust's power comes from <em>closures</em>. In their simplest form, they
act like shortcut functions:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let f = |x| x * x;

    let res = f(10);

    println!(&quot;res {}&quot;, res);
    // res 100

#}</code></pre></pre>
<p>There are no explicit types in this example - everything is deduced, starting with the
integer literal 10.</p>
<p>We get an error if we call <code>f</code> on different types - Rust has already decided that
<code>f</code> must be called on an integer type:</p>
<pre><code>    let res = f(10);

    let resf = f(1.2);
  |
8 |     let resf = f(1.2);
  |                  ^^^ expected integral variable, found floating-point variable
  |
  = note: expected type `{integer}`
  = note:    found type `{float}`

</code></pre>
<p>So, the first call fixes the type of the argument <code>x</code>. It's equivalent to this function:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn f (x: i32) -&gt; i32 {
        x*x
    }

#}</code></pre></pre>
<p>But there's a big difference between functions and closures, <em>apart</em> from the need for explicit typing.
Here we evaluate a linear function:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let m = 2.0;
    let c = 1.0;

    let lin = |x| m*x + c;

    println!(&quot;res {} {}&quot;, lin(1.0), lin(2.0));
    // res 3 5

#}</code></pre></pre>
<p>You cannot do this with the explicit <code>fn</code> form - it does not know about variables
in the enclosing scope. The closure has <em>borrowed</em> <code>m</code> and <code>c</code> from its context.</p>
<p>The usual Rules of Borrowing apply. This works fine - our little closure is borrowing
<code>answer</code> mutably.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let mut answer = 42;

let set = |v| answer = v;

//let get = || answer;

set(58);
assert_eq!(answer, 58);

#}</code></pre></pre>
<p>But uncomment <code>get</code> and you get a borrowing error:
&quot;cannot borrow <code>answer</code> as immutable because it is also borrowed as mutable&quot;</p>
<p>Now, what's the type of <code>lin</code>? Only <code>rustc</code> knows. Exactly the same situation applies
to C++ lambdas, and for exactly the same version. Under the hood, a closure is a <em>struct</em>
that implements the call operator. All closures are unique types</p>
<ul>
<li>but they have traits in common.</li>
</ul>
<p>So even though we don't know the exact type, we know the generic constraint:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn apply&lt;F&gt;(x: f64, f: F) -&gt; f64
where F: Fn(f64)-&gt;f64  {
    f(x)
}
...
    let res1 = apply(3.0,lin);
    let res2 = apply(3.14, |x| x.sin());

#}</code></pre></pre>
<p>In English: <code>apply</code> works for <em>any</em> type <code>T</code> such that <code>T</code> implements <code>Fn(f64)-&gt;f64</code> - that
is, is a function which takes <code>f64</code> and returns <code>f64</code>.</p>
<p>After the call to <code>apply(3.0,lin)</code>, trying to access <code>lin</code> gives an interesting error:</p>
<pre><code>    let l = lin;
error[E0382]: use of moved value: `lin`
  --&gt; closure2.rs:22:9
   |
16 |     let res = apply(3.0,lin);
   |                         --- value moved here
...
22 |     let l = lin;
   |         ^ value used here after move
   |
   = note: move occurs because `lin` has type
    `[closure@closure2.rs:12:15: 12:26 m:&amp;f64, c:&amp;f64]`,
     which does not implement the `Copy` trait

</code></pre>
<p>That's it, <code>apply</code> ate our closure. And there's the actual type of the struct that
<code>rustc</code> made up to implement it. Thinking of closures as structs is useful because they
are <em>values</em> and it's important to know what happens when values move.</p>
<p>Thinking of calling a closure as a <em>method call</em> makes it easy to understand the
three kinds of function traits - they are the three kinds of methods:</p>
<ul>
<li><code>Fn</code> struct passed as <code>&amp;self</code></li>
<li><code>FnMut</code> struct passed as <code>&amp;mut self</code></li>
<li><code>FnOnce</code> struct passed as <code>self</code></li>
</ul>
<p>So it's possible for a closure to mutate its <em>captured</em> references:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn mutate&lt;F&gt;(mut f: F)
    where F: FnMut() {
        f()
    }
    let mut s = &quot;world&quot;;
    mutate(|| s = &quot;hello&quot;);
    assert_eq!(s, &quot;hello&quot;);

#}</code></pre></pre>
<p>Note that <code>mut</code> - <code>f</code> needs to be mutable for this to work.</p>
<p>At this point, if you are used to languages like JavaScript or Lua, you may wonder at the
apparent complexity of closures compared with how straightforward they are in those languages.
This is the necessary cost of Rust's promise to not sneakily make any allocations. In JavaScript,
the equivalent <code>mutate(function() {s = &quot;hello&quot;;})</code> will always result in a dynamically
allocated closure.</p>
<p>You can of course explicitly create a dynamically allocated closure in Rust using <code>Box::new</code>.
This solves the problem of keeping a collection of different closures that implement the
same trait.  The <code>Box</code> struct is fed a
value, allocates enough memory for it on the heap, and moves that value to the heap.
A <code>Box</code> always has the same size (it's basically a smart pointer.) so we're good to go.</p>
<p>Here's a first try:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let mut v = Vec::new();
    v.push(Box::new(|x| x * x));
    v.push(Box::new(|x| x / 2.0));

    for f in v.iter() {
        let res = f(1.0);
        println!(&quot;res {}&quot;, res);
    }

#}</code></pre></pre>
<p>We get a very definite error on the second push:</p>
<pre><code>  = note: expected type `[closure@closure4.rs:4:21: 4:28]`
  = note:    found type `[closure@closure4.rs:5:21: 5:28]`
note: no two closures, even if identical, have the same type
</code></pre>
<p><code>rustc</code> has deduced a type which is too specific, so it's necessary to force that
vector to have the <em>boxed trait type</em> before things just work:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let mut v: Vec&lt;Box&lt;Fn(f64)-&gt;f64&gt;&gt; = Vec::new();

#}</code></pre></pre>
<p>You can use these boxed closures to implement callbacks and so forth. If you want to keep
these boxed closures in a struct, then you will need a lifetime annotation, because
<em>closures borrow variables</em> and so their lifetime is tied to the lifetime of those
variables.</p>
<p>Sometimes you don't want a closure to borrow those variables, but instead <em>move</em> them.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let name = &quot;dolly&quot;.to_string();
    let age = 42;

    let c = move || {
        println!(&quot;name {} age {}&quot;, name,age);
    };

    c();

    println!(&quot;name {}&quot;,name);

#}</code></pre></pre>
<p>And the error at the last <code>println</code> is: &quot;use of moved value: <code>name</code>&quot;. So one solution
here - if we <em>did</em> want to keep <code>name</code> alive - is to move a cloned copy into the closure:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let cname = name.to_string();
    let c = move || {
        println!(&quot;name {} age {}&quot;,cname,age);
    }

#}</code></pre></pre>
<p>Why are moved closures needed? Because we might need to call them at a point where
the original context no longer exists. A classic case is when creating a <em>thread</em>.</p>
<p>A major use of closures is within iterator methods. Recall the <code>range</code> iterator we
defined to go over a range of floating-point numbers. It's straightforward to operate
on this (or any other iterator) using closures:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let sine: Vec&lt;f64&gt; = range(0.0,1.0,0.1).map(|x| x.sin()).collect();

#}</code></pre></pre>
<p><code>map</code> isn't defined on vectors (although it's easy enough to create a trait that does this),
because then <em>every</em> map  will create a new vector.  This way, we have a choice. In this
sum, no temporary objects are created:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
 let sum: f64 = range(0.0,1.0,0.1).map(|x| x.sin()).sum();

#}</code></pre></pre>
<p>It will (in fact) be as fast as writing it out as an explicit loop!</p>
<p><code>filter</code> is another useful iterator method - it only lets through values that match
a condition:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let tuples = [(10,&quot;ten&quot;),(20,&quot;twenty&quot;),(30,&quot;thirty&quot;),(40,&quot;forty&quot;)];
    let iter = tuples.iter().filter(|t| t.0 &gt; 20).map(|t| t.1);

    for name in iter {
        println!(&quot;{} &quot;, name);
    }
    // thirty
    // forty

#}</code></pre></pre>
<a class="header" href="print.html#the-three-kinds-of-iterators" name="the-three-kinds-of-iterators"><h2>The Three Kinds of Iterators</h2></a>
<p>The three kinds correspond (again) to the three basic argument types. Assume we
have a vector of <code>String</code> values. Here are the iterator types explicitly, and
then <em>implicitly</em>, together with the actual type returned by the iterator.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
for s in vec.iter() {...} // &amp;String
for s in vec.iter_mut() {...} // &amp;mut String
for s in vec.into_iter() {...} // String

// implicit!
for s in &amp;vec {...} // &amp;String
for s in &amp;mut vec {...} // &amp;mut String
for s in vec {...} // String

#}</code></pre></pre>
<p>Personally I prefer being explicit, but it's important to understand both forms,
and their implications.</p>
<p><code>into_iter</code> <em>consumes</em> the vector and extracts its strings,
and so afterwards the vector is no longer available - it has been moved. It's
a definite gotcha for Pythonistas used to saying <code>for s in vec</code>!</p>
<p>So the
implicit form <code>for s in &amp;vec</code> is usually the one you want, just as <code>&amp;T</code> is a good
default in passing arguments to functions.</p>
<p>It's important to understand how the three kinds works because Rust relies heavily
on type deduction - you won't often see explicit types in closure arguments. And this
is a Good Thing, because it would be noisy if all those types were explicitly
<em>typed out</em>. However, the price of this compact code is that you need to know
what the implicit types actually are!</p>
<p><code>map</code> takes whatever value the iterator returns and converts it into something else,
but <code>filter</code> takes a <em>reference</em> to that value. In this case, we're using <code>iter</code> so
the iterator item type is <code>&amp;String</code>. Note that <code>filter</code> receives a reference to this type.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
for n in vec.iter().map(|x: &amp;String| x.len()) {...} // n is usize
for s in vec.iter().filter(|x: &amp;&amp;String| x.len() &gt; 2) {...}

#}</code></pre></pre>
<p>When calling methods, Rust will derefence automatically, so the problem isn't obvious.
But <code>|x: &amp;&amp;String| x == &quot;one&quot;|</code> will <em>not</em> work, because operators are more strict
about type matching. <code>rustc</code> will complain that there is no such operator that
compares <code>&amp;&amp;String</code> and <code>&amp;str</code>. So you need an explicit deference to make that <code>&amp;&amp;String</code>
into a <code>&amp;String</code> which <em>does</em> match.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
for s in vec.iter().filter(|x: &amp;&amp;String| *x == &quot;one&quot;) {...}

#}</code></pre></pre>
<p>If you leave out the explicit type, you can modify the argument so that the type of <code>s</code>
is now <code>&amp;String</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
for s in vec.iter().filter(|&amp;x| x == &quot;one&quot;)

#}</code></pre></pre>
<p>And that's usually how you will see it written.</p>
<a class="header" href="print.html#structs-with-dynamic-data" name="structs-with-dynamic-data"><h2>Structs with Dynamic Data</h2></a>
<p>A most powerful technique is <em>a struct that contain references to itself</em>.</p>
<p>Here is the basic building block of a <em>binary tree</em>, expressed in C (everyone's
favourite old relative with a frightening fondness for using power tools without
protection.)</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    struct Node {
        const char *payload;
        struct Node *left;
        struct Node *right;
    };

#}</code></pre></pre>
<p>You can not do this by <em>directly</em> including <code>Node</code> fields, because then the size of
<code>Node</code> depends on the size of <code>Node</code>... it just doesn't compute. So we use pointers
to <code>Node</code> structs, since the size of a pointer is always known.</p>
<p>If <code>left</code> isn't <code>NULL</code>, the <code>Node</code> will have a left pointing to another node, and so
moreorless indefinitely.</p>
<p>Rust does not do <code>NULL</code> (at least not <em>safely</em>) so it's clearly a job for <code>Option</code>.
But you cannot just put a <code>Node</code> in that <code>Option</code>, because we don't know the size
of <code>Node</code> (and so forth.)  This is a job for <code>Box</code>, since it contains a allocated
pointer to the data, and always has a fixed size.</p>
<p>So here's the Rust equivalent, using <code>type</code> to create an alias:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
type NodeBox = Option&lt;Box&lt;Node&gt;&gt;;

#[derive(Debug)]
struct Node {
    payload: String,
    left: NodeBox,
    right: NodeBox
}

#}</code></pre></pre>
<p>(Rust is forgiving in this way - no need for forward declarations.)</p>
<p>And a first test program:</p>
<pre><pre class="playpen"><code class="language-rust">impl Node {
    fn new(s: &amp;str) -&gt; Node {
        Node{payload: s.to_string(), left: None, right: None}
    }

    fn boxer(node: Node) -&gt; NodeBox {
        Some(Box::new(node))
    }

    fn set_left(&amp;mut self, node: Node) {
        self.left = Self::boxer(node);
    }

    fn set_right(&amp;mut self, node: Node) {
        self.right = Self::boxer(node);
    }

}


fn main() {
    let mut root = Node::new(&quot;root&quot;);
    root.set_left(Node::new(&quot;left&quot;));
    root.set_right(Node::new(&quot;right&quot;));

    println!(&quot;arr {:#?}&quot;, root);
}
</code></pre></pre>
<p>The output is surprisingly pretty, thanks to &quot;{:#?}&quot; ('#' means 'extended'.)</p>
<pre><code>root Node {
    payload: &quot;root&quot;,
    left: Some(
        Node {
            payload: &quot;left&quot;,
            left: None,
            right: None
        }
    ),
    right: Some(
        Node {
            payload: &quot;right&quot;,
            left: None,
            right: None
        }
    )
}
</code></pre>
<p>Now, what happens when <code>root</code> is dropped? All fields are dropped; if the 'branches' of
the tree are dropped, they drop <em>their</em> fields and so on. <code>Box::new</code> may be the
closest you will get to a <code>new</code> keyword, but we have no need for <code>delete</code> or <code>free</code>.</p>
<p>We must know work out what use such a tree is. Note that strings can be ordered:
'bar' &lt; 'foo', 'abba' &gt; 'aardvark'; so-called 'alphabetical order'. (Strictly speaking, this
is <em>lexical order</em>, since human languages are very diverse and have strange rules.)</p>
<p>Here is a method which inserts nodes in lexical order of the strings. We compare the new data
to the current node - if it's less, then we try to insert on the left, otherwise try to insert
on the right. There may be no node on the left, so then <code>set_left</code> and so forth.</p>
<pre><pre class="playpen"><code class="language-rust">    fn insert(&amp;mut self, data: &amp;str) {
        if data &lt; &amp;self.payload {
            match self.left {
            Some(ref mut n) =&gt; n.insert(data),
            None =&gt; self.set_left(Self::new(data)),
            }
        } else {
            match self.right {
            Some(ref mut n) =&gt; n.insert(data),
            None =&gt; self.set_right(Self::new(data)),
            }
        }
    }

    ...
    fn main() {
        let mut root = Node::new(&quot;root&quot;);
        root.insert(&quot;one&quot;);
        root.insert(&quot;two&quot;);
        root.insert(&quot;four&quot;);

        println!(&quot;root {:#?}&quot;, root);
    }
</code></pre></pre>
<p>Note the <code>match</code> - we're pulling out a mutable reference to the box, if the <code>Option</code>
is <code>Some</code>, and applying the <code>insert</code> method. Otherwise, we need to create a new <code>Node</code>
for the left side and so forth. <code>Box</code> is a <em>smart</em> pointer; note that no 'unboxing' was
needed to call <code>Node</code> methods on it!</p>
<p>And here's the output tree:</p>
<pre><code>root Node {
    payload: &quot;root&quot;,
    left: Some(
        Node {
            payload: &quot;one&quot;,
            left: Some(
                Node {
                    payload: &quot;four&quot;,
                    left: None,
                    right: None
                }
            ),
            right: None
        }
    ),
    right: Some(
        Node {
            payload: &quot;two&quot;,
            left: None,
            right: None
        }
    )
}
</code></pre>
<p>The strings that are 'less' than other strings get put down the left side, otherwise
the right side.</p>
<p>Time for a visit. This is <em>in-order traversal</em> - we visit the left, do something on
the node, and then visit the right.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn visit(&amp;self) {
        if let Some(ref left) = self.left {
            left.visit();
        }
        println!(&quot;'{}'&quot;, self.payload);
        if let Some(ref right) = self.right {
            right.visit();
        }
    }
    ...
    ...
    root.visit();
    // 'four'
    // 'one'
    // 'root'
    // 'two'

#}</code></pre></pre>
<p>So we're visiting the strings in order! Please note the reappearance of <code>ref</code> - <code>if let</code>
uses exactly the same rules as <code>match</code>.</p>
<a class="header" href="print.html#generic-functions" name="generic-functions"><h2>Generic Functions</h2></a>
<p>The operation of squaring a number is <em>generic</em> in that <code>x*x</code> will work for integers,
floats and generally for anything that knows about the multiplication operator <code>*</code>.</p>
<p>This Just Happens in dynamic languages because the arguments carry their type, and the
runtime will then call the appropriate multiply operator - or fail miserably.
(Which is always the painful thing about dynamic languages.)</p>
<p>The Rust solution is a <em>generic function</em>, which has <em>type parameters</em>.</p>
<pre><pre class="playpen"><code class="language-rust">// gen1.rs

fn sqr&lt;T&gt; (x: T) -&gt; T {
    x * x
}

fn main() {
    let res = sqr(10.0);
    println!(&quot;res {}&quot;,res);
}
</code></pre></pre>
<p>However, Rust is not C++ - it's not going to let you do this without knowing <em>something</em>
about <code>T</code>:</p>
<pre><code>error[E0369]: binary operation `*` cannot be applied to type `T`
 --&gt; gen1.rs:4:5
  |
4 |     x * x
  |     ^
  |
note: an implementation of `std::ops::Mul` might be missing for `T`
 --&gt; gen1.rs:4:5
  |
4 |     x * x
  |     ^
</code></pre>
<p>Following the advice of the compiler, let's <em>constrain</em> that type parameter using
that trait, which is used to implement the multiplication operator <code>*</code>:
(<code>T: Mul</code> means 'any type T that implements Mul')</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
use std::ops::Mul;

fn sqr&lt;T: Mul&gt; (x: T) -&gt; T {
    x * x
}

#}</code></pre></pre>
<p>Which still doesn't work:</p>
<pre><code>rror[E0308]: mismatched types
 --&gt; gen2.rs:6:5
  |
6 |     x * x
  |     ^^^ expected type parameter, found associated type
  |
  = note: expected type `T`
  = note:    found type `&lt;T as std::ops::Mul&gt;::Output`
</code></pre>
<p>What <code>rustc</code> is saying that the type of <code>x*x</code> is the associated type <code>T::Output</code>, not <code>T</code>.
There's actually no reason that the type of <code>x*x</code> is the same as the type of <code>x</code>, e.g. the dot product
of two vectors is a scalar.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn sqr&lt;T: Mul&gt; (x: T) -&gt; T::Output {
    x * x
}

#}</code></pre></pre>
<p>and now the error is:</p>
<pre><code>error[E0382]: use of moved value: `x`
 --&gt; gen2.rs:6:7
  |
6 |     x * x
  |     - ^ value used here after move
  |     |
  |     value moved here
  |
  = note: move occurs because `x` has type `T`, which does not implement the `Copy` trait
</code></pre>
<p>So, we need to constrain the type even further!</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn sqr&lt;T: Mul + Copy&gt; (x: T) -&gt; T::Output {
    x * x
}

#}</code></pre></pre>
<p>And that (finally) works. Calmly listening to the compiler will often get you closer
to the magic point when ... things compile cleanly.</p>
<p>It <em>is</em> a bit simpler in C++:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
T sqr(x: T) {
    return x * x;
}
</code></pre>
<p>but (to be honest) C++ is adopting cowboy tactics here. C++ template errors are famously
bad, because all the compiler knows (ultimately) is that some operator or method is
not defined. The C++ committee knows this is a problem and so they are working
toward <a href="https://en.wikipedia.org/wiki/Concepts_(C%2B%2B)">concepts</a>, which are pretty
much like trait-constrained type parameters in Rust.</p>
<p>Rust generic functions may look a bit overwhelming at first, but being explicit means
you will know exactly what kind of values you can safely feed it, just by looking at the
definition.</p>
<p>These functions are called <em>monomorphic</em>, in constrast to <em>polymorphic</em>. The body of
the function is compiled separately for each unique type.  With polymorphic functions,
the same machine code works with each matching type, dynamically <em>dispatching</em>
the correct method.</p>
<p>Monomorphic produces faster code,
specialized for the particular type, and can often be <em>inlined</em>.  So when <code>sqr(x)</code> is
seen, it's effectively replaced with <code>x*x</code>.  The downside is that large generic
functions produce a lot of code, for each type used, which can result in <em>code bloat</em>.
As always, there are trade-offs; an experienced person learns to make the right choice
for the job.</p>
<a class="header" href="print.html#generic-structs" name="generic-structs"><h2>Generic Structs</h2></a>
<p>Consider the example of a binary tree. It would be <em>seriously irritating</em> to
have to rewrite it for all possible kinds of payload. Before C++ templates, people
would do truly awful things with the C preprocessor to write 'generic' classes.</p>
<p>So here's our generic <code>Node</code> with its <em>type parameter</em> <code>T</code>. It's fairly similar to
a C++ template struct.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
type NodeBox&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

#[derive(Debug)]
struct Node&lt;T&gt; {
    payload: T,
    left: NodeBox&lt;T&gt;,
    right: NodeBox&lt;T&gt;
}

#}</code></pre></pre>
<p>The implementation shows the difference between the languages. The fundamental operation
on the payload is comparison, so T must be comparable with <code>&lt;</code>, i.e. implements <code>PartialOrd</code>.
The type parameter must be declared in the <code>impl</code> block with its constraints:</p>
<pre><pre class="playpen"><code class="language-rust">impl &lt;T: PartialOrd&gt; Node&lt;T&gt; {
    fn new(s: T) -&gt; Node&lt;T&gt; {
        Node{payload: s, left: None, right: None}
    }

    fn boxer(node: Node&lt;T&gt;) -&gt; NodeBox&lt;T&gt; {
        Some(Box::new(node))
    }

    fn set_left(&amp;mut self, node: Node&lt;T&gt;) {
        self.left = Self::boxer(node);
    }

    fn set_right(&amp;mut self, node: Node&lt;T&gt;) {
        self.right = Self::boxer(node);
    }

    fn insert(&amp;mut self, data: T) {
        if data &lt; self.payload {
            match self.left {
            Some(ref mut n) =&gt; n.insert(data),
            None =&gt; self.set_left(Self::new(data)),
            }
        } else {
            match self.right {
            Some(ref mut n) =&gt; n.insert(data),
            None =&gt; self.set_right(Self::new(data)),
            }
        }
    }
}


fn main() {
    let mut root = Node::new(&quot;root&quot;.to_string());
    root.insert(&quot;one&quot;.to_string());
    root.insert(&quot;two&quot;.to_string());
    root.insert(&quot;four&quot;.to_string());

    println!(&quot;root {:#?}&quot;, root);
}
</code></pre></pre>
<p>So generic structs need their type parameter(s) specified
in angle brackets, like C++. Unlike C++, Rust is usually smart enough to work out
that type parameter from context. But you do need to constrain that type appropriately!</p>
<a class="header" href="print.html#filesystem-and-processes" name="filesystem-and-processes"><h1>Filesystem and Processes</h1></a>
<a class="header" href="print.html#another-look-at-reading-files" name="another-look-at-reading-files"><h2>Another look at Reading Files</h2></a>
<p>At the end of Part 1, I showed how to read a whole file into a string. Naturally
this isn't always such a good idea, so here is how to read a file line-by-line.</p>
<p><code>fs::File</code> implements <code>io::Read</code>, which is the trait for anything readable.
This trait defines a <code>read</code> method which will fill a slice of <code>u8</code> with bytes -
this is the only <em>required</em> method of the trait, and you get some <em>provided</em> methods
for free, much like with <code>Iterator</code>.  You can use <code>read_to_end</code> to fill a vector of
bytes with contents from the readable, and <code>read_to_string</code> to fill a string - which
must be UTF-8 encoded.</p>
<p>This is a 'raw' read, with no buffering. For buffered reading there is the
<code>io::BufRead</code> trait which gives us <code>read_line</code> and a <code>lines</code> iterator.
<code>io::BufReader</code> will provide an implementation of <code>io::BufRead</code> for <em>any</em> readable.</p>
<p><code>fs::File</code> <em>also</em> implements <code>io::Write</code>.</p>
<p>The easiest way to make sure all these traits are visible is <code>use std::io::prelude::*</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
use std::fs::File;
use std::io;
use std::io::prelude::*;

fn read_all_lines(filename: &amp;str) -&gt; io::Result&lt;()&gt; {
    let file = File::open(&amp;filename)?;

    let reader = io::BufReader::new(file);

    for line in reader.lines() {
        let line = line?;
        println!(&quot;{}&quot;, line);
    }
    Ok(())
}

#}</code></pre></pre>
<p>The <code>let line = line?</code> may look a bit strange. The <code>line</code> returned by the
iterator is actually an <code>io::Result&lt;String&gt;</code> which we unwrap with <code>?</code>.
Because things <em>can</em> go wrong during this iteration - I/O errors, swallowing
a chunk of bytes that aren't UTF-8, and so forth.</p>
<p><code>lines</code> being an iterator, it is straightforward to read a file into a vector
of strings using <code>collect</code>, or print out the line with line numbers using the
<code>enumerate</code> iterator.</p>
<p>It isn't the most efficient way to read all the lines, however, because a new
string is allocated for each line. It is more efficient to use <code>read_line</code>, although
more awkward. Note that the returned line includes the linefeed, which
can be removed using <code>trim_right</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let mut reader = io::BufReader::new(file);
    let mut buf = String::new();
    while reader.read_line(&amp;mut buf)? &gt; 0 {
        {
            let line = buf.trim_right();
            println!(&quot;{}&quot;, line);
        }
        buf.clear();
    }

#}</code></pre></pre>
<p>This results in far less allocations, because <em>clearing</em> that string does not free its
allocated memory; once the string has enough capacity, no more allocations will take
place.</p>
<p>This is one of those cases where we use a block to control a borrow. <code>line</code> is
borrowed from <code>buf</code>, and this borrow must finish before we modify <code>buf</code>.  Again,
Rust is trying to stop us doing something stupid, which is to access <code>line</code> <em>after</em>
we've cleared the buffer. (The borrow checker can be restrictive sometimes.
Rust is due to get 'non-lexical lifetimes' this year, where
it will analyze the code and see that <code>line</code> isn't used after <code>buf.clear()</code>.)</p>
<p>This isn't very pretty. I cannot give you a proper iterator that returns references
to a buffer, but I can give you something that <em>looks</em> like an iterator.</p>
<p>First define a generic struct;
the type parameter <code>R</code> is 'any type that implements Read'. It contains the reader
and the buffer which we are going to borrow from.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// file5.rs
use std::fs::File;
use std::io;
use std::io::prelude::*;

struct Lines&lt;R&gt; {
    reader: io::BufReader&lt;R&gt;,
    buf: String
}
impl &lt;R: Read&gt; Lines&lt;R&gt; {
    fn new(r: R) -&gt; Lines&lt;R&gt; {
        Lines{reader: io::BufReader::new(r), buf: String::new()}
    }
    ...
}

#}</code></pre></pre>
<p>Then the <code>next</code> method. It returns an <code>Option</code> - just like an iterator, when it
returns <code>None</code> the iterator finishes. The returned type is a <code>Result</code> because
<code>read_line</code> might fail, and we <em>never throw errors away</em>. So if fails, we
wrap up its error in a <code>Some&lt;Result&gt;</code>.  Otherwise, it may have read zero bytes,
which is the natural end of the file - not an error, just a <code>None</code>.</p>
<p>At this point, the buffer contains the line with a linefeed (`\n') appended.
Trim this away, and package up the string slice.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn next&lt;'a&gt;(&amp;'a mut self) -&gt; Option&lt;io::Result&lt;&amp;'a str&gt;&gt;{
        self.buf.clear();
        match self.reader.read_line(&amp;mut self.buf) {
            Ok(nbytes) =&gt; if nbytes == 0 {
                None // no more lines!
            } else {
                let line = self.buf.trim_right();
                Some(Ok(line))
            },
            Err(e) =&gt; Some(Err(e))
        }
    }

#}</code></pre></pre>
<p>Now, note how the lifetimes work. We need an explicit lifetime because Rust will never
allow us to hand out borrowed string slices without knowing their lifetime. And here
we say that the lifetime of this borrowed string is within the lifetime of <code>self</code>.</p>
<p>And this signature, with the lifetime, is incompatible with the interface of <code>Iterator</code>.
But it's easy to see problems if it were compatible; consider <code>collect</code> trying to make
a vector of these string slices. There's no way this could work, since they're all
borrowed from the same mutable string! (If you had read <em>all</em> the file into a string, then
the string's <code>lines</code> iterator works fine because the string slices are all borrowed from
the original string.)</p>
<p>The resulting loop is much cleaner, and the file buffering is invisible to the user.</p>
<pre><code>fn read_all_lines(filename: &amp;str) -&gt; io::Result&lt;()&gt; {
    let file = File::open(&amp;filename)?;

    let mut lines = Lines::new(file);
    while let Some(line) = lines.next() {
        let line = line?;
        println!(&quot;{}&quot;, line)?;
    }

    Ok(())
}
</code></pre>
<p>You can even write the loop like this, since the explicit match can pull out the
string slice:</p>
<pre><code>    while let Some(Ok(line)) = lines.next() {
        println!&quot;{}&quot;, line)?;
    }
</code></pre>
<p>It's tempting, but you are throwing away a possible error here; this loop will
silently stop whenever an error occurs. In particular, it will stop at the first place
where Rust can't convert a line to UTF-8.  Fine for casual code, bad for production code!</p>
<a class="header" href="print.html#writing-to-files" name="writing-to-files"><h2>Writing To Files</h2></a>
<p>We met the <code>write!</code> macro when implementing <code>Display</code> - it also works with anything
that implements <code>Write</code>. So here's a another way of saying <code>print!</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let mut stdout = io::stdout();
    ...
    write!(stdout,&quot;answer is {}\n&quot;, 42).expect(&quot;write failed&quot;);

#}</code></pre></pre>
<p>If an error is <em>possible</em>, you must handle it. It may not be
very <em>likely</em> but it can happen. It's usually fine, because if you
are doing file i/o you should be in a context where <code>?</code> works.</p>
<p><code>print!</code> works fine as it is, but for arbitrary files we need <code>write!</code>. The
file is closed when <code>out</code> is dropped at the end of <code>write_out</code>, which is
convenient and often important.</p>
<pre><pre class="playpen"><code class="language-rust">// file6.rs
use std::fs::File;
use std::io;
use std::io::prelude::*;

fn write_out(f: &amp;str) -&gt; io::Result&lt;()&gt; {
    let mut out = File::create(f)?;
    write!(out,&quot;answer is {}\n&quot;, 42)?;
    Ok(())
}

fn main() {
  write_out(&quot;test.txt&quot;).expect(&quot;write failed&quot;);
}
</code></pre></pre>
<p>Another place we need it is writing to 'standard error'. There is one input stream
<code>io::stdin()</code> and <em>two</em> output streams <code>io::stderr()</code> and <code>io::stdout()</code>. If a program
needs to complain bitterly, the convention is that this output should go to the
error stream. If the program wants then to stop running, the convention is also to
return a non-zero exit code.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn quit(msg: &amp;str) {
    write!(io::stderr(),&quot;error: {}\n&quot;, msg).expect(&quot;write?&quot;);
    std::process::exit(1);
}

#}</code></pre></pre>
<a class="header" href="print.html#files-paths-and-directories" name="files-paths-and-directories"><h2>Files, Paths and Directories</h2></a>
<p>Here is a little program for printing out the Cargo directory on a machine. The
simplest case is that it's '~/.cargo'. This is a Unix shell expansion,
so we use <code>env::home_dir</code> because it's cross-platform. (It might fail, but a
computer without a home directory isn't going to be hosting Rust tools anyway.)</p>
<p>We then create a <code>PathBuf</code>
and use its <code>push</code> method to build up the full file path from its <em>components</em>.
(This is much easier than fooling around with '/','' or whatever, depending on
the system.)</p>
<pre><pre class="playpen"><code class="language-rust">// file7.rs
use std::env;
use std::path::PathBuf;

fn main() {
    let home = env::home_dir().expect(&quot;no home!&quot;);
    let mut path = PathBuf::new();
    path.push(home);
    path.push(&quot;.cargo&quot;);

    if path.is_dir() {
        println!(&quot;{}&quot;, path.display());
    }
}
</code></pre></pre>
<p>A <code>PathBuf</code> is like <code>String</code> - it owns a growable set of characters, but with methods
specialized to building up paths.  Most of its functionality however comes from
the borrowed version <code>Path</code>, which is like <code>&amp;str</code>.  So, for instance, <code>is_dir</code> is
a <code>Path</code> method.</p>
<p>This might sound suspiciously like a form of inheritance, but the magic <a href="https://doc.rust-lang.org/book/deref-coercions.html">Deref</a>
trait works differently. It works just like it does with <code>String/&amp;str</code> -
a reference to <code>PathBuf</code> can be <em>coerced</em> into a reference to <code>Path</code>.
('Coerce' is a strong word, but this really
is one of the few places where Rust does conversions for you.)</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn foo(p: &amp;Path) {...}
...
let path = PathBuf::from(home);
foo(&amp;path);

#}</code></pre></pre>
<p><code>PathBuf</code> has an intimate relationship with <code>OsString</code>, which represents strings we get
directly from the system. (There is a corresponding <code>OsString/&amp;OsStr</code> relationship.)</p>
<p>Such strings are not <em>guaranteed</em> to be representable as UTF-8!
Real life is a <a href="https://news.ycombinator.com/item?id=10519932">complicated matter</a>,
particularly see the answer to 'Why are they so hard?'.  To summarize, first there are
years of ASCII legacy coding, and multiple special encodings for other languages. Second,
human languages are complicated. For instance 'noël' is <em>five</em> Unicode code points!</p>
<p>It's true that <em>most</em> of the time
with modern operating systems file names will be Unicode (UTF-8 on the Unix side, UTF-16
for Windows), except when they're not. And Rust must handle that possibility
rigorously. For instance,
<code>Path</code> has a method <code>as_os_str</code> which returns a <code>&amp;OsStr</code>, but the <code>to_str</code> method
returns an <code>Option&lt;&amp;str&gt;</code>. Not always possible!</p>
<p>People have trouble at this point because they have become too attached to 'string' and
'character' as the only necessary abstractions.  As Einstein could have said, a programming language
has to be as simple as possible, but no simpler. A systems language <em>needs</em> a
<code>String/&amp;str</code> distinction (owned versus borrowed: this is also very <em>convenient</em>)
and if it wishes to standardize on Unicode strings then it needs another type to handle
text which isn't valid Unicode - hence <code>OsString/&amp;OsStr</code>.</p>
<p>People are also very used to processing filenames as if they were text, which is why
Rust makes it easier to manipulate file paths using <code>PathBuf</code> methods.</p>
<p>You can <code>pop</code> to successively remove path components. Here we start with the
current directory of the program:</p>
<pre><code>// file8.rs
use std::env;

fn main() {
    let mut path = env::current_dir().expect(&quot;can't access current dir&quot;);
    loop {
        println!(&quot;{}&quot;, path.display());
        if ! path.pop() {
            break;
        }
    }
}
// /home/steve/rust/gentle-intro/src
// /home/steve/rust/gentle-intro
// /home/steve/rust
// /home/steve
// /home
// /
</code></pre>
<p>Here's a useful variation. I have a program which searches for a configuration file,
and the rule is that it may appear in any subdirectory of the current directory.
So I create <code>/home/steve/rust/config.txt</code> and start this program up in <code>/home/steve/rust/gentle-intro/src</code>:</p>
<pre><pre class="playpen"><code class="language-rust">// file9.rs
use std::env;

fn main() {
    let mut path = env::current_dir().expect(&quot;can't access current dir&quot;);
    loop {
        path.push(&quot;config.txt&quot;);
        if path.is_file() {
            println!(&quot;gotcha {}&quot;, path.display());
            break;
        } else {
            path.pop();
        }
        if ! path.pop() {
            break;
        }
    }
}
// gotcha /home/steve/rust/config.txt
</code></pre></pre>
<p>This is pretty much how <strong>git</strong> works when it wants to know what the current repo is.</p>
<p>The details about a file (its size, type, etc) are called its <em>metadata</em>. As always,
there may be an error - not just 'not found' but also if we don't have permission
to read this file.</p>
<pre><pre class="playpen"><code class="language-rust">// file10.rs
use std::env;
use std::path::Path;

fn main() {
    let file = env::args().skip(1).next().unwrap_or(&quot;file10.rs&quot;.to_string());
    let path = Path::new(&amp;file);
    match path.metadata() {
        Ok(data) =&gt; {
            println!(&quot;type {:?}&quot;, data.file_type());
            println!(&quot;len {}&quot;, data.len());
            println!(&quot;perm {:?}&quot;, data.permissions());
            println!(&quot;modified {:?}&quot;, data.modified());
        },
        Err(e) =&gt; println!(&quot;error {:?}&quot;, e)
    }
}
// type FileType(FileType { mode: 33204 })
// len 488
// perm Permissions(FilePermissions { mode: 436 })
// modified Ok(SystemTime { tv_sec: 1483866529, tv_nsec: 600495644 })
</code></pre></pre>
<p>The length of the file (in bytes) and modified time are straightforward to interpret.
(Note we may not be able to get this time!)  The file type has methods <code>is_dir</code>,
<code>is_file</code> and <code>is_symlink</code>.</p>
<p><code>permissions</code> is an interesting one. Rust strives to be cross-platform, and so it's
a case of the 'lowest common denominator'. In general, all you can query is whether
the file is read-only - the 'permissions' concept is extended in Unix and encodes
read/write/executable for user/group/others.</p>
<p>But, if you are not interested in Windows, then bringing in a platform-specific trait will give
us at least the permission mode bits. (As usual, a trait only kicks in when it is
visible.) Then, applying the program to its own executable gives:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
use std::os::unix::fs::PermissionsExt;
...
println!(&quot;perm {:o}&quot;,data.permissions().mode());
// perm 755

#}</code></pre></pre>
<p>(Note '{:o}' for printing out in <em>octal</em>)</p>
<p>(Whether a file is executable on Windows is determined by its extension. The executable
extensions are found in the <code>PATHEXT</code> environment variable - '.exe','.bat' and so forth).</p>
<p><code>std::fs</code> contains a number of useful functions for working with files, such as copying or
moving files, making symbolic links and creating directories.</p>
<p>To find the contents of a directory, <code>std::fs::read_dir</code> provides an iterator.
Here are all files with extension '.rs' and size greater than 1024 bytes:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn dump_dir(dir: &amp;str) -&gt; io::Result&lt;()&gt; {
    for entry in fs::read_dir(dir)? {
        let entry = entry?;
        let data = entry.metadata()?;
        let path = entry.path();
        if data.is_file() {
            if let Some(ex) = path.extension() {
                if ex == &quot;rs&quot; &amp;&amp; data.len() &gt; 1024 {
                    println!(&quot;{} length {}&quot;, path.display(),data.len());
                }
            }
        }
    }
    Ok(())
}
// ./enum4.rs length 2401
// ./struct7.rs length 1151
// ./sexpr.rs length 7483
// ./struct6.rs length 1359
// ./new-sexpr.rs length 7719

#}</code></pre></pre>
<p>Obviously <code>read_dir</code> might fail (usually 'not found' or 'no permission'), but
also getting each new entry might fail (it's like the <code>lines</code> iterator over a buffered
reader's contents).  Plus, we might not be able to get the metadata corresponding to
the entry.  A file might have no extension, so we have to check for that as well.</p>
<p>Why not just an iterator over paths? On Unix this is the way the <code>opendir</code> system call works,
but on Windows you cannot iterate over a directory's contents without getting the
metadata. So this is a reasonably elegant compromise that allows cross-platform
code to be as efficient as possible.</p>
<p>You can be forgiven for feeling 'error fatigue' at this point. But please note that
the <em>errors always existed</em> - it's not that Rust is inventing new ones. It's just
trying its darnedest to make it hard for you to ignore them.  Any call to an
operating system may fail, but C makes getting errors awkward. You check the return
code, and if it's not zero you then have to inspect <code>errno</code>
to find out what the actual error was.
Quite apart from memory safety, this makes robust C programming harder than most
C programmers think!</p>
<p>Languages like Java and Python throw exceptions; languages like Go and Lua return two
values, where the first is the result and the second is the error: like Rust it is
considered bad manners for library functions to raise errors. So there is a lot
of error checking and early-returns from functions.</p>
<p>Rust uses <code>Result</code> because it's either-or: you cannot get a result <em>and</em> an error.
And the question-mark operator makes handling errors much cleaner.</p>
<a class="header" href="print.html#processes" name="processes"><h2>Processes</h2></a>
<p>A fundamental need is for programs to run programs, or to <em>launch processes</em>.
Your program can <em>spawn</em> as many child processes it likes, and as the name
suggests they have a special relationship with their parent.</p>
<p>To run a program is straightforward using the <code>Command</code> struct, which <em>builds</em> up
arguments to pass to the program:</p>
<pre><pre class="playpen"><code class="language-rust">use std::process::Command;

fn main() {
    let status = Command::new(&quot;rustc&quot;)
        .arg(&quot;-V&quot;)
        .status()
        .expect(&quot;no rustc?&quot;);

    println!(&quot;cool {} code {}&quot;, status.success(), status.code().unwrap());
}
// rustc 1.15.0-nightly (8f02c429a 2016-12-15)
// cool true code 0
</code></pre></pre>
<p>So <code>new</code> receives the name of the program (it will be looked up on <code>PATH</code> if not
an absolute filename), <code>arg</code> adds a new argument, and <code>status</code> causes it to be run.
This returns a <code>Result</code>, which is <code>Ok</code> if the program actually run, containing an
<code>ExitStatus</code>. In this case, the program succeeded, and returned an exit code 0. (The
<code>unwrap</code> is because we can't always get the code if the program was killed by
a signal).</p>
<p>If we change the <code>-V</code> to <code>-v</code> (an easy mistake) then <code>rustc</code> fails:</p>
<pre><code>error: no input filename given

cool false code 101
</code></pre>
<p>So there are three possibilities:</p>
<ul>
<li>program didn't exist, was bad, or we were not allowed to run it</li>
<li>program ran, but was not successful - non-zero exit code</li>
<li>program ran, with zero exit code. Success!</li>
</ul>
<p>By default, we get the program's output, since its standard output and standard error is
still going to the terminal.</p>
<p>Often we are very interested in capturing that output, so there's the <code>output</code>
method.</p>
<pre><pre class="playpen"><code class="language-rust">// process2.rs
use std::process::Command;

fn main() {
    let output = Command::new(&quot;rustc&quot;)
        .arg(&quot;-V&quot;)
        .output()
        .expect(&quot;no rustc?&quot;);

    if output.status.success() {
        println!(&quot;ok!&quot;);
    }
    println!(&quot;len stdout {} stderr {}&quot;, output.stdout.len(), output.stderr.len());
}
// ok!
// len stdout 44 stderr 0
</code></pre></pre>
<p>As with <code>status</code> our program blocks until the child process is finished, and we get
back three things - the status (as before), the contents of stdout and the contents
of stderr.</p>
<p>The captured output is simply <code>Vec&lt;u8&gt;</code> - just bytes.  Recall we have no guarantee
that data we receive from the operating system is a properly encoded UTF-8 string. In
fact, we have no guarantee that it <em>even</em> is a string - programs may return arbitrary
binary data.</p>
<p>If we are pretty sure the output is UTF-8, then <code>String::from_utf8</code> will convert those
vectors or bytes - it returns a <code>Result</code> because this conversion may not succeed.
A more sloppy function is <code>String::from_utf8_lossy</code> which will make a good attempt at
conversion and insert the invalid Unicode mark � where it failed.</p>
<p>Here is a useful function which runs a program using the shell. This uses the usual
shell mechanism for joining stderr to stdout:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn shell(cmd: &amp;str) -&gt; (String,bool) {
    let cmd = format!(&quot;{} 2&gt;&amp;1&quot;,cmd);
    let output = Command::new(&quot;/bin/sh&quot;)
        .arg(&quot;-c&quot;)
        .arg(&amp;cmd)
        .output()
        .expect(&quot;no shell?&quot;);
    (
        String::from_utf8_lossy(&amp;output.stdout).trim_right().to_string(),
        output.status.success()
    )
}

fn shell_success(cmd: &amp;str) -&gt; Option&lt;String&gt; {
    let (output,success) = shell(cmd);
    if success {Some(output)} else {None}
}

#}</code></pre></pre>
<p>I'm trimming any whitespace from the right so that if you said <code>shell(&quot;which rustc&quot;)</code>
you will get the path without any extra linefeed.</p>
<p>You can control the execution of a program by specifying the directory it will run
in using the <code>current_dir</code> method and the environment variables it sees using <code>env</code>.</p>
<p>Up to now, our program simply waits for the child process to finish. If you use
the <code>spawn</code> method then we return immediately, and must explicitly wait for it to
finish - or go off and do something else in the meantime!  This example also
shows how to suppress both standard out and standard error:</p>
<pre><pre class="playpen"><code class="language-rust">// process5.rs
use std::process::{Command,Stdio};

fn main() {
    let mut child = Command::new(&quot;rustc&quot;)
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .spawn()
        .expect(&quot;no rustc?&quot;);

    let res = child.wait();
    println!(&quot;res {:?}&quot;, res);
}
</code></pre></pre>
<p>By default, the child 'inherits' the standard input and output of the parent. In this case,
we redirect the child's output handles into 'nowhere'. It's equivalent to saying
<code>&gt; /dev/null 2&gt; /dev/null</code> in the Unix shell.</p>
<p>Now, it's possible to do these things using the shell in Rust, although not in a portable way.
But this way you get full programmatic control of process creation.</p>
<p>For example, if we just had <code>.stdout(Stdio::piped())</code> then the child's standard output
is redirected to a pipe. If we then use <code>wait_with_output</code> instead of <code>wait</code> then
it returns a <code>Result&lt;Output&gt;</code> and the child's output is captured into the <code>stdout</code>
field of that <code>Output</code> just as before. Alternatively, the <em>child</em>'s <code>stdout</code> field is readable and
you can manually read the child's output in the usual way.</p>
<p>The <code>Child</code> struct also gives you an explicit <code>kill</code> method.</p>
<a class="header" href="print.html#modules-and-cargo" name="modules-and-cargo"><h1>Modules and Cargo</h1></a>
<a class="header" href="print.html#modules" name="modules"><h2>Modules</h2></a>
<p>As programs get larger, it's necessary to spread them over more than one file
and put functions and types in different <em>namespaces</em>.
The Rust solution for both of these is <em>modules</em>.</p>
<p>C does the first, and not
the second, so you end up with awful names like <code>primitive_display_set_width</code> and
so forth. In Rust the full name would look like <code>primitive::display::set_width</code>,
and after saying <code>use primitive::display</code> you can then refer to it as <code>display::set_width</code>.
You can even say <code>use primitive::display::set_width</code> and then just say <code>set_width</code>, but
it's not a good idea to get carried away with this. <code>rustc</code> will not be confused, but <em>you</em>
may get confused later.</p>
<p>A new keyword <code>mod</code> is used to define a module as a block
where Rust types or functions can be written:</p>
<pre><pre class="playpen"><code class="language-rust">mod foo {
    #[derive(Debug)]
    struct Foo {
        s: &amp;'static str
    }
}

fn main() {
    let f = foo::Foo{s: &quot;hello&quot;};
    println!(&quot;{:?}&quot;, f);
}
</code></pre></pre>
<p>But it's still not quite right - we get 'struct Foo is private'. To solve this, we need the <code>pub</code> keyword
to export <code>Foo</code>. The error then changes to 'field s of struct foo::Foo is private', so put <code>pub</code>
before the field <code>s</code> to export <code>Foo::s</code>. Then things will work.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    pub struct Foo {
        pub s: &amp;'static str
    }

#}</code></pre></pre>
<p>Needing an explicit <code>pub</code> means that you must <em>choose</em> what items to make public from a module.
The set of functions and types exported from a module is called its <em>interface</em>.</p>
<p>It is usually better to hide the insides of a struct, and only allow access through methods:</p>
<pre><pre class="playpen"><code class="language-rust">mod foo {
    #[derive(Debug)]
    pub struct Foo {
        s: &amp;'static str
    }

    impl Foo {
        pub fn new(s: &amp;'static str) -&gt; Foo {
            Foo{s: s}
        }
    }
}

fn main() {
    let f = foo::Foo::new(&quot;hello&quot;);
    println!(&quot;{:?}&quot;, f);
}
</code></pre></pre>
<p>Why is hiding the implementation a good thing?  Because it means you may change it later
without breaking the interface, without consumers of a module getting too dependent on its details.
The great enemy of large-scale programing is a tendency for code to get entangled, so that understanding
a piece of code is impossible in isolation.</p>
<p>In a perfect world a module does one thing, does it well, and keeps its own secrets.</p>
<p>When not to hide? As Stroustrup says, when the interface <em>is</em> the implementation, like
<code>struct Point{x: f32, y: f32}</code>.</p>
<p><em>Within</em> a module, all items are visible to all other items. It's a cozy place where
everyone can be friends and know intimate details about each other.</p>
<p>Everyone gets to a point where they want to break a program up into separate files,
depending on taste. I start getting uncomfortable around 500 lines, but we all agree
that more than 2000 lines is pushing it.</p>
<p>So how to break this program into separate files?</p>
<p>We put the <code>foo</code> code into <code>foo.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// foo.rs
#[derive(Debug)]
pub struct Foo {
    s: &amp;'static str
}

impl Foo {
    pub fn new(s: &amp;'static str) -&gt; Foo {
        Foo{s: s}
    }
}

#}</code></pre></pre>
<p>And use a <code>mod foo</code> statement <em>without</em> a block in the main program:</p>
<pre><pre class="playpen"><code class="language-rust">// mod3.rs
mod foo;

fn main() {
    let f = foo::Foo::new(&quot;hello&quot;);
    println!(&quot;{:?}&quot;, f);
}
</code></pre></pre>
<p>Now <code>rustc mod3.rs</code> will cause <code>foo.rs</code> to be compiled as well. There is no need to fool around
with makefiles!</p>
<p>The compiler will also look at <code>MODNAME/mod.rs</code>, so this will work
if I create a directory <code>boo</code> containing a file <code>mod.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// boo/mod.rs
pub fn answer()-&gt;u32 {
    42
}

#}</code></pre></pre>
<p>And now the main program can use both modules as separate files:</p>
<pre><code>// mod3.rs
mod foo;
mod boo;

fn main() {
    let f = foo::Foo::new(&quot;hello&quot;);
    let res = boo::answer();
    println!(&quot;{:?} {}&quot;, f,res);
}
</code></pre>
<p>So far, there's <code>mod3.rs</code>, containing <code>main</code>, a module <code>foo.rs</code> and a directory <code>boo</code> containing
<code>mod.rs</code>.  The usual convention is that the file containing <code>main</code> is just called <code>main.rs</code>.</p>
<p>Why two ways to do the same thing? Because <code>boo/mod.rs</code> can refer to other modules defined in <code>boo</code>,
Update <code>boo/mod.rs</code> and add a new module - note that this is explicitly exported.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
pub fn answer()-&gt;u32 {
    42
}

pub mod bar {
    pub fn question() -&gt; &amp;'static str {
        &quot;the meaning of everything&quot;
    }
}

#}</code></pre></pre>
<p>and then we have the question corresponding to the answer:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let q = boo::bar::question();

#}</code></pre></pre>
<p>That module block can be pulled out as <code>boo/bar.rs</code> and so on.</p>
<p>In summary, modules are about organization and visibility,
and this may or may not involve separate files.</p>
<p>Please note that <code>use</code> has nothing to do with importing, and simply specifies visibility
of module names. For example:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
{
    use boo::bar;
    let q = bar::question();
    ...
}
{
    use boo::bar::question();
    let q = question();
    ...
}


#}</code></pre></pre>
<p>An important point to note is there is no <em>separate compilation</em> here. The main program and its
module files will be recompiled each time. Larger programs will take a fair amount of time to build,
although <code>rustc</code> is getting better at incremental compilation.</p>
<a class="header" href="print.html#crates" name="crates"><h2>Crates</h2></a>
<p>The 'compilation unit' for Rust is the <em>crate</em>, which is either an executable or a library.</p>
<p>To separately compile the files from the last section,
first build <code>foo.rs</code> as a Rust <em>static library</em> crate:</p>
<pre><code>src$ rustc foo.rs --crate-type=lib
src$ ls -l libfoo.rlib
-rw-rw-r-- 1 steve steve 7888 Jan  5 13:35 libfoo.rlib
</code></pre>
<p>We can now <em>link</em> this into our main program:</p>
<pre><code>src$ rustc mod4.rs --extern foo=libfoo.rlib
</code></pre>
<p>But the main program must now look like this, where the <code>extern</code> name is the same
as the one used when linking. There is an implicit top-level module <code>foo</code> associated
with the library crate:</p>
<pre><code>// mod4.rs
extern crate foo;

fn main() {
    let f = foo::Foo::new(&quot;hello&quot;);
    println!(&quot;{:?}&quot;, f);
}
</code></pre>
<p>Before people start chanting 'Cargo! Cargo!' let me justify this lower-level look at building Rust.
I'm a great believer in 'Know Thy Toolchain', and this will reduce the amount of new magic you need
to learn when we look at managing projects with Cargo. Modules are basic language features and can be
used outside Cargo projects.</p>
<p>It's time to understand why Rust binaries are so large:</p>
<pre><code>src$ ls -lh mod4
-rwxrwxr-x 1 steve steve 3,4M Jan  5 13:39 mod4
</code></pre>
<p>That's rather fat! There is a <em>lot</em> of debug information in that executable. This is not a Bad Thing,
if you want to use a debugger and actually want meaningful backtraces when your program panics.</p>
<p>So let's strip that debug information and see:</p>
<pre><code>src$ strip mod4
src$ ls -lh mod4
-rwxrwxr-x 1 steve steve 300K Jan  5 13:49 mod4
</code></pre>
<p>Still feels a little large for something so simple, but this program links <em>statically</em> against
the Rust standard library. This is a Good Thing, since you can hand this executable to anyone
with the right operating system - they will not need a 'Rust install<code>. (And</code>rustup` will even let
you cross-compile for other operating systems and platforms as well.)</p>
<p>We can link dynamically against the Rust runtime and get truly tiny exes:</p>
<pre><code>src$ rustc -C prefer-dynamic mod4.rs --extern foo=libfoo.rlib
src$ ls -lh mod4
-rwxrwxr-x 1 steve steve 14K Jan  5 13:53 mod4
src$ ldd mod4
    linux-vdso.so.1 =&gt;  (0x00007fffa8746000)
    libstd-b4054fae3db32020.so =&gt; not found
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f3cd47aa000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f3cd4d72000)
</code></pre>
<p>That 'not found' is because <code>rustup</code> doesn't install the dynamic libraries globally. We
can hack our way to happiness, at least on Unix (yes, I know the best solution is a symlink.)</p>
<pre><code>src$ export LD_LIBRARY_PATH=~/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib
src$ ./mod4
Foo { s: &quot;hello&quot; }
</code></pre>
<p>Rust does not have a <em>philosophical</em> problem with dynamic linking, in the same way as Go does. It's
just that when there's a stable release every 6 weeks it becomes inconvenient to have to recompile
everything. If you have a stable version that Works For You, then cool. As stable versions of Rust
get increasingly delivered by the OS package manager, dynamic linking will become more popular.</p>
<a class="header" href="print.html#cargo" name="cargo"><h2>Cargo</h2></a>
<p>The Rust standard library is not very large, compared to Java or Python; although much more fully
featured than C or C++, which lean heavily on operating system provided libraries.</p>
<p>But it is straightforward to access community-provided libraries in <a href="https://crates.io">crates.io</a>
using <strong>Cargo</strong>.  Cargo will look up the correct version and download the source for you, and
ensures that any other needed crates are downloaded as well.</p>
<p>Let's create a simple program which needs to read JSON. This data format is very widely used,
but is too specialized for inclusion in the standard library. So we initialize a Cargo project,
using '--bin' because the default is to create a library project.</p>
<pre><code>test$ cargo init --bin test-json
     Created binary (application) project
test$ cd test-json
test$ cat Cargo.toml
[package]
name = &quot;test-json&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.org&gt;&quot;]

[dependencies]
</code></pre>
<p>To make the project depend on the <a href="http://json.rs/doc/json/">JSON crate</a>, edit the
'Cargo.toml' file so:</p>
<pre><code>[dependencies]
json=&quot;*&quot;
</code></pre>
<p>Then do a first build with Cargo:</p>
<pre><code>test-json$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading json v0.11.4
   Compiling json v0.11.4
   Compiling test-json v0.1.0 (file:///home/steve/c/rust/test/test-json)
    Finished debug [unoptimized + debuginfo] target(s) in 1.75 secs
</code></pre>
<p>The main file of this project has already been created - it's 'main.rs' in the 'src'
directory. It starts out just as a 'hello world' app, so let's edit it to be a proper test program.</p>
<p>Mote the very convenient 'raw' string literal - otherwise we would need to escape those double quotes
and end up with ugliness:</p>
<pre><pre class="playpen"><code class="language-rust">// test-json/src/main.rs
extern crate json;

fn main() {
    let doc = json::parse(r#&quot;
    {
        &quot;code&quot;: 200,
        &quot;success&quot;: true,
        &quot;payload&quot;: {
            &quot;features&quot;: [
                &quot;awesome&quot;,
                &quot;easyAPI&quot;,
                &quot;lowLearningCurve&quot;
            ]
        }
    }
    &quot;#).expect(&quot;parse failed&quot;);

    println!(&quot;debug {:?}&quot;, doc);
    println!(&quot;display {}&quot;, doc);
}
</code></pre></pre>
<p>You can now build and run this project - only <code>main.rs</code> has changed.</p>
<pre><code>test-json$ cargo run
   Compiling test-json v0.1.0 (file:///home/steve/c/rust/test/test-json)
    Finished debug [unoptimized + debuginfo] target(s) in 0.21 secs
     Running `target/debug/test-json`
debug Object(Object { store: [(&quot;code&quot;, Number(Number { category: 1, exponent: 0, mantissa: 200 }),
 0, 1), (&quot;success&quot;, Boolean(true), 0, 2), (&quot;payload&quot;, Object(Object { store: [(&quot;features&quot;,
 Array([Short(&quot;awesome&quot;), Short(&quot;easyAPI&quot;), Short(&quot;lowLearningCurve&quot;)]), 0, 0)] }), 0, 0)] })
display {&quot;code&quot;:200,&quot;success&quot;:true,&quot;payload&quot;:{&quot;features&quot;:[&quot;awesome&quot;,&quot;easyAPI&quot;,&quot;lowLearningCurve&quot;]}}
</code></pre>
<p>The debug output shows some internal details of the JSON document, but a
plain '{}', using the <code>Display</code> trait, regenerates JSON from the parsed document.</p>
<p>Let's explore the JSON API.
It would not be useful if we could not extract values. The <code>as_TYPE</code> methods
return <code>Option&lt;TYPE&gt;</code> since we cannot be sure that the field exists or is of the correct type.
(see the <a href="http://json.rs/doc/json/enum.JsonValue.html">docs for JsonValue</a>)</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let code = doc[&quot;code&quot;].as_u32().unwrap_or(0);
    let success = doc[&quot;success&quot;].as_bool().unwrap_or(false);

    assert_eq!(code, 200);
    assert_eq!(success, true);

    let features = &amp;doc[&quot;payload&quot;][&quot;features&quot;];
    for v in features.members() {
        println!(&quot;{}&quot;, v.as_str().unwrap()); // MIGHT explode
    }
    // awesome
    // easyAPI
    // lowLearningCurve

#}</code></pre></pre>
<p><code>features</code> here is a reference to <code>JsonValue</code> - it has to be a reference because otherwise
we would be trying to move a <em>value</em> out of the JSON document.  Here we know it's an array,
so <code>members()</code> will return a non-empty iterator over <code>&amp;JsonValue</code>.</p>
<p>What if the 'payload' object didn't have a 'features' key? Then <code>features</code> would be set to <code>Null</code>.
There will be no explosion. This convenience expresses the free-form, anything-goes nature of JSON
very well. It is up to you to examine the structure of any document you receive and create your own
errors if the structure does not match.</p>
<p>You can modify these structures. If we had <code>let mut doc</code> then this would do what you expect:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let features = &amp;mut doc[&quot;payload&quot;][&quot;features&quot;];
    features.push(&quot;cargo!&quot;).expect(&quot;couldn't push&quot;);

#}</code></pre></pre>
<p>The <code>push</code> will fail if <code>features</code> wasn't an array, hence it returns <code>Result&lt;()&gt;</code>.</p>
<p>Here's a truly beautiful use of macros to generate <em>JSON literals</em>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let data = object!{
        &quot;name&quot;    =&gt; &quot;John Doe&quot;,
        &quot;age&quot;     =&gt; 30,
        &quot;numbers&quot; =&gt; array![10,53,553]
    };
    assert_eq!(
        data.dump(),
        r#&quot;{&quot;name&quot;:&quot;John Doe&quot;,&quot;age&quot;:30,&quot;numbers&quot;:[10,53,553]}&quot;#
    );

#}</code></pre></pre>
<p>For this to work, you need to explicitly import macros from the JSON crate thus:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
#[macro_use]
extern crate json;

#}</code></pre></pre>
<p>There is a downside to using this crate, because of the mismatch between the amorphous, dynamically-typed
nature of JSON and the structured, static nature of Rust. (The readme explicitly speaks of 'friction')
So if you <em>did</em> want to map JSON to Rust data structures, you would end up doing a lot of checking,
because you can not assume that the received structure matches your structs! For that, a better
solution is <a href="https://github.com/serde-rs/json">serde-json</a> where you <em>serialize</em> Rust data structures
into JSON and <em>deserialize</em> JSON into Rust.</p>
<p>For this, create a another Cargo binary project with <code>cargo new --bin test-serde-json</code>, go into
the <code>test-serde-json</code> directory and edit <code>Cargo.toml</code>. Edit it like so:</p>
<pre><code>[dependencies]
serde=&quot;0.9&quot;
serde_derive=&quot;0.9&quot;
serde_json=&quot;0.9&quot;
</code></pre>
<p>And edit <code>src/main.rs</code> to be this:</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate serde_derive;
extern crate serde_json;

#[derive(Serialize, Deserialize, Debug)]
struct Person {
    name: String,
    age: u8,
    address: Address,
    phones: Vec&lt;String&gt;,
}

#[derive(Serialize, Deserialize, Debug)]
struct Address {
    street: String,
    city: String,
}

fn main() {
    let data = r#&quot; {
     &quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 43,
     &quot;address&quot;: {&quot;street&quot;: &quot;main&quot;, &quot;city&quot;:&quot;Downtown&quot;},
     &quot;phones&quot;:[&quot;27726550023&quot;]
    } &quot;#;
    let p: Person = serde_json::from_str(data).expect(&quot;deserialize error&quot;);
    println!(&quot;Please call {} at the number {}&quot;, p.name, p.phones[0]);

    println!(&quot;{:#?}&quot;,p);
}
</code></pre></pre>
<p>You have seen the <code>derive</code> attribute before, but the <code>serde_derive</code> crate defines <em>custom derives</em>
for the special <code>Serialize</code> and <code>Deserialize</code> traits. And the result shows the generated Rust struct:</p>
<pre><code>Please call John Doe at the number 27726550023
Person {
    name: &quot;John Doe&quot;,
    age: 43,
    address: Address {
        street: &quot;main&quot;,
        city: &quot;Downtown&quot;
    },
    phones: [
        &quot;27726550023&quot;
    ]
}
</code></pre>
<p>Now, if you did this using the <code>json</code> crate, you would need a few hundred lines of custom conversion
code, mostly error handling. Tedious, easy to mess up, and not where you want to put effort anyway.</p>
<p>This is clearly the best solution if you are processing well-structured JSON from outside sources (it's
possible to remap field names if needed) and provides a robust way for Rust programs to share data
with other programs over the network (since everything understands JSON these days.)</p>
<p>Serialization is an important technique and similar solutions exist for Java and Go - but with a big
difference. In those languages the structure of the data is found at <em>run-time</em> using <em>reflection</em>, but
in this case the serialization code is generated at <em>compile-time</em> - altogether more efficient!</p>
<p>Cargo is considered to be one of the great strengths of the Rust ecosystem, because it does
a lot of work for us. Otherwise we would have had to download these libraries from Github,
build as static library crates, and link them against the program. It's painful to do this for
C++ projects, and would be nearly as painful for Rust projects if Cargo did not exist.
C++ is somewhat unique in its painfullness here, so we should compare this with
other languages' package managers. npm (for JavaScript) and pip (for Python) manage dependencies
and downloads for you, but the distribution story is harder, since the user of your program
needs NodeJS or Python installed.
But these programs are statically linked against their dependencies, so again it can be handed
out to your buddies without external dependencies.</p>
<a class="header" href="print.html#more-gems" name="more-gems"><h2>More Gems</h2></a>
<p>When processing anything except simple text, regular expressions make your life much easier.
These are commonly available for most languages and I'll here assume a basic familiarity with
regex notation.  To use the <a href="https://github.com/rust-lang/regex">regex</a> crate, put 'regex = &quot;*&quot;'
after &quot;[dependencies]&quot; in your Cargo.toml.</p>
<p>We'll use 'raw strings' again so that the backslashes don't have to be escaped. In English, this
regular expression is &quot;match exactly two digits, the character ':', and then any number of digits.
Capture both sets of digits&quot;:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
extern crate regex;
use regex::Regex;

let re = Regex::new(r&quot;(\d{2}):(\d+)&quot;).unwrap();
println!(&quot;{:?}&quot;, re.captures(&quot;  10:230&quot;));
println!(&quot;{:?}&quot;, re.captures(&quot;[22:2]&quot;));
println!(&quot;{:?}&quot;, re.captures(&quot;10:x23&quot;));
// Some(Captures({0: Some(&quot;10:230&quot;), 1: Some(&quot;10&quot;), 2: Some(&quot;230&quot;)}))
// Some(Captures({0: Some(&quot;22:2&quot;), 1: Some(&quot;22&quot;), 2: Some(&quot;2&quot;)}))
// None

#}</code></pre></pre>
<p>The successful output actually has three <em>captures</em> - the whole match, and the two sets of digits.
These regular expressions are not <em>anchored</em> by default, so <strong>regex</strong> will hunt for the first
occurring match, skipping anything that doesn't match.  (If you left out the '()' it would just
give us the whole match.)</p>
<p>It's possible to <em>name</em> those captures, and spread the regular expression over several lines,
even including comments!  Compiling the regex might fail (the first <em>expect</em>) or the match
might fail (the second <em>expect</em>). Here we can use the result as an associative array and look
up captures by name.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let re = Regex::new(r&quot;(?x)
(?P&lt;year&gt;\d{4})  # the year
-
(?P&lt;month&gt;\d{2}) # the month
-
(?P&lt;day&gt;\d{2})   # the day
&quot;).expect(&quot;bad regex&quot;);
let caps = re.captures(&quot;2010-03-14&quot;).expect(&quot;match failed&quot;);

assert_eq!(&quot;2010&quot;, &amp;caps[&quot;year&quot;]);
assert_eq!(&quot;03&quot;, &amp;caps[&quot;month&quot;]);
assert_eq!(&quot;14&quot;, &amp;caps[&quot;day&quot;]);

#}</code></pre></pre>
<p>Regular expressions can break up strings that match a pattern, but won't check whether they make sense.
That is, you can specify and match the <em>syntax</em> of ISO-style dates, but <em>semantically</em> they may be nonsense,
like &quot;2014-24-52&quot;.</p>
<p>For this, you need dedicated date-time processing, which is provided by <a href="https://github.com/lifthrasiir/rust-chrono">chrono</a>.
You need to decide on a time zone when doing dates:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate chrono;
use chrono::*;

fn main() {
    let date = Local.ymd(2010,3,14);
    println!(&quot;date was {}&quot;, date);
}
// date was 2010-03-14+02:00
</code></pre></pre>
<p>However, this isn't recommended because feeding it bad dates will cause a panic! (try the bogus date
to see this.) The method you need here is <code>ymd_opt</code> which returns <code>LocalResult&lt;Date&gt;</code></p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let date = Local.ymd_opt(2010,3,14);
    println!(&quot;date was {:?}&quot;, date);
    // date was Single(2010-03-14+02:00)

    let date = Local.ymd_opt(2014,24,52);
    println!(&quot;date was {:?}&quot;, date);
    // date was None

#}</code></pre></pre>
<p>You can also directly parse date-times, either in standard UTC format or using custom <a href="https://lifthrasiir.github.io/rust-chrono/chrono/format/strftime/index.html#specifiers">formats</a>.
These self-same formats allow you to print out dates in exactly the format you want.</p>
<p>I specifically highlighted these two useful crates because they would be part of the standard
library in most other languages. And, in fact, the embryonic form of these crates was
once part of the Rust stdlib, but were cut loose. This was a deliberate decision: the Rust team takes
stdlib stability very seriously so features only arrive in stable once they have gone through
incubation in unstable nightly versions, and only then beta and stable.  For libraries that need
experimentation and refinement, it's much better that they remain independent and get tracked
with Cargo. For all practical purposes, these two crates <em>are</em> standard - they are not going away and
may be folded back into the stdlib at some point.</p>
<a class="header" href="print.html#standard-library-containers" name="standard-library-containers"><h1>Standard Library Containers</h1></a>
<a class="header" href="print.html#reading-the-documentation" name="reading-the-documentation"><h2>Reading the Documentation</h2></a>
<p>In this section I'll briefly introduce some very useful parts of the Rust standard
library. The documentation (as always) is excellent but a little context and a few examples is
always useful.</p>
<p>Initially, reading the Rust documentation can be challenging. I'll take the <code>Vec</code> struct as an
example.  A useful tip is to tick the '[-]' box to collapse the docs. (If you download the
standard library source using <code>rustup component add rust-src</code> a '[src]' link will appear next to this.)
This gives you a bird's eye view of all the available methods.</p>
<p>The first point to notice is that <em>not all possible methods</em> are defined on <code>Vec</code> itself. They are (mostly)
mutable methods that change the vector, e.g. <code>push</code>. Some methods are only implemented for vectors where
the type matches some constraint. For example, you can only call <code>dedup</code> (remove duplicates) if the
type is indeed something that can be compared for equality.  There are multiple <code>impl</code> blocks that
define <code>Vec</code> for different type constraints.</p>
<p>Then there's the very special relationship between <code>Vec&lt;T&gt;</code> and <code>&amp;[T]</code>.  Any method that works on
slices will also directly work on vectors, without explicitly having to use the <code>as_slice</code> method.
This relationship is expressed by <code>Deref&lt;Target=[T]&gt;</code>. This also kicks in when you pass a vector by
mutable reference to something that expects a slice - this is one of the few places where
a conversion between types happens automatically. So slice methods like <code>first</code>, which maybe-returns
a reference to the first element, or <code>last</code>, work for vectors as well. Many of the methods are similar
to the corresponding string methods, so there's <code>split_at</code> for getting a pair of slices spit at an index,
<code>starts_with</code> to check whether a vector starts with sequence of values, and <code>contains</code> to check whether
a vector contains a particular value.</p>
<p>There's no <code>search</code> method for finding the index of a particular value, but here's a rule of thumb:
if you can't find a method on the container, look for a method on the iterator:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let v = vec![10,20,30,40,50];
    assert_eq!(v.iter().position(|&amp;i| i == 30).unwrap(), 2);

#}</code></pre></pre>
<p>(The <code>&amp;</code> is because this is an iterator over <em>references</em> - alternatively you could say <code>*i == 30</code> for
the comparison.)</p>
<p>Likewise, there's no <code>map</code> method on vectors, because <code>iter().map(...).collect()</code> will do the job
just as well. Rust does not like to allocate unnecessarily - often you don't need the result of that <code>map</code>
as an actual allocated vector.</p>
<p>In other languages, things like <code>map</code> are functions. For instance, in C++ <code>std::count</code> is a function that
takes two C++ iterators to establish a range, but it's an iterator method in Rust.</p>
<p>So I'd suggest you become familiar with all the iterator methods, because they are crucial to writing
good Rust code without having to write loops all the time. As always, write little programs to explore
iterator methods, rather than wrestling with them in the context of a more complicated program.</p>
<p>The <code>Vec&lt;T&gt;</code> and <code>&amp;[T]</code> methods are followed by the common traits: vectors know how to do a debug display of themselves
(but only if the elements implement <code>Debug</code>). Likewise, they are clonable if their elements are clonable.
They implement <code>Drop</code>, which happens when vectors get to finally die; memory is released,
and all the elements are dropped as well.</p>
<p>The <code>Extend</code> trait means values from iterators can be added to a vector without a loop:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
v.extend([60,70,80].iter());
let mut strings = vec![&quot;hello&quot;.to_string(), &quot;dolly&quot;.to_string()];
strings.extend([&quot;you&quot;,&quot;are&quot;,&quot;fine&quot;].iter().map(|s| s.to_string()));

#}</code></pre></pre>
<p>There's also <code>FromIterator</code>, which lets vectors be <em>constructed</em> from iterators. (The iterator <code>collect</code>
method leans on this.)</p>
<p>Any container needs to be iterable as well. Recall that there are three kinds of iterators:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
for x in v {...} // returns T, consumes v
for x in &amp;v {...} // returns &amp;T
for x in &amp;mut v {...} // returns &amp;mut T

#}</code></pre></pre>
<p>The <code>for</code> statement relies on the <code>IntoIterator</code> trait, and there's indeed three implementations.</p>
<p>Then there is indexing, controlled by <code>Index</code> (reading from a vector) and <code>IndexMut</code> (modifying a
vector.)  There are many possibilities, because there's slice indexing as well, like <code>v[0..2]</code>,
returning these return slices, as well as plain <code>v[0]</code> which returns a reference to the first element.</p>
<p>There's a few implementations of the <code>From</code> trait. For instance <code>Vec::from(&quot;hello&quot;.to_string())</code>
will give you a vector of the underlying bytes of the string <code>Vec&lt;u8&gt;</code>.
Now, there's already a method 'into_bytes<code>on</code>String`, so why the redundancy?
It seems confusing to have multiple ways of doing the same thing.
But it's needed because explicit traits make generic methods possible.</p>
<p>We've met this before with <code>String</code> - there seem to be so many ways to create strings! There's the
<code>to_string</code> method on <code>&amp;str</code> - this comes from the <code>ToString</code> trait and will be implemented for anything
that knows how to <code>Display</code> itself.  There is <code>String::from</code> which comes from the <code>From</code> trait. There's
also <code>Into</code> which is the inverse of <code>From</code> and is automatically available if <code>From</code> exists.
If a function argument expects a <code>String</code>, you will often
see the value passed as <code>&quot;some text&quot;.into()</code> since string slices implement <code>Into&lt;String&gt;</code>.</p>
<p>Sometimes limitations of the Rust type system make things clumsy. An example here is how <code>PartialEq</code>
is <em>separately</em> defined for arrays up to size 32!  This will get better. This allows the convenience
of directly comparing vectors with arrays, but beware the limit.</p>
<p>This is still clearer than what the C++ docs say about <code>std::vector</code></p>
<blockquote>
<p>The requirements that are imposed on the elements depend on the actual operations performed
on the container. Generally, it is required that element type is a complete type and meets
the requirements of Erasable, but many member functions impose stricter requirements.</p>
</blockquote>
<p>Clearly, you're on your own! The explicitness of Rust is daunting at first, but as you learn to
read the constraints you will know exactly what any particular method of <code>Vec</code> requires.</p>
<a class="header" href="print.html#maps" name="maps"><h2>Maps</h2></a>
<p><em>Maps</em>  (sometimes called <em>associative arrays</em> or <em>dicts</em>) let you look up values
associated with a <em>key</em>.  It's not really a fancy concept, and can be done with
an array of tuples:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let entries = [(&quot;one&quot;,&quot;eins&quot;),(&quot;two&quot;,&quot;zwei&quot;),(&quot;three&quot;,&quot;drei&quot;)];

    if let Some(val) = entries.iter().find(|t| t.0 == &quot;two&quot;) {
        assert_eq!(val.1,&quot;zwei&quot;);
    }

#}</code></pre></pre>
<p>This is fine for small maps and just requires equality to be defined for the keys,
but the search takes linear time - proportional to the size of the map.</p>
<p>A <code>HashMap</code> does much better when there are a <em>lot</em> of key/value pairs to be
searched:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
use std::collections::HashMap;

let mut map = HashMap::new();
map.insert(&quot;one&quot;,&quot;eins&quot;);
map.insert(&quot;two&quot;,&quot;zwei&quot;);
map.insert(&quot;three&quot;,&quot;drei&quot;);

assert_eq! (map.contains_key(&quot;two&quot;), true);
assert_eq! (map.get(&quot;two&quot;), Some(&amp;&quot;zwei&quot;));

#}</code></pre></pre>
<p><code>&amp;&quot;zwei&quot;</code>? This is because <code>get</code> returns a <em>reference</em> to the value, not the value
itself. Here the value type is <code>&amp;str</code>, so we get a <code>&amp;&amp;str</code>. In general it <em>has</em> to be
a reference, because we can't just <em>move</em> a value out of its owning type.</p>
<p><code>get_mut</code> is like <code>get</code> but returns a possible mutable reference. Here we have
a map from strings to integers, and wish to update the value for the key 'two':</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let mut map = HashMap::new();
map.insert(&quot;one&quot;,1);
map.insert(&quot;two&quot;,2);
map.insert(&quot;three&quot;,3);

println!(&quot;before {}&quot;, map.get(&quot;two&quot;).unwrap());

{
    let mut mref = map.get_mut(&quot;two&quot;).unwrap();
    *mref = 20;
}

println!(&quot;after {}&quot;, map.get(&quot;two&quot;).unwrap());
// before 2
// after 20

#}</code></pre></pre>
<p>Note that getting that writable reference takes place in its own block - otherwise,
we would have a mutable borrow lasting until the end, and then Rust won't allow
you to borrow from <code>map</code> again with <code>map.get(&quot;two&quot;)</code>; it cannot allow any readable
references while there's already a writable reference in scope. (If it did, it could
not guarantee that those readable references would remain valid.)
So the solution is to make
sure that mutable borrow doesn't last very long.</p>
<p>It is not the most elegant API possible, but we can't throw away any possible
errors. Python would bail out with an exception, and C++ would just create
a default value. (This is convenient but sneaky; easy to forget that the price
of <code>a_map[&quot;two&quot;]</code> always returning an integer is that we can't tell the difference
between zero and 'not found', <em>plus</em> an extra entry is created!)</p>
<p>And no-one just calls <code>unwrap</code>, except in examples. However, most Rust code you see consists
of little standalone examples!  Much more likely for a match to take place:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
if let Some(v) = map.get(&quot;two&quot;) {
    let res = v + 1;
    assert_eq!(res, 3);
}
...
match map.get_mut(&quot;two&quot;) {
    Some(mref) =&gt; *mref = 20,
    None =&gt; panic!(&quot;_now_ we can panic!&quot;)
}

#}</code></pre></pre>
<p>We can iterate over the key/value pairs, but not in any particular order.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
for (k,v) in map.iter() {
    println!(&quot;key {} value {}&quot;, k,v);
}
// key one value eins
// key three value drei
// key two value zwei

#}</code></pre></pre>
<p>There are also <code>keys</code> and <code>values</code> methods returning iterators over the keys and
values respectively, which makes creating vectors of values easy.</p>
<a class="header" href="print.html#example-counting-words" name="example-counting-words"><h2>Example: Counting Words</h2></a>
<p>An entertaining thing to do with text is count word length frequency. It is straightforward
to break text into words with <code>split_whitespace</code>, but really we must respect punctuation.
So the words should be defined as consisting only of alphabetic characters.
And the words need to be compared as lower-case as well.</p>
<p>Doing a mutable lookup on a map is straightforward, but also handling the case where the
lookup fails is a little awkward.  Fortunately there's an elegant
way to update the values of a map:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let mut map = HashMap::new();

for s in text.split(|c: char| ! c.is_alphabetic()) {
    let word = s.to_lowercase();
    let mut count = map.entry(word).or_insert(0);
    *count += 1;
}

#}</code></pre></pre>
<p>If there's no existing count corresponding to a word, then let's create a new entry
containing zero for that word and <em>insert</em> it into the map. Its exactly what a C++
map does, except it's done explicitly and not sneakily.</p>
<p>There is exactly one explicit type in this snippet, and that's the <code>char</code> needed
because of a quirk of the string <code>Pattern</code> trait used by <code>split</code>.
But we can deduce that the key type is <code>String</code> and the value type is <code>i32</code>.</p>
<p>Using <a href="http://www.gutenberg.org/cache/epub/1661/pg1661.txt">The Adventures of Sherlock Holmes</a>
from Project Gutenberg, we can test this out
more thoroughly.  The total number of unique words (<code>map.len</code>) is 8071.</p>
<p>How to find the twenty most common words? First, convert the map into a vector
of (key,value) tuples. (This consumes the map, since we used <code>into_iter</code>.)</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let mut entries: Vec&lt;_&gt; = map.into_iter().collect();

#}</code></pre></pre>
<p>Next we can sort in descending order. <code>sort_by</code> expects the result of the <code>cmp</code>
method that comes from the <code>Ord</code> trait, which is implemented by the
integer value type:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    entries.sort_by(|a,b| b.1.cmp(&amp;a.1));

#}</code></pre></pre>
<p>And finally print out the first twenty entries:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    for e in entries.iter().take(20) {
        println!(&quot;{} {}&quot;, e.0, e.1);
    }

#}</code></pre></pre>
<p>(Well, you <em>could</em> just loop over <code>0..20</code> and index the vector here - it isn't wrong,
just a little un-idiomatic - and potentially more expensive for big iterations.)</p>
<pre><code> 38765
the 5810
and 3088
i 3038
to 2823
of 2778
a 2701
in 1823
that 1767
it 1749
you 1572
he 1486
was 1411
his 1159
is 1150
my 1007
have 929
with 877
as 863
had 830
</code></pre>
<p>A little surprise - what's that empty word? It is because <code>split</code> works on single-character
delimiters, so any punctuation or extra spaces causes a new split.</p>
<a class="header" href="print.html#sets" name="sets"><h2>Sets</h2></a>
<p>Sets are maps where you care only about the keys, not any associated values.
So <code>insert</code> only takes one value, and you use <code>contains</code> for testing whether a value
is in a set.</p>
<p>Like all containers, you can create a <code>HashSet</code> from an iterator. And this
is exactly what <code>collect</code> does, once you have given it the necessary type hint.</p>
<pre><code>// set1.rs
use std::collections::HashSet;

fn make_set(words: &amp;str) -&gt; HashSet&lt;&amp;str&gt; {
    words.split_whitespace().collect()
}

fn main() {
    let fruit = make_set(&quot;apple orange pear orange&quot;);

    println!(&quot;{:?}&quot;, fruit);
}
// {&quot;orange&quot;, &quot;pear&quot;, &quot;apple&quot;}
</code></pre>
<p>Note (as expected) that repeated insertions of the same key have no effect, and the order
of values in a set are not important.</p>
<p>They would not be sets without the usual operations:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
let fruit = make_set(&quot;apple orange pear&quot;);
let colours = make_set(&quot;brown purple orange yellow&quot;);

for c in fruit.intersection(&amp;colours) {
    println!(&quot;{:?}&quot;,c);
}
// &quot;orange&quot;

#}</code></pre></pre>
<p>They all create iterators, and you can use <code>collect</code> to make these into sets.</p>
<p>Here's a shortcut, just as we defined for vectors:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
use std::hash::Hash;

trait ToSet&lt;T&gt; {
    fn to_set(self) -&gt; HashSet&lt;T&gt;;
}

impl &lt;T,I&gt; ToSet&lt;T&gt; for I
where T: Eq + Hash, I: Iterator&lt;Item=T&gt; {

    fn to_set(self) -&gt; HashSet&lt;T&gt; {
       self.collect()
    }
}

...

let intersect = fruit.intersection(&amp;colours).to_set();

#}</code></pre></pre>
<p>As with all Rust generics, you do need to constrain types - this can only be
implemented for types that understand equality (<code>Eq</code>) and for which a 'hash function'
exists (<code>Hash</code>). Remember that there is no <em>type</em> called <code>Iterator</code>, so <code>I</code> represents
any type that <em>implements</em> <code>Iterator</code>.</p>
<p>This technique for implementing our own methods on standard library types may appear
to be a little too powerful, but again, there are Rules. We can only do this for our
own traits. If both the struct and the trait came from the same crate (particularly,
the stdlib) then such implemention would not be allowed. In this way, you are
saved from creating confusion.</p>
<p>Before congratulating ourselves on such a clever, convenient shortcut, you should be
aware of the consequences. If <code>make_set</code> was written so, so that these are sets
of owned strings, then the actual type of <code>intersect</code> could come as a sunrise:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn make_set(words: &amp;str) -&gt; HashSet&lt;String&gt; {
    words.split_whitespace().map(|s| s.to_string()).collect()
}
...
// intersect is HashSet&lt;&amp;String&gt;!
let intersect = fruit.intersection(&amp;colours).to_set();

#}</code></pre></pre>
<p>And it cannot be otherwise, since Rust will not suddenly start making copies of owned
strings. <code>intersect</code> contains a single <code>&amp;String</code> borrowed from <code>fruit</code>. I can promise
you that this will cause you trouble later, when you start patching up lifetimes!
A better solution is to use the iterator's <code>cloned</code> method to make owned string copies
of the intersection.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// intersect is HashSet&lt;String&gt; - much better
let intersect = fruit.intersection(&amp;colours).cloned().to_set();

#}</code></pre></pre>
<p>A more robust definition of <code>to_set</code> might be <code>self.cloned().collect()</code>,
which I invite you to try out.</p>
<a class="header" href="print.html#example-interactive-command-processing" name="example-interactive-command-processing"><h2>Example: Interactive command processing</h2></a>
<p>It's often useful to have an interactive session with a program. Each line is read in and
split into words; the command is looked up on the first word, and the rest of the words
are passed as an argument to that command.</p>
<p>A natural implementation is a map from command names to closures. It's tempting as
first to make them <code>FnMut</code> - that is, they can modify any captured variables. But we will
have more than one command, each with its own closure, and you cannot then mutably borrow
the same variables.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// this is a no-no
let mut a = 10;
let set = |n| a = n;
let get = || a;  // can't borrow `a` again!

#}</code></pre></pre>
<p>So the closures are passed a <em>mutable reference</em> as an argument, plus
a slice of string slices (<code>&amp;[&amp;str]</code>) representing the command arguments.
They will return some <code>Result</code> - We'll use <code>String</code> errors at first.</p>
<p>Recall that all closures
implementing a particular function signature are all distinct types, and are (in fact)
compiler-generated structs that <em>borrow</em> variables from the environment of the closure.
They are different types and may well have different sizes, so we put them in a <code>Box</code>.</p>
<p>Any struct that borrows references needs an explicit lifetime, since Rust needs
assurance that these references outlive our <code>Cli</code> struct - so closures have lifetimes.</p>
<p><code>D</code> is the data type, which can be anything with a size.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
type CliResult = Result&lt;String,String&gt;;

struct Cli&lt;'a,D&gt; {
    data: D,
    callbacks: HashMap&lt;String, Box&lt;Fn(&amp;mut D,&amp;[&amp;str])-&gt;CliResult + 'a&gt;&gt;
}

impl &lt;'a,D: Sized&gt; Cli&lt;'a,D&gt; {
    fn new(data: D) -&gt; Cli&lt;'a,D&gt; {
        Cli{data: data, callbacks: HashMap::new()}
    }

    fn cmd&lt;F&gt;(&amp;mut self, name: &amp;str, callback: F)
    where F: Fn(&amp;mut D, &amp;[&amp;str])-&gt;CliResult + 'a {
        self.callbacks.insert(name.to_string(),Box::new(callback));
    }

#}</code></pre></pre>
<p><code>cmd</code> is passed a name and any closure that matches our signature, which is boxed
and entered into the map.  <code>Fn</code> means that our closures borrow their environment
but can't modify it. It's one of those generic methods where the declaration is scarier than
the actual implementation!  Forgetting the explicit lifetime is a common error
here - Rust won't let us forget that these closures have a lifetime limited to
their environment!</p>
<p>Now for reading and running commands:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    fn process(&amp;mut self,line: &amp;str) -&gt; CliResult {
        let parts: Vec&lt;_&gt; = line.split_whitespace().collect();
        if parts.len() == 0 { return Ok(&quot;&quot;.to_string()); }
        match self.callbacks.get(parts[0]) {
            Some(callback) =&gt; callback(&amp;mut self.data,&amp;parts[1..]),
            None =&gt; Err(&quot;no such command&quot;.to_string())
        }
    }

    fn go(&amp;mut self) {
        let mut buff = String::new();
        while io::stdin().read_line(&amp;mut buff).expect(&quot;error&quot;) &gt; 0 {
            {
                let line = buff.trim_left();
                let res = self.process(line);
                println!(&quot;{:?}&quot;, res);

            }
            buff.clear();
        }
    }


#}</code></pre></pre>
<p>This is all reasonably straightforward - split the line into words as a vector,
look up the first word in the map and call the closure with our stored mutable
data and the rest of the words. An empty line is ignored and not considered an error.</p>
<p>Next, let's define some helper functions to make it easier for our closures to
return correct and incorrect results. There's a <em>little</em> bit of cleverness going on;
they are generic functions that work for any type that can be converted to a <code>String</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn ok&lt;T: ToString&gt;(s: T) -&gt; CliResult {
    Ok(s.to_string())
}

fn err&lt;T: ToString&gt;(s: T) -&gt; CliResult {
    Err(s.to_string())
}

#}</code></pre></pre>
<p>So finally, the Main Program. Look at how <code>ok(answer)</code> works - because
integers know how to convert themselves to strings!</p>
<pre><pre class="playpen"><code class="language-rust">use std::error::Error;

fn main() {
    println!(&quot;Welcome to the Interactive Prompt! &quot;);

    struct Data {
        answer: i32
    }

    let mut cli = Cli::new(Data{answer: 42});

    cli.cmd(&quot;go&quot;,|data,args| {
        if args.len() == 0 { return err(&quot;need 1 argument&quot;); }
        data.answer = match args[0].parse::&lt;i32&gt;() {
            Ok(n) =&gt; n,
            Err(e) =&gt; return err(e.description())
        };
        println!(&quot;got {:?}&quot;, args);
        ok(data.answer)
    });

    cli.cmd(&quot;show&quot;,|data,_| {
        ok(data.answer)
    });

    cli.go();
}
</code></pre></pre>
<p>The error handling is a bit clunky here, and we'll later see how to use the question
mark operator in cases like this.
Basically, the particular error <code>std::num::ParseIntError</code> implements
the trait <code>std::error::Error</code>, which we must bring into scope - Rust doesn't let traits
operate unless they're visible.</p>
<p>And in action:</p>
<pre><code>Welcome to the Interactive Prompt!
go 32
got [&quot;32&quot;]
Ok(&quot;32&quot;)
show
Ok(&quot;32&quot;)
goop one two three
Err(&quot;no such command&quot;)
go 42 one two three
got [&quot;42&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
Ok(&quot;42&quot;)
go boo!
Err(&quot;invalid digit found in string&quot;)
</code></pre>
<p>Here are some obvious improvements for you to try. First, if we give <code>cmd</code> three
arguments with the second being a help line, then we can store these help lines
and automatically implement a 'help' command. Second, having some command editing and
history is <em>very</em> convenient, so use the <a href="https://crates.io/crates/rustyline">rustyline</a> crate
from Cargo.</p>
<a class="header" href="print.html#error-handling" name="error-handling"><h1>Error Handling</h1></a>
<a class="header" href="print.html#basic-error-handling" name="basic-error-handling"><h2>Basic Error Handling</h2></a>
<p>Error handling in Rust can be clumsy if you can't use the question-mark operator.
To achieve happiness, we need to create our own error type. The basic requirements
are straightforward:</p>
<ul>
<li>May implement <code>Debug</code></li>
<li>Must implement <code>Display</code></li>
<li>Must implement <code>Error</code></li>
</ul>
<p>Otherwise, your error can do pretty much what it likes.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// error1.rs
use std::error::Error;
use std::fmt;

#[derive(Debug)]
struct MyError {
    details: String
}

impl MyError {
    fn new(msg: &amp;str) -&gt; MyError {
        MyError{details: msg.to_string()}
    }
}

impl fmt::Display for MyError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f,&quot;{}&quot;,self.details)
    }
}


impl Error for MyError {
    fn description(&amp;self) -&gt; &amp;str {
        &amp;self.details
    }
}

// a test function that returns our error result
fn raises_my_error(yes: bool) -&gt; Result&lt;(),MyError&gt; {
    if yes {
        Err(MyError::new(&quot;borked&quot;))
    } else {
        Ok(())
    }
}

#}</code></pre></pre>
<p>In this example we need to handle the specific error when a string can't be parsed
as a floating-point number. It implements <code>Error</code> so <code>description()</code> is defined.</p>
<p>Now the way that <code>?</code> works
is to look for a conversion from the error of the expression to the error that must
be returned. And this conversion is expressed by the <code>From</code> trait:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
impl From&lt;std::num::ParseFloatError&gt; for MyError {
    fn from(err: std::num::ParseFloatError) -&gt; Self {
        MyError::new(err.description())
    }
}

// and test!
fn parse_f64(s: &amp;str, yes: bool) -&gt; Result&lt;f64,MyError&gt; {
    raises_my_error(yes)?;
    let x: f64 = s.parse()?;
    Ok(x)
}

#}</code></pre></pre>
<p>The first <code>?</code> is fine (a type always converts to itself with <code>From</code>) and the
second <code>?</code> needs to convert from <code>ParseFloatError</code> to <code>MyError</code>.</p>
<p>And the results:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot; {:?}&quot;, parse_f64(&quot;42&quot;,false));
    println!(&quot; {:?}&quot;, parse_f64(&quot;42&quot;,true));
    println!(&quot; {:?}&quot;, parse_f64(&quot;?42&quot;,false));
}
//  Ok(42)
//  Err(MyError { details: &quot;borked&quot; })
//  Err(MyError { details: &quot;invalid float literal&quot; })
</code></pre></pre>
<p>Not too complicated, although a little long-winded. The tedious bit is having to
write <code>From</code> conversions for all the other error types that need to play nice
with <code>MyError</code>.  But once the mechanism is in place, your error handling looks
much cleaner!</p>
<p>Typing <code>Result&lt;T,MyError&gt;</code> gets tedious and many Rust modules define their own
<code>Result</code> - e.g. <code>io::Result&lt;T&gt;</code> is short for <code>io::Result&lt;T,io::Error&gt;</code>.</p>
<p>Currently, the question-mark operator only works for <code>Result</code>, not <code>Option</code>, and this can be seen
as a feature, not a limitation.  <code>Option</code> has a <code>ok_or_else</code> which converts itself into a <code>Result</code>.
For example, say we had a <code>HashMap</code> and must fail if a key isn't defined:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let val = map.get(&quot;my_key&quot;).ok_or_else(|| MyError::new(&quot;my_key not defined&quot;))?;

#}</code></pre></pre>
<p>Now here the error returned is completely clear! (This form uses a closure, so the error value
is only created if the lookup fails.)</p>
<a class="header" href="print.html#error-chain-to-the-rescue" name="error-chain-to-the-rescue"><h2>error-chain to the Rescue</h2></a>
<p>Error handling is important, and for non-trivial applications have a look
at the <a href="http://brson.github.io/2016/11/30/starting-with-error-chain">error_chain</a> crate.
A little macro magic can go a long way in Rust...</p>
<p>Create a binary crate with <code>cargo new --bin test-error-chain</code> and
change to this directory. Edit <code>Cargo.toml</code> and add <code>error-chain=&quot;0.8.1&quot;</code> to the end.</p>
<p>What <strong>error-chain</strong> does for you is create all the definitions we needed for manually implementing
an error type; creating a struct, and implementing the necessary traits: <code>Display</code>, <code>Debug</code> and <code>Error</code>.
It also by default implements <code>From</code> so strings can be converted into errors. Here we also ask for
<code>From</code> to be implemented so that <code>std::io::Error</code> will also convert into our error type.</p>
<p>Our first <code>src/main.rs</code> file looks like this. All the main program does is call <code>run</code>, print out any
errors, and end the program with a non-zero exit code.  The macro <code>error_chain</code> generates all the
definitions needed, within an <code>error</code> module - in a larger program you would put this in its own file.
We need to bring everything in <code>error</code> back into global scope because our code will need to see
the generated traits. By default, there will be an <code>Error</code> struct and a <code>Result</code> defined with that
error:</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate error_chain;

mod errors {
    error_chain!{
        foreign_links {
            Io(::std::io::Error);
        }
    }
}
use errors::*;

fn run() -&gt; Result&lt;()&gt; {
    use std::fs::File;

    File::open(&quot;file&quot;)?;

    Ok(())
}


fn main() {
    if let Err(e) = run() {
        println!(&quot;error: {}&quot;, e);

        std::process::exit(1);
    }
}
// error: No such file or directory (os error 2)
</code></pre></pre>
<p>The 'foreign_links' has made our life easier, since the question mark operator now knows how to
convert <code>std::io::Error</code> into our <code>error::Error</code>.</p>
<p>All the action happens in <code>run</code>; let's make it print out the first 10 lines of a file given as the
first program argument.  There may or may not be such an argument, which isn't necessarily an
error. Here we want to convert an <code>Option&lt;String&gt;</code> into a <code>Result&lt;String&gt;</code>. There are two <code>Option</code>
methods for doing this conversion, and I've picked the simplest one.  Our <code>Error</code> type implements
<code>From</code> for <code>&amp;str</code>, so it's straightforward to make an error with a simple text message.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn run() -&gt; Result&lt;()&gt; {
    use std::env::args;
    use std::fs::File;
    use std::io::BufReader;
    use std::io::prelude::*;

    let file = args().skip(1).next()
        .ok_or(Error::from(&quot;provide a file&quot;))?;

    let f = File::open(&amp;file)?;
    let mut l = 0;
    for line in BufReader::new(f).lines() {
        let line = line?;
        println!(&quot;{}&quot;, line);
        l += 1;
        if l == 10 {
            break;
        }
    }

    Ok(())
}

#}</code></pre></pre>
<p>There is a useful little macro <code>bail!</code> for 'throwing' errors.
An alternative to the <code>ok_or</code> method here could be:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let file = match args().skip(1).next() {
        Some(s) =&gt; s,
        None =&gt; bail!(&quot;provide a file&quot;)
    };

#}</code></pre></pre>
<p>Like <code>?</code> it does an <em>early return</em>.</p>
<p>The returned error contains an enum <code>ErrorKind</code>, which allows us to distinguish between various
kinds of errors. There's always a variant <code>Msg</code> (when you say <code>Error::from(str)</code>) and the <code>foreign_links</code>
macro has declared <code>Io</code> which wraps I/O errors:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    if let Err(e) = run() {
        match e.kind() {
            &amp;ErrorKind::Msg(ref s) =&gt; println!(&quot;msg {}&quot;,s),
            &amp;ErrorKind::Io(ref s) =&gt; println!(&quot;io {}&quot;,s),
        }
        std::process::exit(1);
    }
}
// $ cargo run
// msg provide a file
// $ cargo run foo
// io No such file or directory (os error 2)
</code></pre></pre>
<p>It's straightforward to add new kinds of errors. Add an <code>errors</code> section to the <code>error_chain!</code> macro:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    error_chain!{
        foreign_links {
            Io(::std::io::Error);
        }

        errors {
            NoArgument(t: String) {
                display(&quot;no argument provided: '{}'&quot;, t)
            }
        }

    }

#}</code></pre></pre>
<p>This defines how <code>Display</code> works for this new kind of error. And now we can handle
'no argument' errors more specifically, feeding <code>ErrorKind::NoArgument</code> a <code>String</code> value:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let file = args().skip(1).next()
        .ok_or(ErrorKind::NoArgument(&quot;filename needed&quot;.to_string()))?;


#}</code></pre></pre>
<p>There's now an extra <code>ErrorKind</code> variant that you must match:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    if let Err(e) = run() {
        println!(&quot;error {}&quot;,e);
        match e.kind() {
            &amp;ErrorKind::Msg(ref s) =&gt; println!(&quot;msg {}&quot;, s),
            &amp;ErrorKind::Io(ref s) =&gt; println!(&quot;io {}&quot;, s),
            &amp;ErrorKind::NoArgument(ref s) =&gt; println!(&quot;no argument {:?}&quot;, s),
        }
        std::process::exit(1);
    }
}
// cargo run
// error no argument provided: 'filename needed'
// no argument &quot;filename needed&quot;
</code></pre></pre>
<p>Generally, it's useful to make errors as specific as possible, <em>particularly</em> if this is a library
function! This match-on-kind technique is pretty much the equivalent of traditional exception handling,
where you match on exception types.</p>
<p>In summary, <strong>error-chain</strong> creates a type <code>Error</code> for you, and defines <code>Result&lt;T&gt;</code> to be <code>std::result::Result&lt;T,Error&gt;</code>.
<code>Error</code> contains an enum <code>ErrorKind</code> and by default there is one variant <code>Msg</code> for errors created from
strings. You define 'foreign' errors with <code>foreign_links</code> which does two things. First, it creates a new
<code>ErrorKind</code> variant. Second, it defines <code>From</code> on these external errors so they can be converted to our
error.  New error variants can be easily added.  A lot of irritating boilerplate code is eliminated.</p>
<a class="header" href="print.html#chaining-errors" name="chaining-errors"><h2>Chaining Errors</h2></a>
<p>But the really cool thing that this crate provides is <em>error chaining</em>.</p>
<p>As a <em>library user</em>, it's irritating when a method simply just 'throws' a generic I/O error. OK, it
could not open a file, fine, but what file? Basically, what use is this information to me?</p>
<p><code>error_chain</code> does <em>error chaining</em> which helps solve this problem of over-generic errors. When we
try to open the file, we can lazily lean on the conversion to <code>io::Error</code> using <code>?</code> or chain the error.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// non-specific error
let f = File::open(&amp;file)?;

// a specific chained error
let f = File::open(&amp;file).chain_err(|| &quot;unable to read the damn file&quot;)?;

#}</code></pre></pre>
<p>Here's a new version of the program, with <em>no</em> imported 'foreign' errors, just the defaults:</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate error_chain;

mod errors {
    error_chain!{
    }

}
use errors::*;

fn run() -&gt; Result&lt;()&gt; {
    use std::env::args;
    use std::fs::File;
    use std::io::BufReader;
    use std::io::prelude::*;

    let file = args().skip(1).next()
        .ok_or(Error::from(&quot;filename needed&quot;))?;

    ///////// chain explicitly! ///////////
    let f = File::open(&amp;file).chain_err(|| &quot;unable to read the damn file&quot;)?;

    let mut l = 0;
    for line in BufReader::new(f).lines() {
        let line = line.chain_err(|| &quot;cannot read a line&quot;)?;
        println!(&quot;{}&quot;, line);
        l += 1;
        if l == 10 {
            break;
        }
    }

    Ok(())
}


fn main() {
    if let Err(e) = run() {
        println!(&quot;error {}&quot;, e);

        /////// look at the chain of errors... ///////
        for e in e.iter().skip(1) {
            println!(&quot;caused by: {}&quot;, e);
        }

        std::process::exit(1);
    }
}
// $ cargo run foo
// error unable to read the damn file
// caused by: No such file or directory (os error 2)
</code></pre></pre>
<p>So the <code>chain_err</code> method takes the original error, and creates a new error which contains the
original error - this can be continued indefinitely.  The closure is expected to return any
value which can be <em>converted</em> into an error.</p>
<p>Rust macros can clearly save you a lot of typing.  <code>error-chain</code> even provides a shortcut that
replaces the whole main program:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
quick_main!(run);

#}</code></pre></pre>
<p>(<code>run</code> is where all the action takes place, anyway.)</p>
<a class="header" href="print.html#threads-networking-and-sharing" name="threads-networking-and-sharing"><h1>Threads, Networking and Sharing</h1></a>
<a class="header" href="print.html#changing-the-unchangeable" name="changing-the-unchangeable"><h2>Changing the Unchangeable</h2></a>
<p>If you're feeling pig-headed (as I get) you wonder if it's <em>ever</em> possible to get
around the restrictions of the borrow checker.</p>
<p>Consider the following little program, which compiles and runs without problems.</p>
<pre><pre class="playpen"><code class="language-rust">// cell.rs
use std::cell::Cell;

fn main() {
    let answer = Cell::new(42);

    assert_eq!(answer.get(), 42);

    answer.set(77);

    assert_eq!(answer.get(), 77);
}
</code></pre></pre>
<p>The answer was changed - and yet the <em>variable</em> <code>answer</code> was not mutable!</p>
<p>This is obviously perfectly safe, since the value inside the cell is only accessed
through <code>set</code> and <code>get</code>.  This goes by the grand name of <em>interior mutability</em>. The
usual is called <em>inherited mutability</em>: if I have a struct value <code>v</code>, then I can only
write to a field <code>v.a</code> if <code>v</code> itself is writeable. <code>Cell</code> values relax this rule, since
we can change the value contained within them with <code>set</code> even if the cell itself is
not mutable.</p>
<p>However, <code>Cell</code> only works with values that can be copied, that is, they implement <code>Copy</code>,
like primitive types and structs containing them marked as 'derive(Copy)'.</p>
<p>For other values, we have to get a reference we can work on, either mutable or immutable.
This is what <code>RefCell</code> provides - you ask it explicitly for a reference to the contained
value:</p>
<pre><pre class="playpen"><code class="language-rust">// refcell.rs
use std::cell::RefCell;

fn main() {
    let greeting = RefCell::new(&quot;hello&quot;.to_string());

    assert_eq!(*greeting.borrow(), &quot;hello&quot;);
    assert_eq!(greeting.borrow().len(), 5);

    *greeting.borrow_mut() = &quot;hola&quot;.to_string();

    assert_eq!(*greeting.borrow(), &quot;hola&quot;);
}
</code></pre></pre>
<p>The explicit dereference operator <code>*</code> can be a little bit confusing in Rust, because
often you don't need it - for instance <code>greeting.borrow().len()</code> is fine since method
calls will deference implicitly.  But you <em>do</em> need <code>*</code> to pull out the underlying
<code>&amp;String</code> from <code>greeting.borrow()</code> or the <code>&amp;mut String</code> from <code>greeting.borrow_mut()</code>.</p>
<p>Using a <code>RefCell</code> isn't always safe, because any references returned from these
methods must follow the usual rules.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let mut gr = greeting.borrow_mut(); // gr is a mutable borrow
    *gr = &quot;hola&quot;.to_string();

    assert_eq!(*greeting.borrow(), &quot;hola&quot;); // &lt;== we blow up here!
....
thread 'main' panicked at 'already mutably borrowed: BorrowError'

#}</code></pre></pre>
<p>You cannot borrow immutably if you have already borrowed mutably! Except - and this
is important - the violation of the rules happens at <em>runtime</em>.  The solution (as always)
is to keep the scope of mutable borrows as limited as possible - in this case, you could
put a block around the first two lines here so that the mutable reference <code>gr</code> gets
dropped before we borrow again.</p>
<p>So, this is not a feature you use without good reason, since you will <em>not</em> get a
compile-time error.  These types provide <em>dynamic borrowing</em> in cases where the usual
rules make some things impossible.</p>
<a class="header" href="print.html#shared-references" name="shared-references"><h2>Shared References</h2></a>
<p>Up to now, the relationship between a value and its borrowed references has been clear
and known at compile time.  The value is the owner, and the references cannot outlive it.
But many cases simply don't fit into this neat pattern. For example, say we have
a <code>Player</code> struct and a <code>Role</code> struct. A <code>Player</code> keeps a vector of references to <code>Role</code>
objects. There isn't a neat one-to-one relationship between these values, and persuading
<code>rustc</code> to cooperate becomes nasty.</p>
<p><code>Rc</code> works like <code>Box</code> - heap memory is allocated and the value is moved to it. If you
clone a <code>Box</code>, it allocates a full cloned copy of the value.  But cloning an <code>Rc</code> is
cheap, because each time you clone it just updates a _reference count_to the <em>same data</em>.
This is an old and very popular strategy for memory management,
for example it's used in the Objective C runtime on iOS/MacOS.
(In modern C++, it is implemented with <code>std::shared_ptr</code>.)</p>
<p>When a <code>Rc</code> is dropped, the reference count is decremented. When that count goes to zero
the owned value is dropped and the memory freed.</p>
<pre><pre class="playpen"><code class="language-rust">// rc1.rs
use std::rc::Rc;

fn main() {
    let s = &quot;hello dolly&quot;.to_string();
    let rs1 = Rc::new(s); // s moves to heap; ref count 1
    let rs2 = rs1.clone(); // ref count 2

    println!(&quot;len {}, {}&quot;, rs1.len(), rs2.len());
} // both rs1 and rs2 drop, string dies.
</code></pre></pre>
<p>You may make as many references as you like to the original value - it's <em>dynamic borrowing</em>
again. You do not have to carefully track the relationship between the value <code>T</code> and
its references <code>&amp;T</code>. There is some runtime cost involved, so it isn't the <em>first</em>
solution you choose, but it makes patterns of sharing possible which would fall foul
of the borrow checker.  Note that <code>Rc</code> gives you immutable shared references, since
otherwise that would break one of the very basic rules of borrowing.
A leopard can't change its spots without ceasing to be a leopard.</p>
<p>In the case of a <code>Player</code>, it can now keep its roles as a <code>Vec&lt;Rc&lt;Role&gt;&gt;</code> and things
work out fine - we can add or remove roles but not <em>change</em> them after their creation.</p>
<p>However, what if each <code>Player</code> needs to keep references to a <em>team</em> as a vector of
<code>Player</code> references? Then everything becomes immutable, because all the <code>Player</code> values
need to be stored as <code>Rc</code>!  This is the place where <code>RefCell</code> becomes necessary. The team
may be then defined as <code>Vec&lt;Rc&lt;RefCell&lt;Player&gt;&gt;&gt;</code>.  It is now possible to change
a <code>Player</code> value using <code>borrow_mut</code>, <em>provided</em> no-one has 'checked out' a reference
to a <code>Player</code> at the same time. For example, say we have a rule that if something special
happens to a player, then all of their team gets stronger:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    for p in &amp;self.team {
        p.borrow_mut().make_stronger();
    }

#}</code></pre></pre>
<p>So the application code isn't too bad, but the type signatures get a bit scary. You can
always simplify them with a <code>type</code> alias:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
type PlayerRef = Rc&lt;RefCell&lt;Player&gt;&gt;;

#}</code></pre></pre>
<a class="header" href="print.html#multithreading" name="multithreading"><h2>Multithreading</h2></a>
<p>Over the last twenty years, there has been a shift away from raw processing speed
to CPUs having multiple cores. So the only way to get the most out of a modern computer
is to keep all of those cores busy. It's certainly possible to spawn child processes
in the background as we saw with <code>Command</code> but there's still a synchronization problem:
we don't know exactly when those children are finished without waiting on them.</p>
<p>There are other reasons for needing separate <em>threads of execution</em>, of course. You cannot
afford to lock up your whole process just to wait on blocking i/o, for instance.</p>
<p>Spawning threads is straightforward in Rust - you feed <code>spawn</code> a closure which is
executed in the background.</p>
<pre><pre class="playpen"><code class="language-rust">// thread1.rs
use std::thread;
use std::time;

fn main() {
    thread::spawn(|| println!(&quot;hello&quot;));
    thread::spawn(|| println!(&quot;dolly&quot;));

    println!(&quot;so fine&quot;);
    // wait a little bit
    thread::sleep(time::Duration::from_millis(100));
}
// so fine
// hello
// dolly
</code></pre></pre>
<p>Well obviously just 'wait a little bit' is not a very rigorous solution! It's better
to call <code>join</code> on the returned object - then the main thread waits for the
spawned thread to finish.</p>
<pre><pre class="playpen"><code class="language-rust">// thread2.rs
use std::thread;

fn main() {
    let t = thread::spawn(|| {
        println!(&quot;hello&quot;);
    });
    println!(&quot;wait {:?}&quot;, t.join());
}
// hello
// wait Ok(())
</code></pre></pre>
<p>Here's an interesting variation: force the new thread to panic.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let t = thread::spawn(|| {
        println!(&quot;hello&quot;);
        panic!(&quot;I give up!&quot;);
    });
    println!(&quot;wait {:?}&quot;, t.join());

#}</code></pre></pre>
<p>We get a panic as expected, but only the panicking thread dies! We still manage
to print out the error message from the <code>join</code>. So yes, panics are not always fatal,
but threads are relatively expensive, so this should not be seen as a routine way
of handling panics.</p>
<pre><code>hello
thread '&lt;unnamed&gt;' panicked at 'I give up!', thread2.rs:7
note: Run with `RUST_BACKTRACE=1` for a backtrace.
wait Err(Any)
</code></pre>
<a class="header" href="print.html#threads-dont-borrow" name="threads-dont-borrow"><h2>Threads Don't Borrow</h2></a>
<p>It's possible for the thread closure to capture values, but <em>not</em> by borrowing!</p>
<pre><pre class="playpen"><code class="language-rust">// thread3.rs
use std::thread;

fn main() {
    let name = &quot;dolly&quot;.to_string();
    let t = thread::spawn(|| {
        println!(&quot;hello {}&quot;, name);
    });
    println!(&quot;wait {:?}&quot;, t.join());
}
</code></pre></pre>
<p>And here's the helpful error message:</p>
<pre><code>error[E0373]: closure may outlive the current function, but it borrows `name`, which is owned by the current function
 --&gt; thread3.rs:6:27
  |
6 |     let t = thread::spawn(|| {
  |                           ^^ may outlive borrowed value `name`
7 |         println!(&quot;hello {}&quot;, name);
  |                             ---- `name` is borrowed here
  |
help: to force the closure to take ownership of `name` (and any other referenced variables), use the `move` keyword, as shown:
  |     let t = thread::spawn(move || {
</code></pre>
<p>That's fair enough! Imagine spawning this thread from a function - it will exist
after the function call has finished and <code>name</code> gets dropped.  So adding <code>move</code> solves our
problem.</p>
<p>The returned objects can be used to keep track of multiple threads:</p>
<pre><pre class="playpen"><code class="language-rust">// thread4.rs
use std::thread;

fn main() {
    let mut threads = Vec::new();

    for i in 0..5 {
        let t = thread::spawn(move || {
            println!(&quot;hello {}&quot;, i);
        });
        threads.push(t);
    }

    for t in threads {
        t.join().expect(&quot;thread failed&quot;);
    }
}
// hello 0
// hello 2
// hello 4
// hello 3
// hello 1

</code></pre></pre>
<p>Rust insists that we handle the case where the join failed - i.e. that thread panicked.
(You would typically not bail out of the main program when this happens, just note the
error, retry etc)</p>
<p>There is no particular order to thread execution (this program gives different orders
for different runs), and this is key - they really are <em>independent threads of execution</em>.
Multithreading is easy; what's hard is <em>concurrency</em> - managing and synchronizing multiple
threads of execution.</p>
<p>Threads can't share the same environment - by <em>design</em> in Rust. In particular,
they cannot share regular references because the closures move their captured variables.</p>
<p>_<em>shared references</em> are fine however - but you cannot use <code>Rc</code> for this. This is because
<code>Rc</code> is not <em>thread safe</em> - it's optimized to be fast for the non-threaded case. For
threads, you need <code>std::sync::Arc</code> - 'Arc' stands for 'Atomic Reference Counting'. That
is, it guarantees that the reference count will be modified in one logical operation. To
make this guarantee, it must ensure that the operation is locked so that only the current
thread has access.</p>
<pre><pre class="playpen"><code class="language-rust">// thread5.rs
use std::thread;
use std::sync::Arc;

fn main() {
    let mut threads = Vec::new();
    let name = Arc::new(&quot;dolly&quot;.to_string());

    for i in 0..5 {
        let tname = name.clone();
        let t = thread::spawn(move || {
            println!(&quot;hello {} count {}&quot;, tname,i);
        });
        threads.push(t);
    }

    for t in threads {
        t.join().expect(&quot;thread failed&quot;);
    }
}
</code></pre></pre>
<p>So the shared reference <code>name</code> is passed to each new thread by making a new reference
with <code>clone</code> and moving it into the closure. It's a little verbose, but this is a safe
pattern. Safety is important in concurrency precisely because the problems are so
unpredictable. A program may run fine on your machine, but occasionally crash on the
server, usually on the weekend. Worse still, the symptoms of such problems are
not easy to diagnose.</p>
<a class="header" href="print.html#channels" name="channels"><h2>Channels</h2></a>
<p>There are ways to send data between threads. This
is done in Rust using <em>channels</em>. <code>std::sync::mpsc::channel()</code> returns a pair:
the <em>receiver</em> channel and the <em>sender</em> channel. Each thread is passed a copy
of the sender with <code>clone</code>, and calls <code>send</code>. Meanwhile the main thread calls
<code>recv</code> on the receiver.</p>
<pre><pre class="playpen"><code class="language-rust">// thread9.rs
use std::thread;
use std::sync::mpsc;

fn main() {
    let nthreads = 5;
    let (tx, rx) = mpsc::channel();

    for i in 0..nthreads {
        let tx = tx.clone();
        thread::spawn(move || {
            let response = format!(&quot;hello {}&quot;, i);
            tx.send(response).unwrap();
        });
    }

    for _ in 0..nthreads {
        println!(&quot;got {:?}&quot;, rx.recv());
    }
}
// got Ok(&quot;hello 0&quot;)
// got Ok(&quot;hello 1&quot;)
// got Ok(&quot;hello 3&quot;)
// got Ok(&quot;hello 4&quot;)
// got Ok(&quot;hello 2&quot;)
</code></pre></pre>
<p>There's no need to join here since the threads send their response just before they
end execution, but obviously this can happen at any time. <code>recv</code> will block, and will
return an error if the sender channel is disconnected. <code>recv_timeout</code> will only block
for a given time period, and may return a timeout error as well.</p>
<p><code>send</code> never blocks, which is useful because threads can push out data without waiting
for the receiver to process. In addition, the channel is buffered so multiple
send` operations can take place, which will be received in order.</p>
<p>However, not blocking means that <code>Ok</code> does not automatically mean 'successfully delivered message'!</p>
<p>A <code>sync_channel</code> <em>does</em> block on send. With an argument of zero, the send blocks until the
recv happens. The threads must meet up or <em>rendezvous</em> (on the sound principle that most things
sound better in French.)</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    let (tx, rx) = mpsc::sync_channel(0);

    let t1 = thread::spawn(move || {
        for i in 0..5 {
            tx.send(i).unwrap();
        }
    });

    for _ in 0..5 {
        let res = rx.recv().unwrap();
        println!(&quot;{}&quot;,res);
    }
    t1.join().unwrap();

#}</code></pre></pre>
<p>We can easily cause an error here by calling <code>recv</code> when there has been no corresponding <code>send</code>, e.g
by looping <code>for i in 0..4</code>. The thread ends, and <code>tx</code> drops, and then <code>recv</code> will fail. This will also
happen if the thread panics, which causes its stack to be unwound, dropping any values.</p>
<p>If the <code>sync_channel</code> was created with a non-zero argument <code>n</code>, then it acts like a queue with a
maximum size of <code>n</code> - <code>send</code> will only block when it tries to add more than <code>n</code> values to the queue.</p>
<p>Channels are strongly typed - here the channel had type <code>i32</code> - but type inference makes this implicit.
If you need to pass different kinds of data, then enums are a good way to express this.</p>
<a class="header" href="print.html#synchronization" name="synchronization"><h2>Synchronization</h2></a>
<p>Let's look at <em>synchronization</em>. <code>join</code> is very basic, and merely waits until a
particular thread has finished.  A <code>sync_channel</code> synchronizes two threads - in the last example, the
spawned thread and the main thread are completely locked together.</p>
<p>Barrier synchronization is a checkpoint where the threads must wait until <em>all</em> of
them have reached that point. Then they can keep going as before. The barrier is
created with the number of threads that we want to wait for. As before we use use <code>Arc</code>
to share the barrier with all the threads.</p>
<pre><pre class="playpen"><code class="language-rust">// thread7.rs
use std::thread;
use std::sync::Arc;
use std::sync::Barrier;

fn main() {
    let nthreads = 5;
    let mut threads = Vec::new();
    let barrier = Arc::new(Barrier::new(nthreads));

    for i in 0..nthreads {
        let barrier = barrier.clone();
        let t = thread::spawn(move || {
            println!(&quot;before wait {}&quot;, i);
            barrier.wait();
            println!(&quot;after wait {}&quot;, i);
        });
        threads.push(t);
    }

    for t in threads {
        t.join().unwrap();
    }
}
// before wait 2
// before wait 0
// before wait 1
// before wait 3
// before wait 4
// after wait 4
// after wait 2
// after wait 3
// after wait 0
// after wait 1
</code></pre></pre>
<p>The threads do their semi-random thing, all meet up, and then continue. It's like a kind
of resumable <code>join</code> and useful when you need to farm off pieces of a job to
different threads and want to take some action when all the pieces are finished.</p>
<a class="header" href="print.html#shared-state" name="shared-state"><h2>Shared State</h2></a>
<p>But how can threads <em>modify</em> shared state?</p>
<p>Recall the <code>Rc&lt;RefCell&gt;</code> strategy for <em>dynamically</em> doing a
mutable borrow on shared references.  The threading equivalent to <code>RefCell</code> is
<code>Mutex</code> - you may get your mutable reference by calling <code>lock</code>. While this reference
exists, no other thread can access it. <code>mutex</code> stands for <code>Mutual Exclusion' - we lock a section of code so that only one thread can access it, and then unlock it. You get the lock with the</code>lock` method, and it is unlocked when the reference is dropped.</p>
<pre><pre class="playpen"><code class="language-rust">// thread9.rs
use std::thread;
use std::sync::Arc;
use std::sync::Mutex;

fn main() {
    let answer = Arc::new(Mutex::new(42));

    let answer_ref = answer.clone();
    let t = thread::spawn(move || {
        let mut answer = answer_ref.lock().unwrap();
        *answer = 55;
    });

    t.join().unwrap();

    let ar = answer.lock().unwrap();
    assert_eq!(*ar, 55);

}
</code></pre></pre>
<p>This isn't so straightforward as using <code>RefCell</code> because asking for the lock on
the mutex might fail, if another thread has panicked while holding the lock.
(In this case, the documentation actually recommends just exiting the thread with <code>unwrap</code>
because things have gone seriously wrong!)</p>
<p>It's even more important to keep this mutable borrow as short as possible, because
as long as the mutex is locked, other threads are <em>blocked</em>. This is not the place for
expensive calculations! So typically such code would be used like this:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
// ... do something in the thread
// get a locked reference and use it briefly!
{
    let mut data = data_ref.lock().unwrap();
    // modify data
}
//... continue with the thread

#}</code></pre></pre>
<a class="header" href="print.html#higher-level-operations" name="higher-level-operations"><h2>Higher-Level Operations</h2></a>
<p>It's better to find higher-level ways of doing threading, rather than managing the synchronization
yourself. An example is when you need to do things in parallel and collect the results. One very
cool crate is <a href="https://docs.rs/pipeliner/0.1.1/pipeliner/">pipeliner</a> which has a very straightforward
API. Here's the 'Hello, World!' - an iterator feeds us inputs and we execute up to <code>n</code> of the operations
on the values in parallel.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate pipeliner;
use pipeliner::Pipeline;

fn main() {
    for result in (0..50).with_threads(10).map(|x| x + 1) {
        println!(&quot;result: {}&quot;, result);
    }
}
</code></pre></pre>
<p>It's silly of course, because the operation is so cheap to calculate, but shows how simple it is
to collect parallel results.</p>
<p>Here's something more useful. Doing network operations in parallel is very useful, because they can
take time, and you don't want to wait for them <em>all</em> to finish before starting to do work.</p>
<p>This example is pretty crude (believe me, there are better ways of doing it) but here we want to focus
on the principle. We reuse the <code>shell</code> function defined in section 4 to call <code>ping</code> on a range
of IP4 addresses.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate pipeliner;
use pipeliner::Pipeline;

use std::process::Command;

fn shell(cmd: &amp;str) -&gt; (String,bool) {
    let cmd = format!(&quot;{} 2&gt;&amp;1&quot;,cmd);
    let output = Command::new(&quot;/bin/sh&quot;)
        .arg(&quot;-c&quot;)
        .arg(&amp;cmd)
        .output()
        .expect(&quot;no shell?&quot;);
    (
        String::from_utf8_lossy(&amp;output.stdout).trim_right().to_string(),
        output.status.success()
    )
}

fn main() {
    let addresses: Vec&lt;_&gt; = (1..40).map(|n| format!(&quot;ping -c1 192.168.0.{}&quot;,n)).collect();
    let n = addresses.len();

    for result in addresses.with_threads(n).map(|s| shell(&amp;s)) {
        if result.1 {
            println!(&quot;got: {}&quot;, result.0);
        }
    }

}
</code></pre></pre>
<p>And the result on my home network looks like this:</p>
<pre><code>got: PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data.
64 bytes from 192.168.0.1: icmp_seq=1 ttl=64 time=43.2 ms

--- 192.168.0.1 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 43.284/43.284/43.284/0.000 ms
got: PING 192.168.0.18 (192.168.0.18) 56(84) bytes of data.
64 bytes from 192.168.0.18: icmp_seq=1 ttl=64 time=0.029 ms

--- 192.168.0.18 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.029/0.029/0.029/0.000 ms
got: PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.
64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=110 ms

--- 192.168.0.3 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 110.008/110.008/110.008/0.000 ms
got: PING 192.168.0.5 (192.168.0.5) 56(84) bytes of data.
64 bytes from 192.168.0.5: icmp_seq=1 ttl=64 time=207 ms
...
</code></pre>
<p>The active addresses come through pretty fast within the first half-second, and we then wait for the negative
results to come in. Otherwise, we would wait for the better part of a minute! You can now proceed
to scrape things like ping times from the output, although this would only work on Linux. <code>ping</code>
is universal, but the exact output format is different for each platform.  To do better we need to use
the cross-platform Rust networking API, and so let's move onto Networking.</p>
<a class="header" href="print.html#a-better-way-to-resolve-addresses" name="a-better-way-to-resolve-addresses"><h2>A Better Way to Resolve Addresses</h2></a>
<p>If you <em>just</em> want availability and not detailed ping statistics, the <code>std::net::ToSocketAddrs</code> trait
will do any DNS resolution for you:</p>
<pre><pre class="playpen"><code class="language-rust">use std::net::*;

fn main() {
    for res in &quot;google.com:80&quot;.to_socket_addrs().expect(&quot;bad&quot;) {
        println!(&quot;got {:?}&quot;, res);
    }
}
// got V4(216.58.223.14:80)
// got V6([2c0f:fb50:4002:803::200e]:80)
</code></pre></pre>
<p>It's an iterator because there is often more than one interface associated with a domain - there are
both IPV4 and IPV6 interfaces to Google.</p>
<p>So, let's naively use this method to rewrite the pipeliner example. Most networking protocols use both an
address and a port:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate pipeliner;
use pipeliner::Pipeline;

use std::net::*;

fn main() {
    let addresses: Vec&lt;_&gt; = (1..40).map(|n| format!(&quot;192.168.0.{}:0&quot;,n)).collect();
    let n = addresses.len();

    for result in addresses.with_threads(n).map(|s| s.to_socket_addrs()) {
        println!(&quot;got: {:?}&quot;, result);
    }
}
// got: Ok(IntoIter([V4(192.168.0.1:0)]))
// got: Ok(IntoIter([V4(192.168.0.39:0)]))
// got: Ok(IntoIter([V4(192.168.0.2:0)]))
// got: Ok(IntoIter([V4(192.168.0.3:0)]))
// got: Ok(IntoIter([V4(192.168.0.5:0)]))
// ....
</code></pre></pre>
<p>This is much faster than the ping example because it's just checking that the IP address is valid - if we fed
it a list of actual domain names the DNS lookup could take some time, hence the importance of parallelism.</p>
<p>Suprisingly, it sort-of Just Works. The fact that everything in the standard library implements <code>Debug</code>
is great for exploration as well as debugging.  The iterator is returning <code>Result</code> (hence <code>Ok</code>) and
in that <code>Result</code> is an <code>IntoIter</code> into a <code>SocketAddr</code> which is an enum with either a IPV4 or a IPV6 address.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
    for result in addresses.with_threads(n)
        .map(|s| s.to_socket_addrs().unwrap().next().unwrap())
    {
        println!(&quot;got: {:?}&quot;, result);
    }
// got: V4(192.168.0.1:0)
// got: V4(192.168.0.39:0)
// got: V4(192.168.0.3:0)

#}</code></pre></pre>
<p>This also works, surprisingly enough, at least for our simple example. The first <code>unwrap</code> gets rid of
the <code>Result</code>, and then we explicitly pull the first value out of the iterator. The <code>Result</code> will get
bad typically when we give a nonsense address (like an address name without a port.)</p>
<a class="header" href="print.html#tcp-client-server" name="tcp-client-server"><h2>TCP Client Server</h2></a>
<p>Rust provides a straightforward interface to the most commonly used network protocol, TCP.
It is very fault-resistant and is the base on which our networked world is built - <em>packets</em> of
data are sent and received, with acknowledgement. By contrast, UDP sends packets out into the wild
without much error correction - there's a joke that goes &quot;I could tell you a joke about UDP but you
might not get it.&quot;
(Jokes about networking are only funny for a specialized meaning of the word 'funny')</p>
<p>However, error handling is <em>very</em> important with networking, because anything can happen, and will,
eventually.</p>
<p>TCP works as a client/server model; the server listens on a address and a particular <em>network port</em>,
and the client connects to that server. A connection is established and thereafter the client and server
can communicate with a socket.</p>
<p><code>TcpStream::connect</code> takes anything that can convert into a <code>SocketAddr</code>, in particular the plain strings
we have been using.</p>
<p>A simple TCP client in Rust is easy - a <code>TcpStream</code> struct is both readable and writeable. As usual, we
have to bring the <code>Read</code>, <code>Write</code> and other <code>std::io</code> traits into scope:</p>
<pre><pre class="playpen"><code class="language-rust">// client.rs
use std::net::TcpStream;
use std::io::prelude::*;

fn main() {
    let mut stream = TcpStream::connect(&quot;127.0.0.1:8000&quot;).expect(&quot;connection failed&quot;);

    write!(stream,&quot;hello from the client!\n&quot;).expect(&quot;write failed&quot;);
 }
</code></pre></pre>
<p>The server is not much more complicated; we set up a listener and wait for connections. When a
client connects, we get a <code>TcpStream</code> on the server side. In this
case, we read everything that the client has written into a string.</p>
<pre><pre class="playpen"><code class="language-rust">// server.rs
use std::net::TcpListener;
use std::io::prelude::*;

fn main() {

    let listener = TcpListener::bind(&quot;127.0.0.1:8000&quot;).expect(&quot;could not start server&quot;);

    // accept connections and get a TcpStream
    for connection in listener.incoming() {
        match connection {
            Ok(mut stream) =&gt; {
                let mut text = String::new();
                stream.read_to_string(&amp;mut text).expect(&quot;read failed&quot;);
                println!(&quot;got '{}'&quot;, text);
            }
            Err(e) =&gt; { println!(&quot;connection failed {}&quot;, e); }
        }
    }
}
</code></pre></pre>
<p>Here I've chosen a port number moreorless at random, but <a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers">most ports</a>
are assigned some meaning.</p>
<p>Note that both parties have to agree on a protocol - the client expects it can write
text to the stream, and the server expects to read text from the stream.  If they don't play the same
game, then situations can occur where one party is blocked, waiting for bytes that never come.</p>
<p>Error checking is important - network I/O can fail for many reasons, and errors that might appear
once in a blue moon on a local filesystem can happen on a regular basis.
Someone can trip over the network cable, the other party could crash,  and so forth.
This little server isn't very robust, because it will fall over on the first read error.</p>
<p>Here is a more solid server that handles the error without failing. It also specifically reads a <em>line</em>
from the stream, which is done using <code>io::BufReader</code> to create an <code>io::BufRead</code> on which we can call
<code>read_line</code>.</p>
<pre><pre class="playpen"><code class="language-rust">// server2.rs
use std::net::{TcpListener, TcpStream};
use std::io::prelude::*;
use std::io;

fn handle_connection(stream: TcpStream) -&gt; io::Result&lt;()&gt;{
    let mut rdr = io::BufReader::new(stream);
    let mut text = String::new();
    rdr.read_line(&amp;mut text)?;
    println!(&quot;got '{}'&quot;, text.trim_right());
    Ok(())
}

fn main() {

    let listener = TcpListener::bind(&quot;127.0.0.1:8000&quot;).expect(&quot;could not start server&quot;);

    // accept connections and get a TcpStream
    for connection in listener.incoming() {
        match connection {
            Ok(stream) =&gt; {
                if let Err(e) = handle_connection(stream) {
                    println!(&quot;error {:?}&quot;, e);
                }
            }
            Err(e) =&gt; { print!(&quot;connection failed {}\n&quot;, e); }
        }
    }
}
</code></pre></pre>
<p><code>read_line</code> might fail in <code>handle_connection</code>, but the resulting error is safely handled.</p>
<p>One-way communications like this are certainly useful - for instance. a set of services across a
network which want to collect their status reports together in one central place. But it's
reasonable to expect a polite reply, even if just 'ok'!</p>
<p>A simple example is an 'echo' server. The client writes some text ending in a newline to the
server, and receives the same text back with a newline - the stream is readable and writeable.</p>
<pre><pre class="playpen"><code class="language-rust">// client_echo.rs
use std::io::prelude::*;
use std::net::TcpStream;

fn main() {
    let mut stream = TcpStream::connect(&quot;127.0.0.1:8000&quot;).expect(&quot;connection failed&quot;);
    let msg = &quot;hello from the client!&quot;;

    write!(stream,&quot;{}\n&quot;, msg).expect(&quot;write failed&quot;);

    let mut resp = String::new();
    stream.read_to_string(&amp;mut resp).expect(&quot;read failed&quot;);
    let text = resp.trim_right();
    assert_eq!(msg,text);
}
</code></pre></pre>
<p>The server has an interesting twist. Only <code>handle_connection</code> changes:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
# 
#fn main() {
fn handle_connection(stream: TcpStream) -&gt; io::Result&lt;()&gt;{
    let mut ostream = stream.try_clone()?;
    let mut rdr = io::BufReader::new(stream);
    let mut text = String::new();
    rdr.read_line(&amp;mut text)?;
    ostream.write_all(text.as_bytes())?;
    Ok(())
}

#}</code></pre></pre>
<p>This is a common gotcha with simple two-way socket communication; we want to read a line, so
need to feed the readable stream to <code>BufReader</code> - but it <em>consumes</em> the stream! So we have to
clone the stream, creating a new struct which refers to the same underlying socket. Then we
have happiness.</p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
