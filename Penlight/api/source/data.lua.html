<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Penlight Documentation</title>
    <link rel="stylesheet" href="../ldoc_fixed.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Penlight</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Source</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../source/app.lua.html">app.lua</a></li>
  <li><a href="../source/array2d.lua.html">array2d.lua</a></li>
  <li><a href="../source/class.lua.html">class.lua</a></li>
  <li><a href="../source/compat.lua.html">compat.lua</a></li>
  <li><a href="../source/comprehension.lua.html">comprehension.lua</a></li>
  <li><a href="../source/config.lua.html">config.lua</a></li>
  <li><strong>data.lua</strong></li>
  <li><a href="../source/date.lua.html">date.lua</a></li>
  <li><a href="../source/dir.lua.html">dir.lua</a></li>
  <li><a href="../source/file.lua.html">file.lua</a></li>
  <li><a href="../source/func.lua.html">func.lua</a></li>
  <li><a href="../source/import_into.lua.html">import_into.lua</a></li>
  <li><a href="../source/init.lua.html">init.lua</a></li>
  <li><a href="../source/input.lua.html">input.lua</a></li>
  <li><a href="../source/lapp.lua.html">lapp.lua</a></li>
  <li><a href="../source/lexer.lua.html">lexer.lua</a></li>
  <li><a href="../source/list.lua.html">list.lua</a></li>
  <li><a href="../source/luabalanced.lua.html">luabalanced.lua</a></li>
  <li><a href="../source/map.lua.html">map.lua</a></li>
  <li><a href="../source/multimap.lua.html">multimap.lua</a></li>
  <li><a href="../source/operator.lua.html">operator.lua</a></li>
  <li><a href="../source/orderedmap.lua.html">orderedmap.lua</a></li>
  <li><a href="../source/path.lua.html">path.lua</a></li>
  <li><a href="../source/permute.lua.html">permute.lua</a></li>
  <li><a href="../source/pretty.lua.html">pretty.lua</a></li>
  <li><a href="../source/seesubst.lua.html">seesubst.lua</a></li>
  <li><a href="../source/seq.lua.html">seq.lua</a></li>
  <li><a href="../source/set.lua.html">set.lua</a></li>
  <li><a href="../source/sip.lua.html">sip.lua</a></li>
  <li><a href="../source/sipscan.lua.html">sipscan.lua</a></li>
  <li><a href="../source/strict.lua.html">strict.lua</a></li>
  <li><a href="../source/stringio.lua.html">stringio.lua</a></li>
  <li><a href="../source/stringx.lua.html">stringx.lua</a></li>
  <li><a href="../source/symbols.lua.html">symbols.lua</a></li>
  <li><a href="../source/tablex.lua.html">tablex.lua</a></li>
  <li><a href="../source/template.lua.html">template.lua</a></li>
  <li><a href="../source/test-cmp.lua.html">test-cmp.lua</a></li>
  <li><a href="../source/test-data.lua.html">test-data.lua</a></li>
  <li><a href="../source/test-listcallbacks.lua.html">test-listcallbacks.lua</a></li>
  <li><a href="../source/test-pretty.lua.html">test-pretty.lua</a></li>
  <li><a href="../source/test-symbols.lua.html">test-symbols.lua</a></li>
  <li><a href="../source/test.lua.html">test.lua</a></li>
  <li><a href="../source/testapp.lua.html">testapp.lua</a></li>
  <li><a href="../source/testclone.lua.html">testclone.lua</a></li>
  <li><a href="../source/testconfig.lua.html">testconfig.lua</a></li>
  <li><a href="../source/testglobal.lua.html">testglobal.lua</a></li>
  <li><a href="../source/testinputfields.lua.html">testinputfields.lua</a></li>
  <li><a href="../source/testinputfields2.lua.html">testinputfields2.lua</a></li>
  <li><a href="../source/testxml.lua.html">testxml.lua</a></li>
  <li><a href="../source/text.lua.html">text.lua</a></li>
  <li><a href="../source/types.lua.html">types.lua</a></li>
  <li><a href="../source/url.lua.html">url.lua</a></li>
  <li><a href="../source/utils.lua.html">utils.lua</a></li>
  <li><a href="../source/which.lua.html">which.lua</a></li>
  <li><a href="../source/xml.lua.html">xml.lua</a></li>
</ul>
<h2>Libraries</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../libraries/pl.html">pl</a></li>
  <li><a href="../libraries/pl.app.html">pl.app</a></li>
  <li><a href="../libraries/pl.array2d.html">pl.array2d</a></li>
  <li><a href="../libraries/pl.class.html">pl.class</a></li>
  <li><a href="../libraries/pl.compat.html">pl.compat</a></li>
  <li><a href="../libraries/pl.comprehension.html">pl.comprehension</a></li>
  <li><a href="../libraries/pl.config.html">pl.config</a></li>
  <li><a href="../libraries/pl.data.html">pl.data</a></li>
  <li><a href="../libraries/pl.dir.html">pl.dir</a></li>
  <li><a href="../libraries/pl.file.html">pl.file</a></li>
  <li><a href="../libraries/pl.func.html">pl.func</a></li>
  <li><a href="../libraries/pl.import_into.html">pl.import_into</a></li>
  <li><a href="../libraries/pl.input.html">pl.input</a></li>
  <li><a href="../libraries/pl.lapp.html">pl.lapp</a></li>
  <li><a href="../libraries/pl.lexer.html">pl.lexer</a></li>
  <li><a href="../libraries/pl.luabalanced.html">pl.luabalanced</a></li>
  <li><a href="../libraries/pl.operator.html">pl.operator</a></li>
  <li><a href="../libraries/pl.path.html">pl.path</a></li>
  <li><a href="../libraries/pl.permute.html">pl.permute</a></li>
  <li><a href="../libraries/pl.pretty.html">pl.pretty</a></li>
  <li><a href="../libraries/pl.seq.html">pl.seq</a></li>
  <li><a href="../libraries/pl.sip.html">pl.sip</a></li>
  <li><a href="../libraries/pl.strict.html">pl.strict</a></li>
  <li><a href="../libraries/pl.stringio.html">pl.stringio</a></li>
  <li><a href="../libraries/pl.stringx.html">pl.stringx</a></li>
  <li><a href="../libraries/pl.tablex.html">pl.tablex</a></li>
  <li><a href="../libraries/pl.template.html">pl.template</a></li>
  <li><a href="../libraries/pl.test.html">pl.test</a></li>
  <li><a href="../libraries/pl.text.html">pl.text</a></li>
  <li><a href="../libraries/pl.types.html">pl.types</a></li>
  <li><a href="../libraries/pl.url.html">pl.url</a></li>
  <li><a href="../libraries/pl.utils.html">pl.utils</a></li>
  <li><a href="../libraries/pl.xml.html">pl.xml</a></li>
</ul>
<h2>Classes</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../classes/pl.Date.html">pl.Date</a></li>
  <li><a href="../classes/pl.List.html">pl.List</a></li>
  <li><a href="../classes/pl.Map.html">pl.Map</a></li>
  <li><a href="../classes/pl.MultiMap.html">pl.MultiMap</a></li>
  <li><a href="../classes/pl.OrderedMap.html">pl.OrderedMap</a></li>
  <li><a href="../classes/pl.Set.html">pl.Set</a></li>
</ul>
<h2>Manual</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../manual/01-introduction.md.html">Introduction</a></li>
  <li><a href="../manual/02-arrays.md.html">Tables and Arrays</a></li>
  <li><a href="../manual/03-strings.md.html">Strings. Higher-level operations on strings.</a></li>
  <li><a href="../manual/04-paths.md.html">Paths and Directories</a></li>
  <li><a href="../manual/05-dates.md.html">Date and Time</a></li>
  <li><a href="../manual/06-data.md.html">Data</a></li>
  <li><a href="../manual/07-functional.md.html">Functional Programming</a></li>
  <li><a href="../manual/08-additional.md.html">Additional Libraries</a></li>
  <li><a href="../manual/09-discussion.md.html">Technical Choices</a></li>
</ul>
<h2>Examples</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../examples/seesubst.lua.html">seesubst.lua</a></li>
  <li><a href="../examples/sipscan.lua.html">sipscan.lua</a></li>
  <li><a href="../examples/symbols.lua.html">symbols.lua</a></li>
  <li><a href="../examples/test-cmp.lua.html">test-cmp.lua</a></li>
  <li><a href="../examples/test-data.lua.html">test-data.lua</a></li>
  <li><a href="../examples/test-listcallbacks.lua.html">test-listcallbacks.lua</a></li>
  <li><a href="../examples/test-pretty.lua.html">test-pretty.lua</a></li>
  <li><a href="../examples/test-symbols.lua.html">test-symbols.lua</a></li>
  <li><a href="../examples/testapp.lua.html">testapp.lua</a></li>
  <li><a href="../examples/testclone.lua.html">testclone.lua</a></li>
  <li><a href="../examples/testconfig.lua.html">testconfig.lua</a></li>
  <li><a href="../examples/testglobal.lua.html">testglobal.lua</a></li>
  <li><a href="../examples/testinputfields.lua.html">testinputfields.lua</a></li>
  <li><a href="../examples/testinputfields2.lua.html">testinputfields2.lua</a></li>
  <li><a href="../examples/testxml.lua.html">testxml.lua</a></li>
  <li><a href="../examples/which.lua.html">which.lua</a></li>
</ul>

</div>

<div id="content">

    <h2>data.lua</h2>
<pre>
<span class="comment">--- Reading and querying simple tabular data.
</span><span class="comment">--
</span><span class="comment">--    data.read 'test.txt'
</span><span class="comment">--    ==&gt; {{10,20},{2,5},{40,50},fieldnames={'x','y'},delim=','}
</span><span class="comment">--
</span><span class="comment">-- Provides a way of creating basic SQL-like queries.
</span><span class="comment">--
</span><span class="comment">--    require 'pl'
</span><span class="comment">--    local d = data.read('xyz.txt')
</span><span class="comment">--    local q = d:select('x,y,z where x &gt; 3 and z &lt; 2 sort by y')
</span><span class="comment">--    for x,y,z in q do
</span><span class="comment">--        print(x,y,z)
</span><span class="comment">--    end
</span><span class="comment">--
</span><span class="comment">-- See <a href="../manual/06-data.md.html#Reading_Columnar_Data">the Guide</a>
</span><span class="comment">--
</span><span class="comment">-- Dependencies: <a href="../libraries/pl.utils.html#">pl.utils</a>, <a href="../libraries/pl.array2d.html#">pl.array2d</a> (fallback methods)
</span><span class="comment">-- @module pl.data
</span>
<span class="keyword">local</span> utils = <span class="global">require</span> <span class="string">'pl.utils'</span>
<span class="keyword">local</span> _DEBUG = <span class="global">rawget</span>(_G,<span class="string">'_DEBUG'</span>)

<span class="keyword">local</span> patterns,function_arg,usplit,array_tostring = utils.patterns,utils.function_arg,utils.split,utils.array_tostring
<span class="keyword">local</span> append,concat = <span class="global">table</span>.insert,<span class="global">table</span>.concat
<span class="keyword">local</span> gsub = <span class="global">string</span>.gsub
<span class="keyword">local</span> <span class="global">io</span> = <span class="global">io</span>
<span class="keyword">local</span> _G,<span class="global">print</span>,<span class="global">type</span>,<span class="global">tonumber</span>,<span class="global">ipairs</span>,<span class="global">setmetatable</span>,<span class="global">pcall</span>,error = _G,<span class="global">print</span>,<span class="global">type</span>,<span class="global">tonumber</span>,<span class="global">ipairs</span>,<span class="global">setmetatable</span>,<span class="global">pcall</span>,error


<span class="keyword">local</span> data = {}

<span class="keyword">local</span> parse_select

<span class="keyword">local</span> <span class="keyword">function</span> count(s,chr)
    chr = utils.escape(chr)
    <span class="keyword">local</span> _,cnt = s:gsub(chr,<span class="string">' '</span>)
    <span class="keyword">return</span> cnt
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> rstrip(s)
    <span class="keyword">return</span> (s:gsub(<span class="string">'%s+$'</span>,<span class="string">''</span>))
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> strip (s)
    <span class="keyword">return</span> (rstrip(s):gsub(<span class="string">'^%s*'</span>,<span class="string">''</span>))
<span class="keyword">end</span>

<span class="comment">-- this gives <code>l</code> the standard List metatable, so that if you
</span><span class="comment">-- do choose to pull in pl.List, you can use its methods on such lists.
</span><span class="keyword">local</span> <span class="keyword">function</span> make_list(l)
    <span class="keyword">return</span> <span class="global">setmetatable</span>(l,utils.stdmt.List)
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> map(fun,t)
    <span class="keyword">local</span> res = {}
    <span class="keyword">for</span> i = <span class="number">1</span>,#t <span class="keyword">do</span>
        res[i] = fun(t[i])
    <span class="keyword">end</span>
    <span class="keyword">return</span> res
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> split(line,delim,csv,n)
    <span class="keyword">local</span> massage
    <span class="comment">-- CSV fields may be double-quoted and may contain commas!
</span>    <span class="keyword">if</span> csv <span class="keyword">and</span> line:match <span class="string">'"'</span> <span class="keyword">then</span>
        line = line:gsub(<span class="string">'"([^"]+)"'</span>,<span class="keyword">function</span>(str)
            <span class="keyword">local</span> s,cnt = str:gsub(<span class="string">','</span>,<span class="string">'\001'</span>)
            <span class="keyword">if</span> cnt &gt; <span class="number">0</span> <span class="keyword">then</span> massage = <span class="keyword">true</span> <span class="keyword">end</span>
            <span class="keyword">return</span> s
        <span class="keyword">end</span>)
        <span class="keyword">if</span> massage <span class="keyword">then</span>
            massage = <span class="keyword">function</span>(s) <span class="keyword">return</span> (s:gsub(<span class="string">'\001'</span>,<span class="string">','</span>)) <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">local</span> res = (usplit(line,delim,<span class="keyword">false</span>,n))
    <span class="keyword">if</span> csv <span class="keyword">then</span>
        <span class="comment">-- restore CSV commas-in-fields
</span>        <span class="keyword">if</span> massage <span class="keyword">then</span> res = map(massage,res) <span class="keyword">end</span>
        <span class="comment">-- in CSV mode trailiing commas are significant!
</span>        <span class="keyword">if</span> line:match <span class="string">',$'</span> <span class="keyword">then</span> append(res,<span class="string">''</span>) <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> make_list(res)
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> find(t,v)
    <span class="keyword">for</span> i = <span class="number">1</span>,#t <span class="keyword">do</span>
        <span class="keyword">if</span> v == t[i] <span class="keyword">then</span> <span class="keyword">return</span> i <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">local</span> DataMT = {
    column_by_name = <span class="keyword">function</span>(self,name)
        <span class="keyword">if</span> <span class="global">type</span>(name) == <span class="string">'number'</span> <span class="keyword">then</span>
            name = <span class="string">'$'</span>..name
        <span class="keyword">end</span>
        <span class="keyword">local</span> arr = {}
        <span class="keyword">for</span> res <span class="keyword">in</span> data.query(self,name) <span class="keyword">do</span>
            append(arr,res)
        <span class="keyword">end</span>
        <span class="keyword">return</span> make_list(arr)
    <span class="keyword">end</span>,

    copy_select = <span class="keyword">function</span>(self,condn)
        condn = parse_select(condn,self)
        <span class="keyword">local</span> iter = data.query(self,condn)
        <span class="keyword">local</span> res = {}
        <span class="keyword">local</span> row = make_list{iter()}
        <span class="keyword">while</span> #row &gt; <span class="number">0</span> <span class="keyword">do</span>
            append(res,row)
            row = make_list{iter()}
        <span class="keyword">end</span>
        res.delim = self.delim
        <span class="keyword">return</span> data.new(res,split(condn.fields,<span class="string">','</span>))
    <span class="keyword">end</span>,

    column_names = <span class="keyword">function</span>(self)
        <span class="keyword">return</span> self.fieldnames
    <span class="keyword">end</span>,
}

<span class="keyword">local</span> array2d

DataMT.__index = <span class="keyword">function</span>(self,name)
    <span class="keyword">local</span> f = DataMT[name]
    <span class="keyword">if</span> f <span class="keyword">then</span> <span class="keyword">return</span> f <span class="keyword">end</span>
    <span class="keyword">if</span> <span class="keyword">not</span> array2d <span class="keyword">then</span>
        array2d = <span class="global">require</span> <span class="string">'pl.array2d'</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> array2d[name]
<span class="keyword">end</span>

<span class="comment">--- return a particular column as a list of values (method).
</span><span class="comment">-- @param name either name of column, or numerical index.
</span><span class="comment">-- @function Data.column_by_name
</span><a id="136"></a>
<span class="comment">--- return a query iterator on this data (method).
</span><span class="comment">-- @string condn the query expression
</span><span class="comment">-- @function Data.select
</span><span class="comment">-- @see data.query
</span><a id="141"></a>
<span class="comment">--- return a row iterator on this data (method).
</span><span class="comment">-- @string condn the query expression
</span><span class="comment">-- @function Data.select_row
</span><a id="145"></a>
<span class="comment">--- return a new data object based on this query (method).
</span><span class="comment">-- @string condn the query expression
</span><span class="comment">-- @function Data.copy_select
</span><a id="149"></a>
<span class="comment">--- return the field names of this data object (method).
</span><span class="comment">-- @function Data.column_names
</span><a id="152"></a>
<span class="comment">--- write out a row (method).
</span><span class="comment">-- @param f file-like object
</span><span class="comment">-- @function Data.write_row
</span><a id="156"></a>
<span class="comment">--- write data out to file (method).
</span><span class="comment">-- @param f file-like object
</span><span class="comment">-- @function Data.write
</span><a id="161"></a>

<span class="comment">-- [guessing delimiter] We check for comma, tab and spaces in that order.
</span><span class="comment">-- [issue] any other delimiters to be checked?
</span><span class="keyword">local</span> delims = {<span class="string">','</span>,<span class="string">'\t'</span>,<span class="string">' '</span>,<span class="string">';'</span>}

<span class="keyword">local</span> <span class="keyword">function</span> guess_delim (line)
    <span class="keyword">if</span> line==<span class="string">''</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="string">' '</span> <span class="keyword">end</span>
    <span class="keyword">for</span> _,delim <span class="keyword">in</span> <span class="global">ipairs</span>(delims) <span class="keyword">do</span>
        <span class="keyword">if</span> count(line,delim) &gt; <span class="number">0</span> <span class="keyword">then</span>
            <span class="keyword">return</span> delim == <span class="string">' '</span> <span class="keyword">and</span> <span class="string">'%s+'</span> <span class="keyword">or</span> delim
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="string">' '</span>
<span class="keyword">end</span>

<span class="comment">-- [file parameter] If it's a string, we try open as a filename. If nil, then
</span><span class="comment">-- either stdin or stdout depending on the mode. Otherwise, check if this is
</span><span class="comment">-- a file-like object (implements read or write depending)
</span><span class="keyword">local</span> <span class="keyword">function</span> open_file (f,mode)
    <span class="keyword">local</span> opened, err
    <span class="keyword">local</span> reading = mode == <span class="string">'r'</span>
    <span class="keyword">if</span> <span class="global">type</span>(f) == <span class="string">'string'</span> <span class="keyword">then</span>
        <span class="keyword">if</span> f == <span class="string">'stdin'</span>  <span class="keyword">then</span>
            f = <span class="global">io</span>.stdin
        <span class="keyword">elseif</span> f == <span class="string">'stdout'</span>  <span class="keyword">then</span>
            f = <span class="global">io</span>.stdout
        <span class="keyword">else</span>
            f,err = <span class="global">io</span>.open(f,mode)
            <span class="keyword">if</span> <span class="keyword">not</span> f <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span>,err <span class="keyword">end</span>
            opened = <span class="keyword">true</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> f <span class="keyword">and</span> ((reading <span class="keyword">and</span> <span class="keyword">not</span> f.read) <span class="keyword">or</span> (<span class="keyword">not</span> reading <span class="keyword">and</span> <span class="keyword">not</span> f.write)) <span class="keyword">then</span>
        <span class="keyword">return</span> <span class="keyword">nil</span>, <span class="string">"not a file-like object"</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> f,<span class="keyword">nil</span>,opened
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> all_n ()

<span class="keyword">end</span>

<span class="comment">--- read a delimited file in a Lua table.
</span><span class="comment">-- By default, attempts to treat first line as separated list of fieldnames.
</span><span class="comment">-- @param file a filename or a file-like object (default stdin)
</span><span class="comment">-- @tab cnfg options table: can override <code>delim</code> (a string pattern), <code>fieldnames</code> (a list),
</span><span class="comment">-- specify <code>no_convert</code> (default is to conversion), <code>numfields</code> (indices of columns known
</span><span class="comment">-- to be numbers) and <code>thousands_dot</code> (thousands separator in Excel CSV is '.').
</span><span class="comment">-- If <code>csv</code> is set then fields may be double-quoted and contain commas;
</span><span class="comment">-- @return <a href="../libraries/pl.data.html#">data</a> object, or <code>nil</code>
</span><span class="comment">-- @return error message. May be a file error, 'not a file-like object'
</span><a id="212"></a><span class="comment">-- or a conversion error
</span><span class="keyword">function</span> data.read(file,cnfg)
    <span class="keyword">local</span> err,opened,count,line,csv
    <span class="keyword">local</span> D = {}
    <span class="keyword">if</span> <span class="keyword">not</span> cnfg <span class="keyword">then</span> cnfg = {} <span class="keyword">end</span>
    <span class="keyword">local</span> f,err,opened = open_file(file,<span class="string">'r'</span>)
    <span class="keyword">if</span> <span class="keyword">not</span> f <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span>, err <span class="keyword">end</span>
    <span class="keyword">local</span> thousands_dot = cnfg.thousands_dot

    <span class="comment">-- note that using dot as the thousands separator (@thousands_dot)
</span>    <span class="comment">-- requires a special conversion function!
</span>    <span class="keyword">local</span> <span class="global">tonumber</span> = <span class="global">tonumber</span>
    <span class="keyword">local</span> <span class="keyword">function</span> try_number(x)
        <span class="keyword">if</span> thousands_dot <span class="keyword">then</span> x = x:gsub(<span class="string">'%.(...)'</span>,<span class="string">'%1'</span>) <span class="keyword">end</span>
        <span class="keyword">local</span> v = <span class="global">tonumber</span>(x)
        <span class="keyword">if</span> v == <span class="keyword">nil</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span>,<span class="string">"not a number"</span> <span class="keyword">end</span>
        <span class="keyword">return</span> v
    <span class="keyword">end</span>

    csv = cnfg.csv
    <span class="keyword">if</span> csv <span class="keyword">then</span> cnfg.delim = <span class="string">','</span> <span class="keyword">end</span>
    count = <span class="number">1</span>
    line = f:read()
    <span class="keyword">if</span> <span class="keyword">not</span> line <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span>, <span class="string">"empty file"</span> <span class="keyword">end</span>

    <span class="comment">-- first question: what is the delimiter?
</span>    D.delim = cnfg.delim <span class="keyword">and</span> cnfg.delim <span class="keyword">or</span> guess_delim(line)
    <span class="keyword">local</span> delim = D.delim

    <span class="keyword">local</span> conversion
    <span class="keyword">local</span> numfields = {}
    <span class="keyword">local</span> <span class="keyword">function</span> append_conversion (idx,conv)
        conversion = conversion <span class="keyword">or</span> {}
        append(numfields,idx)
        append(conversion,conv)
    <span class="keyword">end</span>
    <span class="keyword">if</span> cnfg.numfields <span class="keyword">then</span>
        <span class="keyword">for</span> _,n <span class="keyword">in</span> <span class="global">ipairs</span>(cnfg.numfields) <span class="keyword">do</span> append_conversion(n,try_number) <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">-- some space-delimited data starts with a space.  This should not be a column,
</span>    <span class="comment">-- although it certainly would be for comma-separated, etc.
</span>    <span class="keyword">local</span> stripper
    <span class="keyword">if</span> delim == <span class="string">'%s+'</span> <span class="keyword">and</span> line:find(delim) == <span class="number">1</span> <span class="keyword">then</span>
        stripper = <span class="keyword">function</span>(s)  <span class="keyword">return</span> s:gsub(<span class="string">'^%s+'</span>,<span class="string">''</span>) <span class="keyword">end</span>
        line = stripper(line)
    <span class="keyword">end</span>
    <span class="comment">-- first line will usually be field names. Unless fieldnames are specified,
</span>    <span class="comment">-- we check if it contains purely numerical values for the case of reading
</span>    <span class="comment">-- plain data files.
</span>    <span class="keyword">if</span> <span class="keyword">not</span> cnfg.fieldnames <span class="keyword">then</span>
        <span class="keyword">local</span> fields,nums
        fields = split(line,delim,csv)
        <span class="keyword">if</span> <span class="keyword">not</span> cnfg.convert <span class="keyword">then</span>
            nums = map(<span class="global">tonumber</span>,fields)
            <span class="keyword">if</span> #nums == #fields <span class="keyword">then</span> <span class="comment">-- they're ALL numbers!
</span>                append(D,nums) <span class="comment">-- add the first converted row
</span>                <span class="comment">-- and specify conversions for subsequent rows
</span>                <span class="keyword">for</span> i = <span class="number">1</span>,#nums <span class="keyword">do</span> append_conversion(i,try_number) <span class="keyword">end</span>
            <span class="keyword">else</span> <span class="comment">-- we'll try to check numbers just now..
</span>                nums = <span class="keyword">nil</span>
            <span class="keyword">end</span>
        <span class="keyword">else</span> <span class="comment">-- [explicit column conversions] (any deduced number conversions will be added)
</span>            <span class="keyword">for</span> idx,conv <span class="keyword">in</span> <span class="global">pairs</span>(cnfg.convert) <span class="keyword">do</span> append_conversion(idx,conv) <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span> nums == <span class="keyword">nil</span> <span class="keyword">then</span>
            cnfg.fieldnames = fields
        <span class="keyword">end</span>
        line = f:read()
        count = count + <span class="number">1</span>
        <span class="keyword">if</span> stripper <span class="keyword">then</span> line = stripper(line) <span class="keyword">end</span>
    <span class="keyword">elseif</span> <span class="global">type</span>(cnfg.fieldnames) == <span class="string">'string'</span> <span class="keyword">then</span>
        cnfg.fieldnames = split(cnfg.fieldnames,delim,csv)
    <span class="keyword">end</span>
    <span class="keyword">local</span> nfields
    <span class="comment">-- at this point, the column headers have been read in. If the first
</span>    <span class="comment">-- row consisted of numbers, it has already been added to the dataset.
</span>    <span class="keyword">if</span> cnfg.fieldnames <span class="keyword">then</span>
        D.fieldnames = cnfg.fieldnames
        <span class="comment">-- [collecting end field] If @last_field_collect then we'll
</span>        <span class="comment">-- only split as many fields as there are fieldnames
</span>        <span class="keyword">if</span> cnfg.last_field_collect <span class="keyword">then</span>
            nfields = #D.fieldnames
        <span class="keyword">end</span>
        <span class="comment">-- [implicit column conversion] unless @no_convert, we need the numerical field indices
</span>        <span class="comment">-- of the first data row. These can also be specified explicitly by @numfields.
</span>        <span class="keyword">if</span> <span class="keyword">not</span> cnfg.no_convert <span class="keyword">then</span>
            <span class="keyword">local</span> fields = split(line,D.delim,csv,nfields)
            <span class="keyword">for</span> i = <span class="number">1</span>,#fields <span class="keyword">do</span>
                <span class="keyword">if</span> <span class="keyword">not</span> find(numfields,i) <span class="keyword">and</span> <span class="global">tonumber</span>(fields[i]) <span class="keyword">then</span>
                    append_conversion(i,try_number)
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="comment">-- keep going until finished
</span>    <span class="keyword">while</span> line <span class="keyword">do</span>
        <span class="keyword">if</span> <span class="keyword">not</span> line:find (<span class="string">'^%s*$'</span>) <span class="keyword">then</span> <span class="comment">-- [blank lines] ignore them!
</span>            <span class="keyword">if</span> stripper <span class="keyword">then</span> line = stripper(line) <span class="keyword">end</span>
            <span class="keyword">local</span> fields = split(line,delim,csv,nfields)
            <span class="keyword">if</span> conversion <span class="keyword">then</span> <span class="comment">-- there were field conversions...
</span>                <span class="keyword">for</span> k = <span class="number">1</span>,#numfields <span class="keyword">do</span>
                    <span class="keyword">local</span> i,conv = numfields[k],conversion[k]
                    <span class="keyword">local</span> val,err = conv(fields[i])
                    <span class="keyword">if</span> val == <span class="keyword">nil</span> <span class="keyword">then</span>
                        <span class="keyword">return</span> <span class="keyword">nil</span>, err..<span class="string">": "</span>..fields[i]..<span class="string">" at line "</span>..count
                    <span class="keyword">else</span>
                        fields[i] = val
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            append(D,fields)
        <span class="keyword">end</span>
        line = f:read()
        count = count + <span class="number">1</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> opened <span class="keyword">then</span> f:close() <span class="keyword">end</span>
    <span class="keyword">if</span> delim == <span class="string">'%s+'</span> <span class="keyword">then</span> D.delim = <span class="string">' '</span> <span class="keyword">end</span>
    <span class="keyword">if</span> <span class="keyword">not</span> D.fieldnames <span class="keyword">then</span> D.fieldnames = {} <span class="keyword">end</span>
    <span class="keyword">return</span> data.new(D)
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> write_row (data,f,row,delim)
    data.temp = array_tostring(row,data.temp)
    f:write(concat(data.temp,delim),<span class="string">'\n'</span>)
<span class="keyword">end</span>

<span class="keyword">function</span> DataMT:write_row(f,row)
    write_row(self,f,row,self.delim)
<span class="keyword">end</span>

<span class="comment">--- write 2D data to a file.
</span><span class="comment">-- Does not assume that the data has actually been
</span><span class="comment">-- generated with <code>new</code> or <code>read</code>.
</span><span class="comment">-- @param data 2D array
</span><span class="comment">-- @param file filename or file-like object
</span><span class="comment">-- @tparam[opt] {string} fieldnames list of fields (optional)
</span><a id="349"></a><span class="comment">-- @string[opt='\t'] delim delimiter (default tab)
</span><span class="keyword">function</span> data.write (data,file,fieldnames,delim)
    <span class="keyword">local</span> f,err,opened = open_file(file,<span class="string">'w'</span>)
    <span class="keyword">if</span> <span class="keyword">not</span> f <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span>, err <span class="keyword">end</span>
    <span class="keyword">if</span> fieldnames <span class="keyword">and</span> #fieldnames &gt; <span class="number">0</span> <span class="keyword">then</span>
        f:write(concat(data.fieldnames,delim),<span class="string">'\n'</span>)
    <span class="keyword">end</span>
    delim = delim <span class="keyword">or</span> <span class="string">'\t'</span>
    <span class="keyword">for</span> i = <span class="number">1</span>,#data <span class="keyword">do</span>
        write_row(data,f,data[i],delim)
    <span class="keyword">end</span>
    <span class="keyword">if</span> opened <span class="keyword">then</span> f:close() <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="keyword">function</span> DataMT:write(file)
    data.write(self,file,self.fieldnames,self.delim)
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> massage_fieldnames (fields,copy)
    <span class="comment">-- fieldnames must be valid Lua identifiers; ignore any surrounding padding
</span>    <span class="comment">-- but keep the original fieldnames...
</span>    <span class="keyword">for</span> i = <span class="number">1</span>,#fields <span class="keyword">do</span>
        <span class="keyword">local</span> f = strip(fields[i])
        copy[i] = f
        fields[i] = f:gsub(<span class="string">'%W'</span>,<span class="string">'_'</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- create a new dataset from a table of rows.
</span><span class="comment">-- Can specify the fieldnames, else the table must have a field called
</span><span class="comment">-- 'fieldnames', which is either a string of delimiter-separated names,
</span><span class="comment">-- or a table of names. &lt;br&gt;
</span><span class="comment">-- If the table does not have a field called 'delim', then an attempt will be
</span><span class="comment">-- made to guess it from the fieldnames string, defaults otherwise to tab.
</span><span class="comment">-- @param d the table.
</span><span class="comment">-- @tparam[opt] {string} fieldnames optional fieldnames
</span><a id="386"></a><span class="comment">-- @return the table.
</span><span class="keyword">function</span> data.new (d,fieldnames)
    d.fieldnames = d.fieldnames <span class="keyword">or</span> fieldnames <span class="keyword">or</span> <span class="string">''</span>
    <span class="keyword">if</span> <span class="keyword">not</span> d.delim <span class="keyword">and</span> <span class="global">type</span>(d.fieldnames) == <span class="string">'string'</span> <span class="keyword">then</span>
        d.delim = guess_delim(d.fieldnames)
        d.fieldnames = split(d.fieldnames,d.delim)
    <span class="keyword">end</span>
    d.fieldnames = make_list(d.fieldnames)
    d.original_fieldnames = {}
    massage_fieldnames(d.fieldnames,d.original_fieldnames)
    <span class="global">setmetatable</span>(d,DataMT)
    <span class="comment">-- a query with just the fieldname will return a sequence
</span>    <span class="comment">-- of values, which seq.copy turns into a table.
</span>    <span class="keyword">return</span> d
<span class="keyword">end</span>

<span class="keyword">local</span> sorted_query = <span class="string">[[
return function (t)
    local i = 0
    local v
    local ls = {}
    for i,v in ipairs(t) do
        if CONDITION then
            ls[#ls+1] = v
        end
    end
    table.sort(ls,function(v1,v2)
        return SORT_EXPR
    end)
    local n = #ls
    return function()
        i = i + 1
        v = ls[i]
        if i &gt; n then return end
        return FIELDLIST
    end
end
]]</span>

<span class="comment">-- question: is this optimized case actually worth the extra code?
</span><span class="keyword">local</span> simple_query = <span class="string">[[
return function (t)
    local n = #t
    local i = 0
    local v
    return function()
        repeat
            i = i + 1
            v = t[i]
        until i &gt; n or CONDITION
        if i &gt; n then return end
        return FIELDLIST
    end
end
]]</span>

<span class="keyword">local</span> <span class="keyword">function</span> is_string (s)
    <span class="keyword">return</span> <span class="global">type</span>(s) == <span class="string">'string'</span>
<span class="keyword">end</span>

<span class="keyword">local</span> field_error

<span class="keyword">local</span> <span class="keyword">function</span> fieldnames_as_string (data)
    <span class="keyword">return</span> concat(data.fieldnames,<span class="string">','</span>)
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> massage_fields(data,f)
    <span class="keyword">local</span> idx
    <span class="keyword">if</span> f:find <span class="string">'^%d+$'</span> <span class="keyword">then</span>
        idx = <span class="global">tonumber</span>(f)
    <span class="keyword">else</span>
        idx = find(data.fieldnames,f)
    <span class="keyword">end</span>
    <span class="keyword">if</span> idx <span class="keyword">then</span>
        <span class="keyword">return</span> <span class="string">'v['</span>..idx..<span class="string">']'</span>
    <span class="keyword">else</span>
        field_error = f..<span class="string">' not found in '</span>..fieldnames_as_string(data)
        <span class="keyword">return</span> f
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="keyword">local</span> <span class="keyword">function</span> process_select (data,parms)
    <span class="comment">--- preparing fields ----
</span>    <span class="keyword">local</span> res,ret
    field_error = <span class="keyword">nil</span>
    <span class="keyword">local</span> fields = parms.fields
    <span class="keyword">local</span> numfields = fields:find <span class="string">'%$'</span>  <span class="keyword">or</span> #data.fieldnames == <span class="number">0</span>
    <span class="keyword">if</span> fields:find <span class="string">'^%s*%*%s*'</span> <span class="keyword">then</span>
        <span class="keyword">if</span> <span class="keyword">not</span> numfields <span class="keyword">then</span>
            fields = fieldnames_as_string(data)
        <span class="keyword">else</span>
            <span class="keyword">local</span> ncol = #data[<span class="number">1</span>]
            fields = {}
            <span class="keyword">for</span> i = <span class="number">1</span>,ncol <span class="keyword">do</span> append(fields,<span class="string">'$'</span>..i) <span class="keyword">end</span>
            fields = concat(fields,<span class="string">','</span>)
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">local</span> idpat = patterns.IDEN
    <span class="keyword">if</span> numfields <span class="keyword">then</span>
        idpat = <span class="string">'%$(%d+)'</span>
    <span class="keyword">else</span>
        <span class="comment">-- massage field names to replace non-identifier chars
</span>        fields = rstrip(fields):gsub(<span class="string">'[^,%w]'</span>,<span class="string">'_'</span>)
    <span class="keyword">end</span>
    <span class="keyword">local</span> massage_fields = utils.bind1(massage_fields,data)
    ret = gsub(fields,idpat,massage_fields)
    <span class="keyword">if</span> field_error <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span>,field_error <span class="keyword">end</span>
    parms.fields = fields
    parms.proc_fields = ret
    parms.where = parms.where <span class="keyword">or</span>  <span class="string">'true'</span>
    <span class="keyword">if</span> is_string(parms.where) <span class="keyword">then</span>
        parms.where = gsub(parms.where,idpat,massage_fields)
        field_error = <span class="keyword">nil</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="keyword">true</span>
<span class="keyword">end</span>


parse_select = <span class="keyword">function</span>(s,data)
    <span class="keyword">local</span> endp
    <span class="keyword">local</span> parms = {}
    <span class="keyword">local</span> w1,w2 = s:find(<span class="string">'where '</span>)
    <span class="keyword">local</span> s1,s2 = s:find(<span class="string">'sort by '</span>)
    <span class="keyword">if</span> w1 <span class="keyword">then</span> <span class="comment">-- where clause!
</span>        endp = (s1 <span class="keyword">or</span> <span class="number">0</span>)-<span class="number">1</span>
        parms.where = s:sub(w2+<span class="number">1</span>,endp)
    <span class="keyword">end</span>
    <span class="keyword">if</span> s1 <span class="keyword">then</span> <span class="comment">-- sort by clause (must be last!)
</span>        parms.sort_by = s:sub(s2+<span class="number">1</span>)
    <span class="keyword">end</span>
    endp = (w1 <span class="keyword">or</span> s1 <span class="keyword">or</span> <span class="number">0</span>)-<span class="number">1</span>
    parms.fields = s:sub(<span class="number">1</span>,endp)
    <span class="keyword">local</span> status,err = process_select(data,parms)
    <span class="keyword">if</span> <span class="keyword">not</span> status <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span>,err
    <span class="keyword">else</span> <span class="keyword">return</span> parms <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- create a query iterator from a select string.
</span><span class="comment">-- Select string has this format: &lt;br&gt;
</span><span class="comment">-- FIELDLIST [ where LUA-CONDN [ sort by FIELD] ]&lt;br&gt;
</span><span class="comment">-- FIELDLIST is a comma-separated list of valid fields, or '*'. &lt;br&gt; &lt;br&gt;
</span><span class="comment">-- The condition can also be a table, with fields 'fields' (comma-sep string or
</span><span class="comment">-- table), 'sort_by' (string) and 'where' (Lua expression string or function)
</span><span class="comment">-- @param data table produced by read
</span><span class="comment">-- @param condn select string or table
</span><span class="comment">-- @param context a list of tables to be searched when resolving functions
</span><span class="comment">-- @param return_row if true, wrap the results in a row table
</span><span class="comment">-- @return an iterator over the specified fields, or nil
</span><span class="comment">-- @return an error message
</span><span class="keyword">function</span> data.query(data,condn,context,return_row)
    <span class="keyword">local</span> err
    <span class="keyword">if</span> is_string(condn) <span class="keyword">then</span>
        condn,err = parse_select(condn,data)
        <span class="keyword">if</span> <span class="keyword">not</span> condn <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span>,err <span class="keyword">end</span>
    <span class="keyword">elseif</span> <span class="global">type</span>(condn) == <span class="string">'table'</span> <span class="keyword">then</span>
        <span class="keyword">if</span> <span class="global">type</span>(condn.fields) == <span class="string">'table'</span> <span class="keyword">then</span>
            condn.fields = concat(condn.fields,<span class="string">','</span>)
        <span class="keyword">end</span>
        <span class="keyword">if</span> <span class="keyword">not</span> condn.proc_fields <span class="keyword">then</span>
            <span class="keyword">local</span> status,err = process_select(data,condn)
            <span class="keyword">if</span> <span class="keyword">not</span> status <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span>,err <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="keyword">nil</span>, <span class="string">"condition must be a string or a table"</span>
    <span class="keyword">end</span>
    <span class="keyword">local</span> query, k
    <span class="keyword">if</span> condn.sort_by <span class="keyword">then</span> <span class="comment">-- use sorted_query
</span>        query = sorted_query
    <span class="keyword">else</span>
        query = simple_query
    <span class="keyword">end</span>
    <span class="keyword">local</span> fields = condn.proc_fields <span class="keyword">or</span> condn.fields
    <span class="keyword">if</span> return_row <span class="keyword">then</span>
        fields = <span class="string">'{'</span>..fields..<span class="string">'}'</span>
    <span class="keyword">end</span>
    query,k = query:gsub(<span class="string">'FIELDLIST'</span>,fields)
    <span class="keyword">if</span> is_string(condn.where) <span class="keyword">then</span>
        query = query:gsub(<span class="string">'CONDITION'</span>,condn.where)
        condn.where = <span class="keyword">nil</span>
    <span class="keyword">else</span>
       query = query:gsub(<span class="string">'CONDITION'</span>,<span class="string">'_condn(v)'</span>)
       condn.where = function_arg(<span class="number">0</span>,condn.where,<span class="string">'condition.where must be callable'</span>)
    <span class="keyword">end</span>
    <span class="keyword">if</span> condn.sort_by <span class="keyword">then</span><a id="535"></a>
        <span class="keyword">local</span> expr,sort_var,sort_dir
        <span class="keyword">local</span> sort_by = condn.sort_by
        <span class="keyword">local</span> i1,i2 = sort_by:find(<span class="string">'%s+'</span>)
        <span class="keyword">if</span> i1 <span class="keyword">then</span>
            sort_var,sort_dir = sort_by:sub(<span class="number">1</span>,i1-<span class="number">1</span>),sort_by:sub(i2+<span class="number">1</span>)
        <span class="keyword">else</span>
            sort_var = sort_by
            sort_dir = <span class="string">'asc'</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span> sort_var:match <span class="string">'^%$'</span> <span class="keyword">then</span> sort_var = sort_var:sub(<span class="number">2</span>) <span class="keyword">end</span>
        sort_var = massage_fields(data,sort_var)
        <span class="keyword">if</span> field_error <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span>,field_error <span class="keyword">end</span>
        <span class="keyword">if</span> sort_dir == <span class="string">'asc'</span> <span class="keyword">then</span>
            sort_dir = <span class="string">'&lt;'</span>
        <span class="keyword">else</span>
            sort_dir = <span class="string">'&gt;'</span>
        <span class="keyword">end</span>
        expr = (<span class="string">'%s %s %s'</span>):format(sort_var:gsub(<span class="string">'v'</span>,<span class="string">'v1'</span>),sort_dir,sort_var:gsub(<span class="string">'v'</span>,<span class="string">'v2'</span>))
        query = query:gsub(<span class="string">'SORT_EXPR'</span>,expr)
    <span class="keyword">end</span>
    <span class="keyword">if</span> condn.where <span class="keyword">then</span>
        query = <span class="string">'return function(_condn) '</span>..query..<span class="string">' end'</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> _DEBUG <span class="keyword">then</span> <span class="global">print</span>(query) <span class="keyword">end</span>

    <span class="keyword">local</span> fn,err = utils.<span class="global">load</span>(query,<span class="string">'tmp'</span>)
    <span class="keyword">if</span> <span class="keyword">not</span> fn <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span>,err <span class="keyword">end</span>
    fn = fn() <span class="comment">-- get the function
</span>    <span class="keyword">if</span> condn.where <span class="keyword">then</span>
        fn = fn(condn.where)
    <span class="keyword">end</span>
    <span class="keyword">local</span> qfun = fn(data)
    <span class="keyword">if</span> context <span class="keyword">then</span>
        <span class="comment">-- [specifying context for condition] @context is a list of tables which are
</span>        <span class="comment">-- 'injected'into the condition's custom context
</span>        append(context,_G)
        <span class="keyword">local</span> lookup = {}
        utils.<span class="global">setfenv</span>(qfun,lookup)
        <span class="global">setmetatable</span>(lookup,{
            __index = <span class="keyword">function</span>(tbl,key)
               <span class="comment">-- _G.print(tbl,key)
</span>                <span class="keyword">for</span> k,t <span class="keyword">in</span> <span class="global">ipairs</span>(context) <span class="keyword">do</span>
                    <span class="keyword">if</span> t[key] <span class="keyword">then</span> <span class="keyword">return</span> t[key] <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        })
    <span class="keyword">end</span>
    <span class="keyword">return</span> qfun
<span class="keyword">end</span>


DataMT.<span class="global">select</span> = data.query
DataMT.select_row = <span class="keyword">function</span>(d,condn,context)
    <span class="keyword">return</span> data.query(d,condn,context,<span class="keyword">true</span>)
<span class="keyword">end</span>

<span class="comment">--- Filter input using a query.
</span><span class="comment">-- @string Q a query string
</span><span class="comment">-- @param infile filename or file-like object
</span><span class="comment">-- @param outfile filename or file-like object
</span><span class="comment">-- @bool dont_fail true if you want to return an error, not just fail
</span><span class="keyword">function</span> data.filter (Q,infile,outfile,dont_fail)
    <span class="keyword">local</span> err
    <span class="keyword">local</span> d = data.read(infile <span class="keyword">or</span> <span class="string">'stdin'</span>)
    <span class="keyword">local</span> out = open_file(outfile <span class="keyword">or</span> <span class="string">'stdout'</span>)
    <span class="keyword">local</span> iter,err = d:<span class="global">select</span>(Q)
    <span class="keyword">local</span> delim = d.delim
    <span class="keyword">if</span> <span class="keyword">not</span> iter <span class="keyword">then</span>
        err = <span class="string">'error: '</span>..err
        <span class="keyword">if</span> dont_fail <span class="keyword">then</span>
            <span class="keyword">return</span> <span class="keyword">nil</span>,err
        <span class="keyword">else</span>
            utils.quit(<span class="number">1</span>,err)
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">while</span> <span class="keyword">true</span> <span class="keyword">do</span>
        <span class="keyword">local</span> res = {iter()}
        <span class="keyword">if</span> #res == <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span>
        out:write(concat(res,delim),<span class="string">'\n'</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">return</span> data</pre>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.3</a></i>
<i style="float:right;">Last updated 2014-11-01 18:36:39 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
