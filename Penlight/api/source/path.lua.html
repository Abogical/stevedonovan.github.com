<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Penlight Documentation</title>
    <link rel="stylesheet" href="../ldoc_fixed.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Penlight</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Source</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../source/app.lua.html">app.lua</a></li>
  <li><a href="../source/array2d.lua.html">array2d.lua</a></li>
  <li><a href="../source/class.lua.html">class.lua</a></li>
  <li><a href="../source/compat.lua.html">compat.lua</a></li>
  <li><a href="../source/comprehension.lua.html">comprehension.lua</a></li>
  <li><a href="../source/config.lua.html">config.lua</a></li>
  <li><a href="../source/data.lua.html">data.lua</a></li>
  <li><a href="../source/date.lua.html">date.lua</a></li>
  <li><a href="../source/dir.lua.html">dir.lua</a></li>
  <li><a href="../source/file.lua.html">file.lua</a></li>
  <li><a href="../source/func.lua.html">func.lua</a></li>
  <li><a href="../source/import_into.lua.html">import_into.lua</a></li>
  <li><a href="../source/init.lua.html">init.lua</a></li>
  <li><a href="../source/input.lua.html">input.lua</a></li>
  <li><a href="../source/lapp.lua.html">lapp.lua</a></li>
  <li><a href="../source/lexer.lua.html">lexer.lua</a></li>
  <li><a href="../source/list.lua.html">list.lua</a></li>
  <li><a href="../source/luabalanced.lua.html">luabalanced.lua</a></li>
  <li><a href="../source/map.lua.html">map.lua</a></li>
  <li><a href="../source/multimap.lua.html">multimap.lua</a></li>
  <li><a href="../source/operator.lua.html">operator.lua</a></li>
  <li><a href="../source/orderedmap.lua.html">orderedmap.lua</a></li>
  <li><strong>path.lua</strong></li>
  <li><a href="../source/permute.lua.html">permute.lua</a></li>
  <li><a href="../source/pretty.lua.html">pretty.lua</a></li>
  <li><a href="../source/seesubst.lua.html">seesubst.lua</a></li>
  <li><a href="../source/seq.lua.html">seq.lua</a></li>
  <li><a href="../source/set.lua.html">set.lua</a></li>
  <li><a href="../source/sip.lua.html">sip.lua</a></li>
  <li><a href="../source/sipscan.lua.html">sipscan.lua</a></li>
  <li><a href="../source/strict.lua.html">strict.lua</a></li>
  <li><a href="../source/stringio.lua.html">stringio.lua</a></li>
  <li><a href="../source/stringx.lua.html">stringx.lua</a></li>
  <li><a href="../source/symbols.lua.html">symbols.lua</a></li>
  <li><a href="../source/tablex.lua.html">tablex.lua</a></li>
  <li><a href="../source/template.lua.html">template.lua</a></li>
  <li><a href="../source/test-cmp.lua.html">test-cmp.lua</a></li>
  <li><a href="../source/test-data.lua.html">test-data.lua</a></li>
  <li><a href="../source/test-listcallbacks.lua.html">test-listcallbacks.lua</a></li>
  <li><a href="../source/test-pretty.lua.html">test-pretty.lua</a></li>
  <li><a href="../source/test-symbols.lua.html">test-symbols.lua</a></li>
  <li><a href="../source/test.lua.html">test.lua</a></li>
  <li><a href="../source/testapp.lua.html">testapp.lua</a></li>
  <li><a href="../source/testclone.lua.html">testclone.lua</a></li>
  <li><a href="../source/testconfig.lua.html">testconfig.lua</a></li>
  <li><a href="../source/testglobal.lua.html">testglobal.lua</a></li>
  <li><a href="../source/testinputfields.lua.html">testinputfields.lua</a></li>
  <li><a href="../source/testinputfields2.lua.html">testinputfields2.lua</a></li>
  <li><a href="../source/testxml.lua.html">testxml.lua</a></li>
  <li><a href="../source/text.lua.html">text.lua</a></li>
  <li><a href="../source/types.lua.html">types.lua</a></li>
  <li><a href="../source/url.lua.html">url.lua</a></li>
  <li><a href="../source/utils.lua.html">utils.lua</a></li>
  <li><a href="../source/which.lua.html">which.lua</a></li>
  <li><a href="../source/xml.lua.html">xml.lua</a></li>
</ul>
<h2>Libraries</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../libraries/pl.html">pl</a></li>
  <li><a href="../libraries/pl.app.html">pl.app</a></li>
  <li><a href="../libraries/pl.array2d.html">pl.array2d</a></li>
  <li><a href="../libraries/pl.class.html">pl.class</a></li>
  <li><a href="../libraries/pl.compat.html">pl.compat</a></li>
  <li><a href="../libraries/pl.comprehension.html">pl.comprehension</a></li>
  <li><a href="../libraries/pl.config.html">pl.config</a></li>
  <li><a href="../libraries/pl.data.html">pl.data</a></li>
  <li><a href="../libraries/pl.dir.html">pl.dir</a></li>
  <li><a href="../libraries/pl.file.html">pl.file</a></li>
  <li><a href="../libraries/pl.func.html">pl.func</a></li>
  <li><a href="../libraries/pl.import_into.html">pl.import_into</a></li>
  <li><a href="../libraries/pl.input.html">pl.input</a></li>
  <li><a href="../libraries/pl.lapp.html">pl.lapp</a></li>
  <li><a href="../libraries/pl.lexer.html">pl.lexer</a></li>
  <li><a href="../libraries/pl.luabalanced.html">pl.luabalanced</a></li>
  <li><a href="../libraries/pl.operator.html">pl.operator</a></li>
  <li><a href="../libraries/pl.path.html">pl.path</a></li>
  <li><a href="../libraries/pl.permute.html">pl.permute</a></li>
  <li><a href="../libraries/pl.pretty.html">pl.pretty</a></li>
  <li><a href="../libraries/pl.seq.html">pl.seq</a></li>
  <li><a href="../libraries/pl.sip.html">pl.sip</a></li>
  <li><a href="../libraries/pl.strict.html">pl.strict</a></li>
  <li><a href="../libraries/pl.stringio.html">pl.stringio</a></li>
  <li><a href="../libraries/pl.stringx.html">pl.stringx</a></li>
  <li><a href="../libraries/pl.tablex.html">pl.tablex</a></li>
  <li><a href="../libraries/pl.template.html">pl.template</a></li>
  <li><a href="../libraries/pl.test.html">pl.test</a></li>
  <li><a href="../libraries/pl.text.html">pl.text</a></li>
  <li><a href="../libraries/pl.types.html">pl.types</a></li>
  <li><a href="../libraries/pl.url.html">pl.url</a></li>
  <li><a href="../libraries/pl.utils.html">pl.utils</a></li>
  <li><a href="../libraries/pl.xml.html">pl.xml</a></li>
</ul>
<h2>Classes</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../classes/pl.Date.html">pl.Date</a></li>
  <li><a href="../classes/pl.List.html">pl.List</a></li>
  <li><a href="../classes/pl.Map.html">pl.Map</a></li>
  <li><a href="../classes/pl.MultiMap.html">pl.MultiMap</a></li>
  <li><a href="../classes/pl.OrderedMap.html">pl.OrderedMap</a></li>
  <li><a href="../classes/pl.Set.html">pl.Set</a></li>
</ul>
<h2>Manual</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../manual/01-introduction.md.html">Introduction</a></li>
  <li><a href="../manual/02-arrays.md.html">Tables and Arrays</a></li>
  <li><a href="../manual/03-strings.md.html">Strings. Higher-level operations on strings.</a></li>
  <li><a href="../manual/04-paths.md.html">Paths and Directories</a></li>
  <li><a href="../manual/05-dates.md.html">Date and Time</a></li>
  <li><a href="../manual/06-data.md.html">Data</a></li>
  <li><a href="../manual/07-functional.md.html">Functional Programming</a></li>
  <li><a href="../manual/08-additional.md.html">Additional Libraries</a></li>
  <li><a href="../manual/09-discussion.md.html">Technical Choices</a></li>
</ul>
<h2>Examples</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../examples/seesubst.lua.html">seesubst.lua</a></li>
  <li><a href="../examples/sipscan.lua.html">sipscan.lua</a></li>
  <li><a href="../examples/symbols.lua.html">symbols.lua</a></li>
  <li><a href="../examples/test-cmp.lua.html">test-cmp.lua</a></li>
  <li><a href="../examples/test-data.lua.html">test-data.lua</a></li>
  <li><a href="../examples/test-listcallbacks.lua.html">test-listcallbacks.lua</a></li>
  <li><a href="../examples/test-pretty.lua.html">test-pretty.lua</a></li>
  <li><a href="../examples/test-symbols.lua.html">test-symbols.lua</a></li>
  <li><a href="../examples/testapp.lua.html">testapp.lua</a></li>
  <li><a href="../examples/testclone.lua.html">testclone.lua</a></li>
  <li><a href="../examples/testconfig.lua.html">testconfig.lua</a></li>
  <li><a href="../examples/testglobal.lua.html">testglobal.lua</a></li>
  <li><a href="../examples/testinputfields.lua.html">testinputfields.lua</a></li>
  <li><a href="../examples/testinputfields2.lua.html">testinputfields2.lua</a></li>
  <li><a href="../examples/testxml.lua.html">testxml.lua</a></li>
  <li><a href="../examples/which.lua.html">which.lua</a></li>
</ul>

</div>

<div id="content">

    <h2>path.lua</h2>
<pre>
<span class="comment">--- Path manipulation and file queries.
</span><span class="comment">--
</span><span class="comment">-- This is modelled after Python's os.path library (10.1); see <a href="../manual/04-paths.md.html#">the Guide</a>.
</span><span class="comment">--
</span><span class="comment">-- Dependencies: <a href="../libraries/pl.utils.html#">pl.utils</a>, <a href="http://stevedonovan.github.io/lua-stdlibs/modules/lfs.html">lfs</a>
</span><span class="comment">-- @module pl.path
</span>
<span class="comment">-- imports and locals
</span><span class="keyword">local</span> _G = _G
<span class="keyword">local</span> sub = <span class="global">string</span>.sub
<span class="keyword">local</span> getenv = <span class="global">os</span>.getenv
<span class="keyword">local</span> tmpnam = <span class="global">os</span>.tmpname
<span class="keyword">local</span> attributes, currentdir, link_attrib
<span class="keyword">local</span> <span class="global">package</span> = <span class="global">package</span>
<span class="keyword">local</span> <span class="global">io</span> = <span class="global">io</span>
<span class="keyword">local</span> append = <span class="global">table</span>.insert
<span class="keyword">local</span> <span class="global">ipairs</span> = <span class="global">ipairs</span>
<span class="keyword">local</span> utils = <span class="global">require</span> <span class="string">'pl.utils'</span>
<span class="keyword">local</span> assert_arg,assert_string,raise = utils.assert_arg,utils.assert_string,utils.raise

<span class="keyword">local</span> attrib
<span class="keyword">local</span> path = {}

<span class="keyword">local</span> res,lfs = _G.<span class="global">pcall</span>(_G.<span class="global">require</span>,<span class="string">'lfs'</span>)
<span class="keyword">if</span> res <span class="keyword">then</span>
    attributes = lfs.attributes
    currentdir = lfs.currentdir
    link_attrib = lfs.symlinkattributes
<span class="keyword">else</span>
    error(<span class="string">"pl.path requires LuaFileSystem"</span>)
<span class="keyword">end</span>

attrib = attributes
path.attrib = attrib
path.link_attrib = link_attrib

<span class="comment">--- Lua iterator over the entries of a given directory.
</span><a id="39"></a><span class="comment">-- Behaves like <a href="http://stevedonovan.github.io/lua-stdlibs/modules/lfs.html#dir">lfs.dir</a>
</span>path.dir = lfs.dir

<a id="42"></a><span class="comment">--- Creates a directory.
</span>path.mkdir = lfs.mkdir

<a id="45"></a><span class="comment">--- Removes a directory.
</span>path.rmdir = lfs.rmdir

<a id="48"></a><span class="comment">---- Get the working directory.
</span>path.currentdir = currentdir

<a id="51"></a><span class="comment">--- Changes the working directory.
</span>path.chdir = lfs.chdir


<span class="comment">--- is this a directory?
</span><a id="56"></a><span class="comment">-- @string P A file path
</span><span class="keyword">function</span> path.isdir(P)
	assert_string(<span class="number">1</span>,P)
    <span class="keyword">if</span> P:match(<span class="string">"\\$"</span>) <span class="keyword">then</span>
        P = P:sub(<span class="number">1</span>,-<span class="number">2</span>)
    <span class="keyword">end</span>
    <span class="keyword">return</span> attrib(P,<span class="string">'mode'</span>) == <span class="string">'directory'</span>
<span class="keyword">end</span>

<span class="comment">--- is this a file?.
</span><a id="66"></a><span class="comment">-- @string P A file path
</span><span class="keyword">function</span> path.isfile(P)
	assert_string(<span class="number">1</span>,P)
    <span class="keyword">return</span> attrib(P,<span class="string">'mode'</span>) == <span class="string">'file'</span>
<span class="keyword">end</span>

<span class="comment">-- is this a symbolic link?
</span><span class="comment">-- @string P A file path
</span><span class="keyword">function</span> path.islink(P)
	assert_string(<span class="number">1</span>,P)
    <span class="keyword">if</span> link_attrib <span class="keyword">then</span>
        <span class="keyword">return</span> link_attrib(P,<span class="string">'mode'</span>)==<span class="string">'link'</span>
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="keyword">false</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- return size of a file.
</span><a id="84"></a><span class="comment">-- @string P A file path
</span><span class="keyword">function</span> path.getsize(P)
	assert_string(<span class="number">1</span>,P)
    <span class="keyword">return</span> attrib(P,<span class="string">'size'</span>)
<span class="keyword">end</span>

<span class="comment">--- does a path exist?.
</span><span class="comment">-- @string P A file path
</span><a id="92"></a><span class="comment">-- @return the file path if it exists, nil otherwise
</span><span class="keyword">function</span> path.exists(P)
	assert_string(<span class="number">1</span>,P)
    <span class="keyword">return</span> attrib(P,<span class="string">'mode'</span>) ~= <span class="keyword">nil</span> <span class="keyword">and</span> P
<span class="keyword">end</span>

<span class="comment">--- Return the time of last access as the number of seconds since the epoch.
</span><a id="99"></a><span class="comment">-- @string P A file path
</span><span class="keyword">function</span> path.getatime(P)
	assert_string(<span class="number">1</span>,P)
    <span class="keyword">return</span> attrib(P,<span class="string">'access'</span>)
<span class="keyword">end</span>

<span class="comment">--- Return the time of last modification
</span><a id="106"></a><span class="comment">-- @string P A file path
</span><span class="keyword">function</span> path.getmtime(P)
    <span class="keyword">return</span> attrib(P,<span class="string">'modification'</span>)
<span class="keyword">end</span>

<span class="comment">---Return the system's ctime.
</span><a id="112"></a><span class="comment">-- @string P A file path
</span><span class="keyword">function</span> path.getctime(P)
	assert_string(<span class="number">1</span>,P)
    <span class="keyword">return</span> path.attrib(P,<span class="string">'change'</span>)
<span class="keyword">end</span>


<span class="keyword">local</span> <span class="keyword">function</span> at(s,i)
    <span class="keyword">return</span> sub(s,i,i)
<span class="keyword">end</span>

path.is_windows = utils.dir_separator == <span class="string">'\\'

local other_sep
-- !constant sep is the directory separator for this platform.
if path.is_windows then
    path.sep = '</span>\\<span class="string">'; other_sep = '</span>/<span class="string">'
    path.dirsep = '</span>;<span class="string">'
else
    path.sep = '</span>/<span class="string">'
    path.dirsep = '</span>:<span class="string">'
end
local sep,dirsep = path.sep,path.dirsep

--- are we running Windows?
-- @class field
-- @name path.is_windows

--- path separator for this platform.
-- @class field
-- @name path.sep

--- separator for PATH for this platform
-- @class field
-- @name path.dirsep

--- given a path, return the directory part and a file part.
-- if there'</span>s no directory part, the first value will be empty
<span class="comment">-- @string P A file path
</span><span class="keyword">function</span> path.splitpath(P)
    assert_string(<span class="number">1</span>,P)
    <span class="keyword">local</span> i = #P
    <span class="keyword">local</span> ch = at(P,i)
    <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> ch ~= sep <span class="keyword">and</span> ch ~= other_sep <span class="keyword">do</span>
        i = i - <span class="number">1</span>
        ch = at(P,i)
    <span class="keyword">end</span>
    <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">then</span>
        <span class="keyword">return</span> <span class="string">''</span>,P
    <span class="keyword">else</span>
        <span class="keyword">return</span> sub(P,<span class="number">1</span>,i-<span class="number">1</span>), sub(P,i+<span class="number">1</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span><a id="139"></a>

<span class="comment">--- return an absolute path.
</span><span class="comment">-- @string P A file path
</span><span class="comment">-- @string[opt] pwd optional start path to use (default is current dir)
</span><span class="keyword">function</span> path.abspath(P,pwd)<a id="143"></a>
    assert_string(<span class="number">1</span>,P)
	<span class="keyword">if</span> pwd <span class="keyword">then</span> assert_string(<span class="number">2</span>,pwd) <span class="keyword">end</span>
    <span class="keyword">local</span> use_pwd = pwd ~= <span class="keyword">nil</span>
    <span class="keyword">if</span> <span class="keyword">not</span> use_pwd <span class="keyword">and</span> <span class="keyword">not</span> currentdir <span class="keyword">then</span> <span class="keyword">return</span> P <span class="keyword">end</span><a id="147"></a>
    P = P:gsub(<span class="string">'[\\/]$'</span>,<span class="string">''</span>)
    pwd = pwd <span class="keyword">or</span> currentdir()
    <span class="keyword">if</span> <span class="keyword">not</span> path.isabs(P) <span class="keyword">then</span><a id="150"></a>
        P = path.join(pwd,P)
    <span class="keyword">elseif</span> path.is_windows <span class="keyword">and</span> <span class="keyword">not</span> use_pwd <span class="keyword">and</span> at(P,<span class="number">2</span>) ~= <span class="string">':'</span> <span class="keyword">and</span> at(P,<span class="number">2</span>) ~= <span class="string">'\\' then
        P = pwd:sub(1,2)..P -- attach current drive to path like '</span>\\fred.txt<span class="string">'
    end
    return path.normpath(P)
end

--- given a path, return the root part and the extension part.
-- if there'</span>s no extension part, the second value will be empty
<span class="comment">-- @string P A file path
</span><span class="comment">-- @treturn string root part
</span><span class="comment">-- @treturn string extension part (maybe empty)
</span><span class="keyword">function</span> path.splitext(P)
    assert_string(<span class="number">1</span>,P)
    <span class="keyword">local</span> i = #P
    <span class="keyword">local</span> ch = at(P,i)
    <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> ch ~= <span class="string">'.'</span> <span class="keyword">do</span>
        <span class="keyword">if</span> ch == sep <span class="keyword">or</span> ch == other_sep <span class="keyword">then</span>
            <span class="keyword">return</span> P,<span class="string">''</span>
        <span class="keyword">end</span>
        i = i - <span class="number">1</span>
        ch = at(P,i)
    <span class="keyword">end</span>
    <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">then</span>
        <span class="keyword">return</span> P,<span class="string">''</span><a id="168"></a>
    <span class="keyword">else</span>
        <span class="keyword">return</span> sub(P,<span class="number">1</span>,i-<span class="number">1</span>),sub(P,i)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- return the directory part of a path
</span><span class="comment">-- @string P A file path
</span><span class="keyword">function</span> path.dirname(P)
    assert_string(<span class="number">1</span>,P)
    <span class="keyword">local</span> p1,p2 = path.splitpath(P)
    <span class="keyword">return</span> p1
<span class="keyword">end</span>

<span class="comment">--- return the file part of a path
</span><span class="comment">-- @string P A file path
</span><span class="keyword">function</span> path.basename(P)
    assert_string(<span class="number">1</span>,P)
    <span class="keyword">local</span> p1,p2 = path.splitpath(P)
    <span class="keyword">return</span> p2
<span class="keyword">end</span>

<span class="comment">--- get the extension part of a path.
</span><span class="comment">-- @string P A file path
</span><span class="keyword">function</span> path.extension(P)
    assert_string(<span class="number">1</span>,P)
    <span class="keyword">local</span> p1,p2 = path.splitext(P)
    <span class="keyword">return</span> p2
<span class="keyword">end</span>

<span class="comment">--- is this an absolute path?.
</span><span class="comment">-- @string P A file path
</span><span class="keyword">function</span> path.isabs(P)
    assert_string(<span class="number">1</span>,P)
    <span class="keyword">if</span> path.is_windows <span class="keyword">then</span>
        <span class="keyword">return</span> at(P,<span class="number">1</span>) == <span class="string">'/'</span> <span class="keyword">or</span> at(P,<span class="number">1</span>)==<span class="string">'\\' or at(P,2)=='</span>:<span class="string">'
    else
        return at(P,1) == '</span>/<span class="string">'
    end
end

--- return the path resulting from combining the individual paths.
-- if the second (or later) path is absolute, we return the last absolute path (joined with any non-absolute paths following).
-- empty elements (except the last) will be ignored.
-- @string p1 A file path
-- @string p2 A file path
-- @string ... more file paths
function path.join(p1,p2,...)
    assert_string(1,p1)
    assert_string(2,p2)
    if select('</span>#<span class="string">',...) &gt; 0 then
        local p = path.join(p1,p2)
        local args = {...}
        for i = 1,#args do
            assert_string(i,args[i])
            p = path.join(p,args[i])
        end
        return p
    end
    if path.isabs(p2) then return p2 end
    local endc = at(p1,#p1)
    if endc ~= path.sep and endc ~= other_sep and endc ~= "" then
        p1 = p1..path.sep
    end
    return p1..p2
end

--- normalize the case of a pathname. On Unix, this returns the path unchanged;
--  for Windows, it converts the path to lowercase, and it also converts forward slashes
-- to backward slashes.
-- @string P A file path
function path.normcase(P)
    assert_string(1,P)
    if path.is_windows then
        return (P:lower():gsub('</span>/<span class="string">','</span>\\<span class="string">'))
    else
        return P
    end
end

local np_gen1,np_gen2 = '</span>[^SEP]+SEP%.%.SEP?<span class="string">','</span>SEP+%.?SEP<span class="string">'
local np_pat1, np_pat2

--- normalize a path name.
--  A//B, A/./B and A/foo/../B all become A/B.
-- @string P a file path
function path.normpath(P)
    assert_string(1,P)
    if path.is_windows then
        if P:match '</span>^\\\\<span class="string">' then -- UNC
            return '</span>\\\\<span class="string">'..path.normpath(P:sub(3))
        end
        P = P:gsub('</span>/<span class="string">','</span>\\<span class="string">')
    end
    if not np_pat1 then
        np_pat1 = np_gen1:gsub('</span>SEP<span class="string">',sep)
        np_pat2 = np_gen2:gsub('</span>SEP<span class="string">',sep)
    end
    local k
    repeat -- /./ -&gt; /
        P,k = P:gsub(np_pat2,sep)
    until k == 0
    repeat -- A/../ -&gt; (empty)
        P,k = P:gsub(np_pat1,'</span><span class="string">')
    until k == 0
    if P == '</span><span class="string">' then P = '</span>.<span class="string">' end
    return P
end

local function ATS (P)
    if at(P,#P) ~= path.sep then
        P = P..path.sep
    end
    return path.normcase(P)
end

--- relative path from current directory or optional start point
-- @string P a path
-- @string[opt] start optional start point (default current directory)
function path.relpath (P,start)
    assert_string(1,P)
	if start then assert_string(2,start) end
    local split,normcase,min,append = utils.split, path.normcase, math.min, table.insert
    P = normcase(path.abspath(P,start))
    start = start or currentdir()
    start = normcase(start)
    local startl, Pl = split(start,sep), split(P,sep)
    local n = min(#startl,#Pl)
    local k = n+1 -- default value if this loop doesn'</span>t bail out!
    <span class="keyword">for</span> i = <span class="number">1</span>,n <span class="keyword">do</span>
        <span class="keyword">if</span> startl[i] ~= Pl[i] <span class="keyword">then</span>
            k = i
            <span class="keyword">break</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">local</span> rell = {}
    <span class="keyword">for</span> i = <span class="number">1</span>, #startl-k+<span class="number">1</span> <span class="keyword">do</span> rell[i] = <span class="string">'..'</span> <span class="keyword">end</span>
    <span class="keyword">if</span> k &lt;= #Pl <span class="keyword">then</span>
        <span class="keyword">for</span> i = k,#Pl <span class="keyword">do</span> append(rell,Pl[i]) <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="global">table</span>.concat(rell,sep)
<span class="keyword">end</span>


<span class="comment">--- Replace a starting '~' with the user's home directory.
</span><span class="comment">-- In windows, if HOME isn't set, then USERPROFILE is used in preference to
</span><span class="comment">-- HOMEDRIVE HOMEPATH. This is guaranteed to be writeable on all versions of Windows.
</span><span class="comment">-- @string P A file path
</span><span class="keyword">function</span> path.expanduser(P)
    assert_string(<span class="number">1</span>,P)
    <span class="keyword">if</span> at(P,<span class="number">1</span>) == <span class="string">'~'</span> <span class="keyword">then</span>
        <span class="keyword">local</span> home = getenv(<span class="string">'HOME'</span>)
        <span class="keyword">if</span> <span class="keyword">not</span> home <span class="keyword">then</span> <span class="comment">-- has to be Windows
</span>            home = getenv <span class="string">'USERPROFILE'</span> <span class="keyword">or</span> (getenv <span class="string">'HOMEDRIVE'</span> .. getenv <span class="string">'HOMEPATH'</span>)
        <span class="keyword">end</span>
        <span class="keyword">return</span> home..sub(P,<span class="number">2</span>)
    <span class="keyword">else</span>
        <span class="keyword">return</span> P
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="comment">---Return a suitable full path to a new temporary file name.
</span><span class="comment">-- unlike os.tmpnam(), it always gives you a writeable path (uses TEMP environment variable on Windows)
</span><span class="keyword">function</span> path.tmpname ()
    <span class="keyword">local</span> res = tmpnam()
    <span class="keyword">if</span> path.is_windows <span class="keyword">then</span> res = getenv(<span class="string">'TEMP'</span>)..res <span class="keyword">end</span>
    <span class="keyword">return</span> res
<span class="keyword">end</span>

<span class="comment">--- return the largest common prefix path of two paths.
</span><span class="comment">-- @string path1 a file path
</span><span class="comment">-- @string path2 a file path
</span><span class="keyword">function</span> path.common_prefix (path1,path2)
    assert_string(<span class="number">1</span>,path1)
    assert_string(<span class="number">2</span>,path2)
    path1, path2 = path.normcase(path1), path.normcase(path2)
    <span class="comment">-- get them in order!
</span>    <span class="keyword">if</span> #path1 &gt; #path2 <span class="keyword">then</span> path2,path1 = path1,path2 <span class="keyword">end</span>
    <span class="keyword">for</span> i = <span class="number">1</span>,#path1 <span class="keyword">do</span>
        <span class="keyword">local</span> c1 = at(path1,i)
        <span class="keyword">if</span> c1 ~= at(path2,i) <span class="keyword">then</span>
            <span class="keyword">local</span> cp = path1:sub(<span class="number">1</span>,i-<span class="number">1</span>)
            <span class="keyword">if</span> at(path1,i-<span class="number">1</span>) ~= sep <span class="keyword">then</span>
                cp = path.dirname(cp)
            <span class="keyword">end</span>
            <span class="keyword">return</span> cp
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> at(path2,#path1+<span class="number">1</span>) ~= sep <span class="keyword">then</span> path1 = path.dirname(path1) <span class="keyword">end</span>
    <span class="keyword">return</span> path1
    <span class="comment">--return ''
</span><span class="keyword">end</span>

<span class="comment">--- return the full path where a particular Lua module would be found.
</span><span class="comment">-- Both package.path and package.cpath is searched, so the result may
</span><span class="comment">-- either be a Lua file or a shared library.
</span><span class="comment">-- @string mod name of the module
</span><span class="comment">-- @return on success: path of module, lua or binary
</span><span class="comment">-- @return on error: nil,error string
</span><span class="keyword">function</span> path.package_path(mod)
    assert_string(<span class="number">1</span>,mod)
    <span class="keyword">local</span> res
    mod = mod:gsub(<span class="string">'%.'</span>,sep)
    res = <span class="global">package</span>.searchpath(mod,<span class="global">package</span>.path)
    <span class="keyword">if</span> res <span class="keyword">then</span> <span class="keyword">return</span> res,<span class="keyword">true</span> <span class="keyword">end</span>
    res = <span class="global">package</span>.searchpath(mod,<span class="global">package</span>.cpath)
    <span class="keyword">if</span> res <span class="keyword">then</span> <span class="keyword">return</span> res,<span class="keyword">false</span> <span class="keyword">end</span>
    <span class="keyword">return</span> raise <span class="string">'cannot find module on path'</span>
<span class="keyword">end</span>


<span class="comment">---- finis -----
</span><span class="keyword">return</span> path</pre>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.3</a></i>
<i style="float:right;">Last updated 2014-11-01 18:36:39 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
