<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Penlight Documentation</title>
    <link rel="stylesheet" href="../ldoc_fixed.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Penlight</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Source</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../source/app.lua.html">app.lua</a></li>
  <li><a href="../source/array2d.lua.html">array2d.lua</a></li>
  <li><a href="../source/class.lua.html">class.lua</a></li>
  <li><a href="../source/compat.lua.html">compat.lua</a></li>
  <li><a href="../source/comprehension.lua.html">comprehension.lua</a></li>
  <li><a href="../source/config.lua.html">config.lua</a></li>
  <li><a href="../source/data.lua.html">data.lua</a></li>
  <li><a href="../source/date.lua.html">date.lua</a></li>
  <li><strong>dir.lua</strong></li>
  <li><a href="../source/file.lua.html">file.lua</a></li>
  <li><a href="../source/func.lua.html">func.lua</a></li>
  <li><a href="../source/import_into.lua.html">import_into.lua</a></li>
  <li><a href="../source/init.lua.html">init.lua</a></li>
  <li><a href="../source/input.lua.html">input.lua</a></li>
  <li><a href="../source/lapp.lua.html">lapp.lua</a></li>
  <li><a href="../source/lexer.lua.html">lexer.lua</a></li>
  <li><a href="../source/list.lua.html">list.lua</a></li>
  <li><a href="../source/luabalanced.lua.html">luabalanced.lua</a></li>
  <li><a href="../source/map.lua.html">map.lua</a></li>
  <li><a href="../source/multimap.lua.html">multimap.lua</a></li>
  <li><a href="../source/operator.lua.html">operator.lua</a></li>
  <li><a href="../source/orderedmap.lua.html">orderedmap.lua</a></li>
  <li><a href="../source/path.lua.html">path.lua</a></li>
  <li><a href="../source/permute.lua.html">permute.lua</a></li>
  <li><a href="../source/pretty.lua.html">pretty.lua</a></li>
  <li><a href="../source/seesubst.lua.html">seesubst.lua</a></li>
  <li><a href="../source/seq.lua.html">seq.lua</a></li>
  <li><a href="../source/set.lua.html">set.lua</a></li>
  <li><a href="../source/sip.lua.html">sip.lua</a></li>
  <li><a href="../source/sipscan.lua.html">sipscan.lua</a></li>
  <li><a href="../source/strict.lua.html">strict.lua</a></li>
  <li><a href="../source/stringio.lua.html">stringio.lua</a></li>
  <li><a href="../source/stringx.lua.html">stringx.lua</a></li>
  <li><a href="../source/symbols.lua.html">symbols.lua</a></li>
  <li><a href="../source/tablex.lua.html">tablex.lua</a></li>
  <li><a href="../source/template.lua.html">template.lua</a></li>
  <li><a href="../source/test-cmp.lua.html">test-cmp.lua</a></li>
  <li><a href="../source/test-data.lua.html">test-data.lua</a></li>
  <li><a href="../source/test-listcallbacks.lua.html">test-listcallbacks.lua</a></li>
  <li><a href="../source/test-pretty.lua.html">test-pretty.lua</a></li>
  <li><a href="../source/test-symbols.lua.html">test-symbols.lua</a></li>
  <li><a href="../source/test.lua.html">test.lua</a></li>
  <li><a href="../source/testapp.lua.html">testapp.lua</a></li>
  <li><a href="../source/testclone.lua.html">testclone.lua</a></li>
  <li><a href="../source/testconfig.lua.html">testconfig.lua</a></li>
  <li><a href="../source/testglobal.lua.html">testglobal.lua</a></li>
  <li><a href="../source/testinputfields.lua.html">testinputfields.lua</a></li>
  <li><a href="../source/testinputfields2.lua.html">testinputfields2.lua</a></li>
  <li><a href="../source/testxml.lua.html">testxml.lua</a></li>
  <li><a href="../source/text.lua.html">text.lua</a></li>
  <li><a href="../source/types.lua.html">types.lua</a></li>
  <li><a href="../source/url.lua.html">url.lua</a></li>
  <li><a href="../source/utils.lua.html">utils.lua</a></li>
  <li><a href="../source/which.lua.html">which.lua</a></li>
  <li><a href="../source/xml.lua.html">xml.lua</a></li>
</ul>
<h2>Libraries</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../libraries/pl.html">pl</a></li>
  <li><a href="../libraries/pl.app.html">pl.app</a></li>
  <li><a href="../libraries/pl.array2d.html">pl.array2d</a></li>
  <li><a href="../libraries/pl.class.html">pl.class</a></li>
  <li><a href="../libraries/pl.compat.html">pl.compat</a></li>
  <li><a href="../libraries/pl.comprehension.html">pl.comprehension</a></li>
  <li><a href="../libraries/pl.config.html">pl.config</a></li>
  <li><a href="../libraries/pl.data.html">pl.data</a></li>
  <li><a href="../libraries/pl.dir.html">pl.dir</a></li>
  <li><a href="../libraries/pl.file.html">pl.file</a></li>
  <li><a href="../libraries/pl.func.html">pl.func</a></li>
  <li><a href="../libraries/pl.import_into.html">pl.import_into</a></li>
  <li><a href="../libraries/pl.input.html">pl.input</a></li>
  <li><a href="../libraries/pl.lapp.html">pl.lapp</a></li>
  <li><a href="../libraries/pl.lexer.html">pl.lexer</a></li>
  <li><a href="../libraries/pl.luabalanced.html">pl.luabalanced</a></li>
  <li><a href="../libraries/pl.operator.html">pl.operator</a></li>
  <li><a href="../libraries/pl.path.html">pl.path</a></li>
  <li><a href="../libraries/pl.permute.html">pl.permute</a></li>
  <li><a href="../libraries/pl.pretty.html">pl.pretty</a></li>
  <li><a href="../libraries/pl.seq.html">pl.seq</a></li>
  <li><a href="../libraries/pl.sip.html">pl.sip</a></li>
  <li><a href="../libraries/pl.strict.html">pl.strict</a></li>
  <li><a href="../libraries/pl.stringio.html">pl.stringio</a></li>
  <li><a href="../libraries/pl.stringx.html">pl.stringx</a></li>
  <li><a href="../libraries/pl.tablex.html">pl.tablex</a></li>
  <li><a href="../libraries/pl.template.html">pl.template</a></li>
  <li><a href="../libraries/pl.test.html">pl.test</a></li>
  <li><a href="../libraries/pl.text.html">pl.text</a></li>
  <li><a href="../libraries/pl.types.html">pl.types</a></li>
  <li><a href="../libraries/pl.url.html">pl.url</a></li>
  <li><a href="../libraries/pl.utils.html">pl.utils</a></li>
  <li><a href="../libraries/pl.xml.html">pl.xml</a></li>
</ul>
<h2>Classes</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../classes/pl.Date.html">pl.Date</a></li>
  <li><a href="../classes/pl.List.html">pl.List</a></li>
  <li><a href="../classes/pl.Map.html">pl.Map</a></li>
  <li><a href="../classes/pl.MultiMap.html">pl.MultiMap</a></li>
  <li><a href="../classes/pl.OrderedMap.html">pl.OrderedMap</a></li>
  <li><a href="../classes/pl.Set.html">pl.Set</a></li>
</ul>
<h2>Manual</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../manual/01-introduction.md.html">Introduction</a></li>
  <li><a href="../manual/02-arrays.md.html">Tables and Arrays</a></li>
  <li><a href="../manual/03-strings.md.html">Strings. Higher-level operations on strings.</a></li>
  <li><a href="../manual/04-paths.md.html">Paths and Directories</a></li>
  <li><a href="../manual/05-dates.md.html">Date and Time</a></li>
  <li><a href="../manual/06-data.md.html">Data</a></li>
  <li><a href="../manual/07-functional.md.html">Functional Programming</a></li>
  <li><a href="../manual/08-additional.md.html">Additional Libraries</a></li>
  <li><a href="../manual/09-discussion.md.html">Technical Choices</a></li>
</ul>
<h2>Examples</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../examples/seesubst.lua.html">seesubst.lua</a></li>
  <li><a href="../examples/sipscan.lua.html">sipscan.lua</a></li>
  <li><a href="../examples/symbols.lua.html">symbols.lua</a></li>
  <li><a href="../examples/test-cmp.lua.html">test-cmp.lua</a></li>
  <li><a href="../examples/test-data.lua.html">test-data.lua</a></li>
  <li><a href="../examples/test-listcallbacks.lua.html">test-listcallbacks.lua</a></li>
  <li><a href="../examples/test-pretty.lua.html">test-pretty.lua</a></li>
  <li><a href="../examples/test-symbols.lua.html">test-symbols.lua</a></li>
  <li><a href="../examples/testapp.lua.html">testapp.lua</a></li>
  <li><a href="../examples/testclone.lua.html">testclone.lua</a></li>
  <li><a href="../examples/testconfig.lua.html">testconfig.lua</a></li>
  <li><a href="../examples/testglobal.lua.html">testglobal.lua</a></li>
  <li><a href="../examples/testinputfields.lua.html">testinputfields.lua</a></li>
  <li><a href="../examples/testinputfields2.lua.html">testinputfields2.lua</a></li>
  <li><a href="../examples/testxml.lua.html">testxml.lua</a></li>
  <li><a href="../examples/which.lua.html">which.lua</a></li>
</ul>

</div>

<div id="content">

    <h2>dir.lua</h2>
<pre>
<span class="comment">--
</span><span class="comment">-- Dependencies: <a href="../libraries/pl.utils.html#">pl.utils</a>, <a href="../libraries/pl.path.html#">pl.path</a>, <a href="../libraries/pl.tablex.html#">pl.tablex</a>
</span><span class="comment">--
</span><span class="comment">-- Soft Dependencies: <code>alien</code>, <code>ffi</code> (either are used on Windows for copying/moving files)
</span><span class="comment">-- @module pl.dir
</span>
<span class="keyword">local</span> utils = <span class="global">require</span> <span class="string">'pl.utils'</span>
<span class="keyword">local</span> path = <span class="global">require</span> <span class="string">'pl.path'</span>
<span class="keyword">local</span> is_windows = path.is_windows
<span class="keyword">local</span> tablex = <span class="global">require</span> <span class="string">'pl.tablex'</span>
<span class="keyword">local</span> ldir = path.dir
<span class="keyword">local</span> chdir = path.chdir
<span class="keyword">local</span> mkdir = path.mkdir
<span class="keyword">local</span> rmdir = path.rmdir
<span class="keyword">local</span> sub = <span class="global">string</span>.sub
<span class="keyword">local</span> <span class="global">os</span>,<span class="global">pcall</span>,<span class="global">ipairs</span>,<span class="global">pairs</span>,<span class="global">require</span>,<span class="global">setmetatable</span>,_G = <span class="global">os</span>,<span class="global">pcall</span>,<span class="global">ipairs</span>,<span class="global">pairs</span>,<span class="global">require</span>,<span class="global">setmetatable</span>,_G
<span class="keyword">local</span> remove = <span class="global">os</span>.remove
<span class="keyword">local</span> append = <span class="global">table</span>.insert
<span class="keyword">local</span> wrap = <span class="global">coroutine</span>.wrap
<span class="keyword">local</span> yield = <span class="global">coroutine</span>.yield
<span class="keyword">local</span> assert_arg,assert_string,raise = utils.assert_arg,utils.assert_string,utils.raise
<span class="keyword">local</span> List = utils.stdmt.List

<span class="keyword">local</span> dir = {}

<span class="keyword">local</span> <span class="keyword">function</span> assert_dir (n,val)
    assert_arg(n,val,<span class="string">'string'</span>,path.isdir,<span class="string">'not a directory'</span>,<span class="number">4</span>)
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> assert_file (n,val)
    assert_arg(n,val,<span class="string">'string'</span>,path.isfile,<span class="string">'not a file'</span>,<span class="number">4</span>)
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> filemask(mask)
    mask = utils.escape(mask)
    <span class="keyword">return</span> mask:gsub(<span class="string">'%%%*'</span>,<span class="string">'.+'</span>):gsub(<span class="string">'%%%?'</span>,<span class="string">'.'</span>)..<span class="string">'$'</span>
<span class="keyword">end</span>

<span class="comment">--- does the filename match the shell pattern?.
</span><span class="comment">-- (cf. fnmatch.fnmatch in Python, 11.8)
</span><span class="comment">-- @string file A file name
</span><span class="comment">-- @string pattern A shell pattern
</span><span class="comment">-- @treturn bool
</span><span class="comment">-- @raise file and pattern must be strings
</span><span class="keyword">function</span> dir.fnmatch(file,pattern)
    assert_string(<span class="number">1</span>,file)
    assert_string(<span class="number">2</span>,pattern)
    <span class="keyword">return</span> path.normcase(file):find(filemask(pattern)) ~= <span class="keyword">nil</span>
<span class="keyword">end</span>

<span class="comment">--- return a list of all files which match the pattern.
</span><span class="comment">-- (cf. fnmatch.filter in Python, 11.8)
</span><span class="comment">-- @string files A table containing file names
</span><span class="comment">-- @string pattern A shell pattern.
</span><span class="comment">-- @treturn List(string) list of files
</span><a id="57"></a><span class="comment">-- @raise file and pattern must be strings
</span><span class="keyword">function</span> dir.filter(files,pattern)
    assert_arg(<span class="number">1</span>,files,<span class="string">'table'</span>)
    assert_string(<span class="number">2</span>,pattern)
    <span class="keyword">local</span> res = {}
    <span class="keyword">local</span> mask = filemask(pattern)
    <span class="keyword">for</span> i,f <span class="keyword">in</span> <span class="global">ipairs</span>(files) <span class="keyword">do</span>
        <span class="keyword">if</span> f:find(mask) <span class="keyword">then</span> append(res,f) <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="global">setmetatable</span>(res,List)
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> _listfiles(dir,filemode,match)
    <span class="keyword">local</span> res = {}
    <span class="keyword">local</span> check = utils.choose(filemode,path.isfile,path.isdir)
    <span class="keyword">if</span> <span class="keyword">not</span> dir <span class="keyword">then</span> dir = <span class="string">'.'</span> <span class="keyword">end</span>
    <span class="keyword">for</span> f <span class="keyword">in</span> ldir(dir) <span class="keyword">do</span>
        <span class="keyword">if</span> f ~= <span class="string">'.'</span> <span class="keyword">and</span> f ~= <span class="string">'..'</span> <span class="keyword">then</span>
            <span class="keyword">local</span> p = path.join(dir,f)
            <span class="keyword">if</span> check(p) <span class="keyword">and</span> (<span class="keyword">not</span> match <span class="keyword">or</span> match(p)) <span class="keyword">then</span>
                append(res,p)
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="global">setmetatable</span>(res,List)
<span class="keyword">end</span>

<span class="comment">--- return a list of all files in a directory which match the a shell pattern.
</span><span class="comment">-- @string dir A directory. If not given, all files in current directory are returned.
</span><span class="comment">-- @string mask  A shell pattern. If not given, all files are returned.
</span><span class="comment">-- @treturn {string} list of files
</span><a id="88"></a><span class="comment">-- @raise dir and mask must be strings
</span><span class="keyword">function</span> dir.getfiles(dir,mask)
    assert_dir(<span class="number">1</span>,dir)
    <span class="keyword">if</span> mask <span class="keyword">then</span> assert_string(<span class="number">2</span>,mask) <span class="keyword">end</span>
    <span class="keyword">local</span> match
    <span class="keyword">if</span> mask <span class="keyword">then</span>
        mask = filemask(mask)
        match = <span class="keyword">function</span>(f)
            <span class="keyword">return</span> f:find(mask)
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> _listfiles(dir,<span class="keyword">true</span>,match)
<span class="keyword">end</span>

<span class="comment">--- return a list of all subdirectories of the directory.
</span><span class="comment">-- @string dir A directory
</span><span class="comment">-- @treturn {string} a list of directories
</span><a id="105"></a><span class="comment">-- @raise dir must be a a valid directory
</span><span class="keyword">function</span> dir.getdirectories(dir)
    assert_dir(<span class="number">1</span>,dir)
    <span class="keyword">return</span> _listfiles(dir,<span class="keyword">false</span>)
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> quote_argument (f)
    f = path.normcase(f)
    <span class="keyword">if</span> f:find <span class="string">'%s'</span> <span class="keyword">then</span>
        <span class="keyword">return</span> <span class="string">'"'</span>..f..<span class="string">'"'</span>
    <span class="keyword">else</span>
        <span class="keyword">return</span> f
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="keyword">local</span> alien,ffi,ffi_checked,CopyFile,MoveFile,GetLastError,win32_errors,cmd_tmpfile

<span class="keyword">local</span> <span class="keyword">function</span> execute_command(cmd,parms)
   <span class="keyword">if</span> <span class="keyword">not</span> cmd_tmpfile <span class="keyword">then</span> cmd_tmpfile = path.tmpname () <span class="keyword">end</span>
   <span class="keyword">local</span> err = path.is_windows <span class="keyword">and</span> <span class="string">' &gt; '</span> <span class="keyword">or</span> <span class="string">' 2&gt; '</span>
    cmd = cmd..<span class="string">' '</span>..parms..err..cmd_tmpfile
    <span class="keyword">local</span> ret = utils.execute(cmd)
    <span class="keyword">if</span> <span class="keyword">not</span> ret <span class="keyword">then</span>
        <span class="keyword">return</span> <span class="keyword">false</span>,(utils.readfile(cmd_tmpfile):gsub(<span class="string">'\n(.*)'</span>,<span class="string">''</span>))
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="keyword">true</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> find_ffi_copyfile ()
    <span class="keyword">if</span> <span class="keyword">not</span> ffi_checked <span class="keyword">then</span>
        ffi_checked = <span class="keyword">true</span>
        <span class="keyword">local</span> res
        res,alien = <span class="global">pcall</span>(<span class="global">require</span>,<span class="string">'alien'</span>)
        <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">then</span>
            alien = <span class="keyword">nil</span>
            res, ffi = <span class="global">pcall</span>(<span class="global">require</span>,<span class="string">'ffi'</span>)
        <span class="keyword">end</span>
        <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">then</span>
            ffi = <span class="keyword">nil</span>
            <span class="keyword">return</span>
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        <span class="keyword">return</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> alien <span class="keyword">then</span>
        <span class="comment">-- register the Win32 CopyFile and MoveFile functions
</span>        <span class="keyword">local</span> kernel = alien.<span class="global">load</span>(<span class="string">'kernel32.dll'</span>)
        CopyFile = kernel.CopyFileA
        CopyFile:types{<span class="string">'string'</span>,<span class="string">'string'</span>,<span class="string">'int'</span>,ret=<span class="string">'int'</span>,abi=<span class="string">'stdcall'</span>}
        MoveFile = kernel.MoveFileA
        MoveFile:types{<span class="string">'string'</span>,<span class="string">'string'</span>,ret=<span class="string">'int'</span>,abi=<span class="string">'stdcall'</span>}
        GetLastError = kernel.GetLastError
        GetLastError:types{ret =<span class="string">'int'</span>, abi=<span class="string">'stdcall'</span>}
    <span class="keyword">elseif</span> ffi <span class="keyword">then</span>
        ffi.cdef <span class="string">[[
            int CopyFileA(const char *src, const char *dest, int iovr);
            int MoveFileA(const char *src, const char *dest);
            int GetLastError();
        ]]</span>
        CopyFile = ffi.C.CopyFileA
        MoveFile = ffi.C.MoveFileA
        GetLastError = ffi.C.GetLastError
    <span class="keyword">end</span>
    win32_errors = {
        ERROR_FILE_NOT_FOUND    =         <span class="number">2</span>,
        ERROR_PATH_NOT_FOUND    =         <span class="number">3</span>,
        ERROR_ACCESS_DENIED    =          <span class="number">5</span>,
        ERROR_WRITE_PROTECT    =          <span class="number">19</span>,
        ERROR_BAD_UNIT         =          <span class="number">20</span>,
        ERROR_NOT_READY        =          <span class="number">21</span>,
        ERROR_WRITE_FAULT      =          <span class="number">29</span>,
        ERROR_READ_FAULT       =          <span class="number">30</span>,
        ERROR_SHARING_VIOLATION =         <span class="number">32</span>,
        ERROR_LOCK_VIOLATION    =         <span class="number">33</span>,
        ERROR_HANDLE_DISK_FULL  =         <span class="number">39</span>,
        ERROR_BAD_NETPATH       =         <span class="number">53</span>,
        ERROR_NETWORK_BUSY      =         <span class="number">54</span>,
        ERROR_DEV_NOT_EXIST     =         <span class="number">55</span>,
        ERROR_FILE_EXISTS       =         <span class="number">80</span>,
        ERROR_OPEN_FAILED       =         <span class="number">110</span>,
        ERROR_INVALID_NAME      =         <span class="number">123</span>,
        ERROR_BAD_PATHNAME      =         <span class="number">161</span>,
        ERROR_ALREADY_EXISTS    =         <span class="number">183</span>,
    }
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> two_arguments (f1,f2)
    <span class="keyword">return</span> quote_argument(f1)..<span class="string">' '</span>..quote_argument(f2)
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> file_op (is_copy,src,dest,flag)
    <span class="keyword">if</span> flag == <span class="number">1</span> <span class="keyword">and</span> path.exists(dest) <span class="keyword">then</span>
        <span class="keyword">return</span> <span class="keyword">false</span>,<span class="string">"cannot overwrite destination"</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> is_windows <span class="keyword">then</span>
        <span class="comment">-- if we haven't tried to load Alien/LuaJIT FFI before, then do so
</span>        find_ffi_copyfile()
        <span class="comment">-- fallback if there's no Alien, just use DOS commands *shudder*
</span>        <span class="comment">-- 'rename' involves a copy and then deleting the source.
</span>        <span class="keyword">if</span> <span class="keyword">not</span> CopyFile <span class="keyword">then</span>
            src = path.normcase(src)
            dest = path.normcase(dest)
            <span class="keyword">local</span> cmd = is_copy <span class="keyword">and</span> <span class="string">'copy'</span> <span class="keyword">or</span> <span class="string">'rename'</span>
            <span class="keyword">local</span> res, err = execute_command(<span class="string">'copy'</span>,two_arguments(src,dest))
            <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span>,err <span class="keyword">end</span>
            <span class="keyword">if</span> <span class="keyword">not</span> is_copy <span class="keyword">then</span>
                <span class="keyword">return</span> execute_command(<span class="string">'del'</span>,quote_argument(src))
            <span class="keyword">end</span>
            <span class="keyword">return</span> <span class="keyword">true</span>
        <span class="keyword">else</span>
            <span class="keyword">if</span> path.isdir(dest) <span class="keyword">then</span>
                dest = path.join(dest,path.basename(src))
            <span class="keyword">end</span>
			<span class="keyword">local</span> ret
            <span class="keyword">if</span> is_copy <span class="keyword">then</span> ret = CopyFile(src,dest,flag)
            <span class="keyword">else</span> ret = MoveFile(src,dest) <span class="keyword">end</span>
            <span class="keyword">if</span> ret == <span class="number">0</span> <span class="keyword">then</span>
                <span class="keyword">local</span> err = GetLastError()
                <span class="keyword">for</span> name,value <span class="keyword">in</span> <span class="global">pairs</span>(win32_errors) <span class="keyword">do</span>
                    <span class="keyword">if</span> value == err <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span>,name <span class="keyword">end</span>
                <span class="keyword">end</span>
                <span class="keyword">return</span> <span class="keyword">false</span>,<span class="string">"Error #"</span>..err
            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">else</span> <span class="comment">-- for Unix, just use cp for now
</span>        <span class="keyword">return</span> execute_command(is_copy <span class="keyword">and</span> <span class="string">'cp'</span> <span class="keyword">or</span> <span class="string">'mv'</span>,
            two_arguments(src,dest))
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- copy a file.
</span><span class="comment">-- @string src source file
</span><span class="comment">-- @string dest destination file or directory
</span><span class="comment">-- @bool flag true if you want to force the copy (default)
</span><span class="comment">-- @treturn bool operation succeeded
</span><span class="comment">-- @raise src and dest must be strings
</span><span class="keyword">function</span> dir.copyfile (src,dest,flag)
    assert_string(<span class="number">1</span>,src)
    assert_string(<span class="number">2</span>,dest)
    flag = flag==<span class="keyword">nil</span> <span class="keyword">or</span> flag<a id="243"></a>
    <span class="keyword">return</span> file_op(<span class="keyword">true</span>,src,dest,flag <span class="keyword">and</span> <span class="number">0</span> <span class="keyword">or</span> <span class="number">1</span>)
<span class="keyword">end</span>

<span class="comment">--- move a file.
</span><span class="comment">-- @string src source file
</span><span class="comment">-- @string dest destination file or directory
</span><span class="comment">-- @treturn bool operation succeeded
</span><span class="comment">-- @raise src and dest must be strings
</span><span class="keyword">function</span> dir.movefile (src,dest)
    assert_string(<span class="number">1</span>,src)
    assert_string(<span class="number">2</span>,dest)
    <span class="keyword">return</span> file_op(<span class="keyword">false</span>,src,dest,<span class="number">0</span>)<a id="255"></a>
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> _dirfiles(dir,attrib)
    <span class="keyword">local</span> dirs = {}
    <span class="keyword">local</span> files = {}
    <span class="keyword">for</span> f <span class="keyword">in</span> ldir(dir) <span class="keyword">do</span>
        <span class="keyword">if</span> f ~= <span class="string">'.'</span> <span class="keyword">and</span> f ~= <span class="string">'..'</span> <span class="keyword">then</span>
            <span class="keyword">local</span> p = path.join(dir,f)
            <span class="keyword">local</span> mode = attrib(p,<span class="string">'mode'</span>)
            <span class="keyword">if</span> mode==<span class="string">'directory'</span> <span class="keyword">then</span>
                append(dirs,f)
            <span class="keyword">else</span>
                append(files,f)
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="global">setmetatable</span>(dirs,List),<span class="global">setmetatable</span>(files,List)
<span class="keyword">end</span>


<span class="keyword">local</span> <span class="keyword">function</span> _walker(root,bottom_up,attrib)
    <span class="keyword">local</span> dirs,files = _dirfiles(root,attrib)
    <span class="keyword">if</span> <span class="keyword">not</span> bottom_up <span class="keyword">then</span> yield(root,dirs,files) <span class="keyword">end</span>
    <span class="keyword">for</span> i,d <span class="keyword">in</span> <span class="global">ipairs</span>(dirs) <span class="keyword">do</span>
        _walker(root..path.sep..d,bottom_up,attrib)
    <span class="keyword">end</span>
    <span class="keyword">if</span> bottom_up <span class="keyword">then</span> yield(root,dirs,files) <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- return an iterator which walks through a directory tree starting at root.
</span><span class="comment">-- The iterator returns (root,dirs,files)
</span><span class="comment">-- Note that dirs and files are lists of names (i.e. you must say path.join(root,d)
</span><span class="comment">-- to get the actual full path)
</span><span class="comment">-- If bottom_up is false (or not present), then the entries at the current level are returned
</span><span class="comment">-- before we go deeper. This means that you can modify the returned list of directories before
</span><span class="comment">-- continuing.
</span><span class="comment">-- This is a clone of os.walk from the Python libraries.
</span><span class="comment">-- @string root A starting directory
</span><span class="comment">-- @bool bottom_up False if we start listing entries immediately.
</span><span class="comment">-- @bool follow_links follow symbolic links
</span><span class="comment">-- @return an iterator returning root,dirs,files
</span><span class="comment">-- @raise root must be a directory
</span><span class="keyword">function</span> dir.walk(root,bottom_up,follow_links)
    assert_dir(<span class="number">1</span>,root)
    <span class="keyword">local</span> attrib
    <span class="keyword">if</span> path.is_windows <span class="keyword">or</span> <span class="keyword">not</span> follow_links <span class="keyword">then</span><a id="301"></a>
        attrib = path.attrib
    <span class="keyword">else</span>
        attrib = path.link_attrib
    <span class="keyword">end</span>
    <span class="keyword">return</span> wrap(<span class="keyword">function</span> () _walker(root,bottom_up,attrib) <span class="keyword">end</span>)
<span class="keyword">end</span>

<span class="comment">--- remove a whole directory tree.
</span><span class="comment">-- @string fullpath A directory path
</span><span class="comment">-- @return true or nil
</span><span class="comment">-- @return error if failed
</span><span class="comment">-- @raise fullpath must be a string
</span><span class="keyword">function</span> dir.rmtree(fullpath)
    assert_dir(<span class="number">1</span>,fullpath)
    <span class="keyword">if</span> path.islink(fullpath) <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span>,<span class="string">'will not follow symlink'</span> <span class="keyword">end</span>
    <span class="keyword">for</span> root,dirs,files <span class="keyword">in</span> dir.walk(fullpath,<span class="keyword">true</span>) <span class="keyword">do</span><a id="317"></a>
        <span class="keyword">for</span> i,f <span class="keyword">in</span> <span class="global">ipairs</span>(files) <span class="keyword">do</span>
            remove(path.join(root,f))
        <span class="keyword">end</span>
        rmdir(root)
    <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="keyword">true</span>
<span class="keyword">end</span>

<span class="keyword">local</span> dirpat
<span class="keyword">if</span> path.is_windows <span class="keyword">then</span>
    dirpat = <span class="string">'(.+)\\[^\\]+$'</span>
<span class="keyword">else</span>
    dirpat = <span class="string">'(.+)/[^/]+$'</span>
<span class="keyword">end</span>

<span class="keyword">local</span> _makepath
<span class="keyword">function</span> _makepath(p)
    <span class="comment">-- windows root drive case
</span>    <span class="keyword">if</span> p:find <span class="string">'^%a:[\\]*$'</span> <span class="keyword">then</span>
        <span class="keyword">return</span> <span class="keyword">true</span>
    <span class="keyword">end</span>
   <span class="keyword">if</span> <span class="keyword">not</span> path.isdir(p) <span class="keyword">then</span>
    <span class="keyword">local</span> subp = p:match(dirpat)
    <span class="keyword">local</span> ok, err = _makepath(subp)
    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span>, err <span class="keyword">end</span>
    <span class="keyword">return</span> mkdir(p)
   <span class="keyword">else</span>
    <span class="keyword">return</span> <span class="keyword">true</span>
   <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- create a directory path.
</span><span class="comment">-- This will create subdirectories as necessary!
</span><span class="comment">-- @string p A directory path
</span><span class="comment">-- @return true on success, nil + errormsg on failure
</span><span class="comment">-- @raise failure to create
</span><span class="keyword">function</span> dir.makepath (p)
    assert_string(<span class="number">1</span>,p)
    <span class="keyword">return</span> _makepath(path.normcase(path.abspath(p)))
<span class="keyword">end</span>


<span class="comment">--- clone a directory tree. Will always try to create a new directory structure
</span><span class="comment">-- if necessary.
</span><span class="comment">-- @string path1 the base path of the source tree
</span><span class="comment">-- @string path2 the new base path for the destination
</span><span class="comment">-- @func file_fun an optional function to apply on all files
</span><span class="comment">-- @bool verbose an optional boolean to control the verbosity of the output.
</span><span class="comment">--  It can also be a logging function that behaves like print()
</span><span class="comment">-- @return true, or nil
</span><span class="comment">-- @return error message, or list of failed directory creations
</span><span class="comment">-- @return list of failed file operations
</span><span class="comment">-- @raise path1 and path2 must be strings
</span><span class="comment">-- @usage clonetree('.','../backup',copyfile)
</span><span class="keyword">function</span> dir.clonetree (path1,path2,file_fun,verbose)
    assert_string(<span class="number">1</span>,path1)
    assert_string(<span class="number">2</span>,path2)
    <span class="keyword">if</span> verbose == <span class="keyword">true</span> <span class="keyword">then</span> verbose = <span class="global">print</span> <span class="keyword">end</span>
    <span class="keyword">local</span> abspath,normcase,isdir,join = path.abspath,path.normcase,path.isdir,path.join
    <span class="keyword">local</span> faildirs,failfiles = {},{}
    <span class="keyword">if</span> <span class="keyword">not</span> isdir(path1) <span class="keyword">then</span> <span class="keyword">return</span> raise <span class="string">'source is not a valid directory'</span> <span class="keyword">end</span>
    path1 = abspath(normcase(path1))
    path2 = abspath(normcase(path2))
    <span class="keyword">if</span> verbose <span class="keyword">then</span> verbose(<span class="string">'normalized:'</span>,path1,path2) <span class="keyword">end</span>
    <span class="comment">-- particularly NB that the new path isn't fully contained in the old path
</span>    <span class="keyword">if</span> path1 == path2 <span class="keyword">then</span> <span class="keyword">return</span> raise <span class="string">"paths are the same"</span> <span class="keyword">end</span>
    <span class="keyword">local</span> i1,i2 = path2:find(path1,<span class="number">1</span>,<span class="keyword">true</span>)
    <span class="keyword">if</span> i2 == #path1 <span class="keyword">and</span> path2:sub(i2+<span class="number">1</span>,i2+<span class="number">1</span>) == path.sep <span class="keyword">then</span>
        <span class="keyword">return</span> raise <span class="string">'destination is a subdirectory of the source'</span>
    <span class="keyword">end</span>
    <span class="keyword">local</span> cp = path.common_prefix (path1,path2)
    <span class="keyword">local</span> idx = #cp
    <span class="keyword">if</span> idx == <span class="number">0</span> <span class="keyword">then</span> <span class="comment">-- no common path, but watch out for Windows paths!
</span>        <span class="keyword">if</span> path1:sub(<span class="number">2</span>,<span class="number">2</span>) == <span class="string">':'</span> <span class="keyword">then</span> idx = <span class="number">3</span> <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">for</span> root,dirs,files <span class="keyword">in</span> dir.walk(path1) <span class="keyword">do</span>
        <span class="keyword">local</span> opath = path2..root:sub(idx)
        <span class="keyword">if</span> verbose <span class="keyword">then</span> verbose(<span class="string">'paths:'</span>,opath,root) <span class="keyword">end</span>
        <span class="keyword">if</span> <span class="keyword">not</span> isdir(opath) <span class="keyword">then</span>
            <span class="keyword">local</span> ret = dir.makepath(opath)
            <span class="keyword">if</span> <span class="keyword">not</span> ret <span class="keyword">then</span> append(faildirs,opath) <span class="keyword">end</span>
            <span class="keyword">if</span> verbose <span class="keyword">then</span> verbose(<span class="string">'creating:'</span>,opath,ret) <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span> file_fun <span class="keyword">then</span>
            <span class="keyword">for</span> i,f <span class="keyword">in</span> <span class="global">ipairs</span>(files) <span class="keyword">do</span>
                <span class="keyword">local</span> p1 = join(root,f)
                <span class="keyword">local</span> p2 = join(opath,f)
                <span class="keyword">local</span> ret = file_fun(p1,p2)
                <span class="keyword">if</span> <span class="keyword">not</span> ret <span class="keyword">then</span> append(failfiles,p2) <span class="keyword">end</span>
                <span class="keyword">if</span> verbose <span class="keyword">then</span>
                    verbose(<span class="string">'files:'</span>,p1,p2,ret)
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="keyword">true</span>,faildirs,failfiles
<span class="keyword">end</span>

<span class="comment">--- return an iterator over all entries in a directory tree
</span><span class="comment">-- @string d a directory
</span><span class="comment">-- @return an iterator giving pathname and mode (true for dir, false otherwise)
</span><span class="comment">-- @raise d must be a non-empty string
</span><span class="keyword">function</span> dir.dirtree( d )
    <span class="global">assert</span>( d <span class="keyword">and</span> d ~= <span class="string">""</span>, <span class="string">"directory parameter is missing or empty"</span> )
    <span class="keyword">local</span> exists, isdir = path.exists, path.isdir
    <span class="keyword">local</span> sep = path.sep

    <span class="keyword">local</span> last = sub ( d, -<span class="number">1</span> )
    <span class="keyword">if</span> last == sep <span class="keyword">or</span> last == <span class="string">'/'</span> <span class="keyword">then</span>
        d = sub( d, <span class="number">1</span>, -<span class="number">2</span> )
    <span class="keyword">end</span>

    <span class="keyword">local</span> <span class="keyword">function</span> yieldtree( dir )
        <span class="keyword">for</span> entry <span class="keyword">in</span> ldir( dir ) <span class="keyword">do</span>
            <span class="keyword">if</span> entry ~= <span class="string">"."</span> <span class="keyword">and</span> entry ~= <span class="string">".."</span> <span class="keyword">then</span>
                entry = dir .. sep .. entry
                <span class="keyword">if</span> exists(entry) <span class="keyword">then</span>  <span class="comment">-- Just in case a symlink is broken.
</span>                    <span class="keyword">local</span> is_dir = isdir(entry)
                    yield( entry, is_dir )
                    <span class="keyword">if</span> is_dir <span class="keyword">then</span>
                        yieldtree( entry )
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">return</span> wrap( <span class="keyword">function</span>() yieldtree( d ) <span class="keyword">end</span> )
<span class="keyword">end</span>


<span class="comment">---	Recursively returns all the file starting at _path_. It can optionally take a shell pattern and
</span><span class="comment">--	only returns files that match _pattern_. If a pattern is given it will do a case insensitive search.
</span><span class="comment">--	@string start_path  A directory. If not given, all files in current directory are returned.
</span><span class="comment">--	@string pattern A shell pattern. If not given, all files are returned.
</span><span class="comment">--	@treturn List(string) containing all the files found recursively starting at _path_ and filtered by _pattern_.
</span><span class="comment">-- @raise start_path must be a directory
</span><span class="keyword">function</span> dir.getallfiles( start_path, pattern )
    assert_dir(<span class="number">1</span>,start_path)
    pattern = pattern <span class="keyword">or</span> <span class="string">""</span>

    <span class="keyword">local</span> files = {}
    <span class="keyword">local</span> normcase = path.normcase
    <span class="keyword">for</span> filename, mode <span class="keyword">in</span> dir.dirtree( start_path ) <span class="keyword">do</span>
        <span class="keyword">if</span> <span class="keyword">not</span> mode <span class="keyword">then</span>
            <span class="keyword">local</span> mask = filemask( pattern )
            <span class="keyword">if</span> normcase(filename):find( mask ) <span class="keyword">then</span>
                files[#files + <span class="number">1</span>] = filename
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">return</span> <span class="global">setmetatable</span>(files,List)
<span class="keyword">end</span>

<span class="keyword">return</span> dir</pre>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.3</a></i>
<i style="float:right;">Last updated 2014-11-01 18:36:39 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
