<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Penlight Documentation</title>
    <link rel="stylesheet" href="../ldoc_fixed.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Penlight</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Source</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../source/app.lua.html">app.lua</a></li>
  <li><a href="../source/array2d.lua.html">array2d.lua</a></li>
  <li><a href="../source/class.lua.html">class.lua</a></li>
  <li><a href="../source/compat.lua.html">compat.lua</a></li>
  <li><a href="../source/comprehension.lua.html">comprehension.lua</a></li>
  <li><a href="../source/config.lua.html">config.lua</a></li>
  <li><a href="../source/data.lua.html">data.lua</a></li>
  <li><a href="../source/date.lua.html">date.lua</a></li>
  <li><a href="../source/dir.lua.html">dir.lua</a></li>
  <li><a href="../source/file.lua.html">file.lua</a></li>
  <li><a href="../source/func.lua.html">func.lua</a></li>
  <li><a href="../source/import_into.lua.html">import_into.lua</a></li>
  <li><a href="../source/init.lua.html">init.lua</a></li>
  <li><a href="../source/input.lua.html">input.lua</a></li>
  <li><a href="../source/lapp.lua.html">lapp.lua</a></li>
  <li><a href="../source/lexer.lua.html">lexer.lua</a></li>
  <li><a href="../source/list.lua.html">list.lua</a></li>
  <li><a href="../source/luabalanced.lua.html">luabalanced.lua</a></li>
  <li><a href="../source/map.lua.html">map.lua</a></li>
  <li><a href="../source/multimap.lua.html">multimap.lua</a></li>
  <li><a href="../source/operator.lua.html">operator.lua</a></li>
  <li><a href="../source/orderedmap.lua.html">orderedmap.lua</a></li>
  <li><a href="../source/path.lua.html">path.lua</a></li>
  <li><a href="../source/permute.lua.html">permute.lua</a></li>
  <li><a href="../source/pretty.lua.html">pretty.lua</a></li>
  <li><a href="../source/seesubst.lua.html">seesubst.lua</a></li>
  <li><a href="../source/seq.lua.html">seq.lua</a></li>
  <li><a href="../source/set.lua.html">set.lua</a></li>
  <li><a href="../source/sip.lua.html">sip.lua</a></li>
  <li><a href="../source/sipscan.lua.html">sipscan.lua</a></li>
  <li><a href="../source/strict.lua.html">strict.lua</a></li>
  <li><a href="../source/stringio.lua.html">stringio.lua</a></li>
  <li><a href="../source/stringx.lua.html">stringx.lua</a></li>
  <li><a href="../source/symbols.lua.html">symbols.lua</a></li>
  <li><a href="../source/tablex.lua.html">tablex.lua</a></li>
  <li><a href="../source/template.lua.html">template.lua</a></li>
  <li><a href="../source/test-cmp.lua.html">test-cmp.lua</a></li>
  <li><a href="../source/test-data.lua.html">test-data.lua</a></li>
  <li><a href="../source/test-listcallbacks.lua.html">test-listcallbacks.lua</a></li>
  <li><a href="../source/test-pretty.lua.html">test-pretty.lua</a></li>
  <li><a href="../source/test-symbols.lua.html">test-symbols.lua</a></li>
  <li><a href="../source/test.lua.html">test.lua</a></li>
  <li><a href="../source/testapp.lua.html">testapp.lua</a></li>
  <li><a href="../source/testclone.lua.html">testclone.lua</a></li>
  <li><a href="../source/testconfig.lua.html">testconfig.lua</a></li>
  <li><a href="../source/testglobal.lua.html">testglobal.lua</a></li>
  <li><a href="../source/testinputfields.lua.html">testinputfields.lua</a></li>
  <li><a href="../source/testinputfields2.lua.html">testinputfields2.lua</a></li>
  <li><a href="../source/testxml.lua.html">testxml.lua</a></li>
  <li><a href="../source/text.lua.html">text.lua</a></li>
  <li><a href="../source/types.lua.html">types.lua</a></li>
  <li><a href="../source/url.lua.html">url.lua</a></li>
  <li><strong>utils.lua</strong></li>
  <li><a href="../source/which.lua.html">which.lua</a></li>
  <li><a href="../source/xml.lua.html">xml.lua</a></li>
</ul>
<h2>Libraries</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../libraries/pl.html">pl</a></li>
  <li><a href="../libraries/pl.app.html">pl.app</a></li>
  <li><a href="../libraries/pl.array2d.html">pl.array2d</a></li>
  <li><a href="../libraries/pl.class.html">pl.class</a></li>
  <li><a href="../libraries/pl.compat.html">pl.compat</a></li>
  <li><a href="../libraries/pl.comprehension.html">pl.comprehension</a></li>
  <li><a href="../libraries/pl.config.html">pl.config</a></li>
  <li><a href="../libraries/pl.data.html">pl.data</a></li>
  <li><a href="../libraries/pl.dir.html">pl.dir</a></li>
  <li><a href="../libraries/pl.file.html">pl.file</a></li>
  <li><a href="../libraries/pl.func.html">pl.func</a></li>
  <li><a href="../libraries/pl.import_into.html">pl.import_into</a></li>
  <li><a href="../libraries/pl.input.html">pl.input</a></li>
  <li><a href="../libraries/pl.lapp.html">pl.lapp</a></li>
  <li><a href="../libraries/pl.lexer.html">pl.lexer</a></li>
  <li><a href="../libraries/pl.luabalanced.html">pl.luabalanced</a></li>
  <li><a href="../libraries/pl.operator.html">pl.operator</a></li>
  <li><a href="../libraries/pl.path.html">pl.path</a></li>
  <li><a href="../libraries/pl.permute.html">pl.permute</a></li>
  <li><a href="../libraries/pl.pretty.html">pl.pretty</a></li>
  <li><a href="../libraries/pl.seq.html">pl.seq</a></li>
  <li><a href="../libraries/pl.sip.html">pl.sip</a></li>
  <li><a href="../libraries/pl.strict.html">pl.strict</a></li>
  <li><a href="../libraries/pl.stringio.html">pl.stringio</a></li>
  <li><a href="../libraries/pl.stringx.html">pl.stringx</a></li>
  <li><a href="../libraries/pl.tablex.html">pl.tablex</a></li>
  <li><a href="../libraries/pl.template.html">pl.template</a></li>
  <li><a href="../libraries/pl.test.html">pl.test</a></li>
  <li><a href="../libraries/pl.text.html">pl.text</a></li>
  <li><a href="../libraries/pl.types.html">pl.types</a></li>
  <li><a href="../libraries/pl.url.html">pl.url</a></li>
  <li><a href="../libraries/pl.utils.html">pl.utils</a></li>
  <li><a href="../libraries/pl.xml.html">pl.xml</a></li>
</ul>
<h2>Classes</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../classes/pl.Date.html">pl.Date</a></li>
  <li><a href="../classes/pl.List.html">pl.List</a></li>
  <li><a href="../classes/pl.Map.html">pl.Map</a></li>
  <li><a href="../classes/pl.MultiMap.html">pl.MultiMap</a></li>
  <li><a href="../classes/pl.OrderedMap.html">pl.OrderedMap</a></li>
  <li><a href="../classes/pl.Set.html">pl.Set</a></li>
</ul>
<h2>Manual</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../manual/01-introduction.md.html">Introduction</a></li>
  <li><a href="../manual/02-arrays.md.html">Tables and Arrays</a></li>
  <li><a href="../manual/03-strings.md.html">Strings. Higher-level operations on strings.</a></li>
  <li><a href="../manual/04-paths.md.html">Paths and Directories</a></li>
  <li><a href="../manual/05-dates.md.html">Date and Time</a></li>
  <li><a href="../manual/06-data.md.html">Data</a></li>
  <li><a href="../manual/07-functional.md.html">Functional Programming</a></li>
  <li><a href="../manual/08-additional.md.html">Additional Libraries</a></li>
  <li><a href="../manual/09-discussion.md.html">Technical Choices</a></li>
</ul>
<h2>Examples</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../examples/seesubst.lua.html">seesubst.lua</a></li>
  <li><a href="../examples/sipscan.lua.html">sipscan.lua</a></li>
  <li><a href="../examples/symbols.lua.html">symbols.lua</a></li>
  <li><a href="../examples/test-cmp.lua.html">test-cmp.lua</a></li>
  <li><a href="../examples/test-data.lua.html">test-data.lua</a></li>
  <li><a href="../examples/test-listcallbacks.lua.html">test-listcallbacks.lua</a></li>
  <li><a href="../examples/test-pretty.lua.html">test-pretty.lua</a></li>
  <li><a href="../examples/test-symbols.lua.html">test-symbols.lua</a></li>
  <li><a href="../examples/testapp.lua.html">testapp.lua</a></li>
  <li><a href="../examples/testclone.lua.html">testclone.lua</a></li>
  <li><a href="../examples/testconfig.lua.html">testconfig.lua</a></li>
  <li><a href="../examples/testglobal.lua.html">testglobal.lua</a></li>
  <li><a href="../examples/testinputfields.lua.html">testinputfields.lua</a></li>
  <li><a href="../examples/testinputfields2.lua.html">testinputfields2.lua</a></li>
  <li><a href="../examples/testxml.lua.html">testxml.lua</a></li>
  <li><a href="../examples/which.lua.html">which.lua</a></li>
</ul>

</div>

<div id="content">

    <h2>utils.lua</h2>
<pre>
<span class="comment">--- Generally useful routines.
</span><span class="comment">-- See  <a href="../manual/01-introduction.md.html#Generally_useful_functions_">the Guide</a>.
</span><span class="comment">-- @module pl.utils
</span><span class="keyword">local</span> format,gsub,byte = <span class="global">string</span>.format,<span class="global">string</span>.gsub,<span class="global">string</span>.byte
<span class="keyword">local</span> compat = <span class="global">require</span> <span class="string">'pl.compat'</span>
<span class="keyword">local</span> clock = <span class="global">os</span>.clock
<span class="keyword">local</span> stdout = <span class="global">io</span>.stdout
<span class="keyword">local</span> append = <span class="global">table</span>.insert
<span class="keyword">local</span> <span class="global">unpack</span> = <span class="global">rawget</span>(_G,<span class="string">'unpack'</span>) <span class="keyword">or</span> <span class="global">rawget</span>(<span class="global">table</span>,<span class="string">'unpack'</span>)

<span class="keyword">local</span> collisions = {}

<span class="keyword">local</span> utils = {
    _VERSION = <span class="string">"1.2.1"</span>,
    lua51 = compat.lua51,
    <span class="global">setfenv</span> = compat.<span class="global">setfenv</span>,
    <span class="global">getfenv</span> = compat.<span class="global">getfenv</span>,
    <span class="global">load</span> = compat.<span class="global">load</span>,
    execute = compat.execute,
    dir_separator = _G.<span class="global">package</span>.config:sub(<span class="number">1</span>,<span class="number">1</span>),
    <span class="global">unpack</span> = <span class="global">unpack</span>
}

<span class="comment">--- end this program gracefully.
</span><span class="comment">-- @param code The exit code or a message to be printed
</span><span class="comment">-- @param ... extra arguments for message's format'
</span><a id="28"></a><span class="comment">-- @see utils.fprintf
</span><span class="keyword">function</span> utils.quit(code,...)
    <span class="keyword">if</span> <span class="global">type</span>(code) == <span class="string">'string'</span> <span class="keyword">then</span>
        utils.fprintf(<span class="global">io</span>.stderr,code,...)
        code = -<span class="number">1</span>
    <span class="keyword">else</span>
        utils.fprintf(<span class="global">io</span>.stderr,...)
    <span class="keyword">end</span>
    <span class="global">io</span>.stderr:write(<span class="string">'\n'</span>)
    <span class="global">os</span>.exit(code)
<span class="keyword">end</span>

<span class="comment">--- print an arbitrary number of arguments using a format.
</span><span class="comment">-- @param fmt The format (see string.format)
</span><a id="42"></a><span class="comment">-- @param ... Extra arguments for format
</span><span class="keyword">function</span> utils.printf(fmt,...)
    utils.assert_string(<span class="number">1</span>,fmt)
    utils.fprintf(stdout,fmt,...)
<span class="keyword">end</span>

<span class="comment">--- write an arbitrary number of arguments to a file using a format.
</span><span class="comment">-- @param f File handle to write to.
</span><span class="comment">-- @param fmt The format (see string.format).
</span><a id="51"></a><span class="comment">-- @param ... Extra arguments for format
</span><span class="keyword">function</span> utils.fprintf(f,fmt,...)
    utils.assert_string(<span class="number">2</span>,fmt)
    f:write(format(fmt,...))
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> import_symbol(T,k,v,libname)
    <span class="keyword">local</span> key = <span class="global">rawget</span>(T,k)
    <span class="comment">-- warn about collisions!
</span>    <span class="keyword">if</span> key <span class="keyword">and</span> k ~= <span class="string">'_M'</span> <span class="keyword">and</span> k ~= <span class="string">'_NAME'</span> <span class="keyword">and</span> k ~= <span class="string">'_PACKAGE'</span> <span class="keyword">and</span> k ~= <span class="string">'_VERSION'</span> <span class="keyword">then</span>
        utils.printf(<span class="string">"warning: '%s.%s' overrides existing symbol\n"</span>,libname,k)
    <span class="keyword">end</span>
    <span class="global">rawset</span>(T,k,v)
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> lookup_lib(T,t)
    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(T) <span class="keyword">do</span>
        <span class="keyword">if</span> v == t <span class="keyword">then</span> <span class="keyword">return</span> k <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="string">'?'</span>
<span class="keyword">end</span>

<span class="keyword">local</span> already_imported = {}

<span class="comment">--- take a table and 'inject' it into the local namespace.
</span><span class="comment">-- @param t The Table
</span><a id="77"></a><span class="comment">-- @param T An optional destination table (defaults to callers environment)
</span><span class="keyword">function</span> utils.import(t,T)
    T = T <span class="keyword">or</span> _G
    t = t <span class="keyword">or</span> utils
    <span class="keyword">if</span> <span class="global">type</span>(t) == <span class="string">'string'</span> <span class="keyword">then</span>
        t = <span class="global">require</span> (t)
    <span class="keyword">end</span>
    <span class="keyword">local</span> libname = lookup_lib(T,t)
    <span class="keyword">if</span> already_imported[t] <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span>
    already_imported[t] = libname
    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(t) <span class="keyword">do</span>
        import_symbol(T,k,v,libname)
    <span class="keyword">end</span>
<span class="keyword">end</span>

utils.patterns = {
    FLOAT = <span class="string">'[%+%-%d]%d*%.?%d*[eE]?[%+%-]?%d*'</span>,
    INTEGER = <span class="string">'[+%-%d]%d*'</span>,
    IDEN = <span class="string">'[%a_][%w_]*'</span>,
    FILE = <span class="string">'[%a%.\\][:%][%w%._%-\\]*'</span>
}

<span class="comment">--- escape any 'magic' characters in a string
</span><a id="100"></a><span class="comment">-- @param s The input string
</span><span class="keyword">function</span> utils.escape(s)
    utils.assert_string(<span class="number">1</span>,s)
    <span class="keyword">return</span> (s:gsub(<span class="string">'[%-%.%+%[%]%(%)%$%^%%%?%*]'</span>,<span class="string">'%%%1'</span>))
<span class="keyword">end</span>

<span class="comment">--- return either of two values, depending on a condition.
</span><span class="comment">-- @param cond A condition
</span><span class="comment">-- @param value1 Value returned if cond is true
</span><a id="109"></a><span class="comment">-- @param value2 Value returned if cond is false (can be optional)
</span><span class="keyword">function</span> utils.choose(cond,value1,value2)
    <span class="keyword">if</span> cond <span class="keyword">then</span> <span class="keyword">return</span> value1
    <span class="keyword">else</span> <span class="keyword">return</span> value2
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">local</span> raise

<span class="comment">--- return the contents of a file as a string
</span><span class="comment">-- @param filename The file path
</span><span class="comment">-- @param is_bin open in binary mode
</span><a id="121"></a><span class="comment">-- @return file contents
</span><span class="keyword">function</span> utils.readfile(filename,is_bin)
    <span class="keyword">local</span> mode = is_bin <span class="keyword">and</span> <span class="string">'b'</span> <span class="keyword">or</span> <span class="string">''</span>
    utils.assert_string(<span class="number">1</span>,filename)
    <span class="keyword">local</span> f,err = <span class="global">io</span>.open(filename,<span class="string">'r'</span>..mode)
    <span class="keyword">if</span> <span class="keyword">not</span> f <span class="keyword">then</span> <span class="keyword">return</span> utils.raise (err) <span class="keyword">end</span>
    <span class="keyword">local</span> res,err = f:read(<span class="string">'*a'</span>)
    f:close()
    <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">then</span> <span class="keyword">return</span> raise (err) <span class="keyword">end</span>
    <span class="keyword">return</span> res
<span class="keyword">end</span>

<span class="comment">--- write a string to a file
</span><span class="comment">-- @param filename The file path
</span><span class="comment">-- @param str The string
</span><span class="comment">-- @return true or nil
</span><span class="comment">-- @return error message
</span><a id="138"></a><span class="comment">-- @raise error if filename or str aren't strings
</span><span class="keyword">function</span> utils.writefile(filename,str)
    utils.assert_string(<span class="number">1</span>,filename)
    utils.assert_string(<span class="number">2</span>,str)
    <span class="keyword">local</span> f,err = <span class="global">io</span>.open(filename,<span class="string">'w'</span>)
    <span class="keyword">if</span> <span class="keyword">not</span> f <span class="keyword">then</span> <span class="keyword">return</span> raise(err) <span class="keyword">end</span>
    f:write(str)
    f:close()
    <span class="keyword">return</span> <span class="keyword">true</span>
<span class="keyword">end</span>

<span class="comment">--- return the contents of a file as a list of lines
</span><span class="comment">-- @param filename The file path
</span><span class="comment">-- @return file contents as a table
</span><a id="152"></a><span class="comment">-- @raise errror if filename is not a string
</span><span class="keyword">function</span> utils.readlines(filename)
    utils.assert_string(<span class="number">1</span>,filename)
    <span class="keyword">local</span> f,err = <span class="global">io</span>.open(filename,<span class="string">'r'</span>)
    <span class="keyword">if</span> <span class="keyword">not</span> f <span class="keyword">then</span> <span class="keyword">return</span> raise(err) <span class="keyword">end</span>
    <span class="keyword">local</span> res = {}
    <span class="keyword">for</span> line <span class="keyword">in</span> f:lines() <span class="keyword">do</span>
        append(res,line)
    <span class="keyword">end</span>
    f:close()
    <span class="keyword">return</span> res
<span class="keyword">end</span>

<span class="comment">--- split a string into a list of strings separated by a delimiter.
</span><span class="comment">-- @param s The input string
</span><span class="comment">-- @param re A Lua string pattern; defaults to '%s+'
</span><span class="comment">-- @param plain don't use Lua patterns
</span><span class="comment">-- @param n optional maximum number of splits
</span><span class="comment">-- @return a list-like table
</span><a id="171"></a><span class="comment">-- @raise error if s is not a string
</span><span class="keyword">function</span> utils.split(s,re,plain,n)
    utils.assert_string(<span class="number">1</span>,s)
    <span class="keyword">local</span> find,sub,append = <span class="global">string</span>.find, <span class="global">string</span>.sub, <span class="global">table</span>.insert
    <span class="keyword">local</span> i1,ls = <span class="number">1</span>,{}
    <span class="keyword">if</span> <span class="keyword">not</span> re <span class="keyword">then</span> re = <span class="string">'%s+'</span> <span class="keyword">end</span>
    <span class="keyword">if</span> re == <span class="string">''</span> <span class="keyword">then</span> <span class="keyword">return</span> {s} <span class="keyword">end</span>
    <span class="keyword">while</span> <span class="keyword">true</span> <span class="keyword">do</span>
        <span class="keyword">local</span> i2,i3 = find(s,re,i1,plain)
        <span class="keyword">if</span> <span class="keyword">not</span> i2 <span class="keyword">then</span>
            <span class="keyword">local</span> last = sub(s,i1)
            <span class="keyword">if</span> last ~= <span class="string">''</span> <span class="keyword">then</span> append(ls,last) <span class="keyword">end</span>
            <span class="keyword">if</span> #ls == <span class="number">1</span> <span class="keyword">and</span> ls[<span class="number">1</span>] == <span class="string">''</span> <span class="keyword">then</span>
                <span class="keyword">return</span> {}
            <span class="keyword">else</span>
                <span class="keyword">return</span> ls
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        append(ls,sub(s,i1,i2-<span class="number">1</span>))
        <span class="keyword">if</span> n <span class="keyword">and</span> #ls == n <span class="keyword">then</span>
            ls[#ls] = sub(s,i1)
            <span class="keyword">return</span> ls
        <span class="keyword">end</span>
        i1 = i3+<span class="number">1</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- split a string into a number of values.
</span><span class="comment">-- @param s the string
</span><span class="comment">-- @param re the delimiter, default space
</span><span class="comment">-- @return n values
</span><span class="comment">-- @usage first,next = splitv('jane:doe',':')
</span><a id="203"></a><span class="comment">-- @see split
</span><span class="keyword">function</span> utils.splitv (s,re)
    <span class="keyword">return</span> <span class="global">unpack</span>(utils.split(s,re))
<span class="keyword">end</span>

<span class="comment">--- convert an array of values to strings.
</span><span class="comment">-- @param t a list-like table
</span><span class="comment">-- @param temp buffer to use, otherwise allocate
</span><span class="comment">-- @param tostr custom tostring function, called with (value,index).
</span><span class="comment">-- Otherwise use <a href="http://www.lua.org/manual/5.1/manual.html#pdf-tostring">tostring</a>
</span><a id="213"></a><span class="comment">-- @return the converted buffer
</span><span class="keyword">function</span> utils.array_tostring (t,temp,tostr)
    temp, tostr = temp <span class="keyword">or</span> {}, tostr <span class="keyword">or</span> <span class="global">tostring</span>
    <span class="keyword">for</span> i = <span class="number">1</span>,#t <span class="keyword">do</span>
        temp[i] = tostr(t[i],i)
    <span class="keyword">end</span>
    <span class="keyword">return</span> temp
<span class="keyword">end</span>

<span class="comment">--- execute a shell command and return the output.
</span><span class="comment">-- This function redirects the output to tempfiles and returns the content of those files.
</span><span class="comment">-- @param cmd a shell command
</span><span class="comment">-- @param bin boolean, if true, read output as binary file
</span><span class="comment">-- @return true if successful
</span><span class="comment">-- @return actual return code
</span><span class="comment">-- @return stdout output (string)
</span><a id="229"></a><span class="comment">-- @return errout output (string)
</span><span class="keyword">function</span> utils.executeex(cmd, bin)
    <span class="keyword">local</span> mode
    <span class="keyword">local</span> outfile = <span class="global">os</span>.tmpname()
    <span class="keyword">local</span> errfile = <span class="global">os</span>.tmpname()

    <span class="keyword">if</span> utils.dir_separator == <span class="string">'\\' then
        outfile = os.getenv('</span>TEMP<span class="string">')..outfile
        errfile = os.getenv('</span>TEMP<span class="string">')..errfile
    end
    cmd = cmd .. [[ &gt;"]]..outfile..[[" 2&gt;"]]..errfile..[["]]

    local success, retcode = utils.execute(cmd)
    local outcontent = utils.readfile(outfile, bin)
    local errcontent = utils.readfile(errfile, bin)
    os.remove(outfile)
    os.remove(errfile)
    return success, retcode, (outcontent or ""), (errcontent or "")
end

--- '</span>memoize<span class="string">' a function (cache returned value for next call).
-- This is useful if you have a function which is relatively expensive,
-- but you don'</span>t know <span class="keyword">in</span> advance what values will be required, so
<span class="comment">-- building a table upfront is wasteful/impossible.
</span><span class="comment">-- @param func a function of at least one argument
</span><span class="comment">-- @return a function with at least one argument, which is used as the key.
</span><span class="keyword">function</span> utils.memoize(func)
    <span class="keyword">return</span> <span class="global">setmetatable</span>({}, {
        __index = <span class="keyword">function</span>(self, k, ...)
            <span class="keyword">local</span> v = func(k,...)
            self[k] = v
            <span class="keyword">return</span> v
        <span class="keyword">end</span>,
        __call = <span class="keyword">function</span>(self, k) <span class="keyword">return</span> self[k] <span class="keyword">end</span>
    })
<span class="keyword">end</span>


utils.stdmt = {
    List = {_name=<span class="string">'List'</span>}, Map = {_name=<span class="string">'Map'</span>},
    Set = {_name=<span class="string">'Set'</span>}, MultiMap = {_name=<span class="string">'MultiMap'</span>}
}

<span class="keyword">local</span> _function_factories = {}

<span class="comment">--- associate a function factory with a type.
</span><span class="comment">-- A function factory takes an object of the given type and
</span><span class="comment">-- returns a function for evaluating it
</span><span class="comment">-- @tab mt metatable
</span><span class="comment">-- @func fun a callable that returns a function
</span><span class="keyword">function</span> utils.add_function_factory (mt,fun)
    _function_factories[mt] = fun
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> _string_lambda(f)
    <span class="keyword">local</span> raise = utils.raise
    <span class="keyword">if</span> f:find <span class="string">'^|'</span> <span class="keyword">or</span> f:find <span class="string">'_'</span> <span class="keyword">then</span>
        <span class="keyword">local</span> args,body = f:match <span class="string">'|([^|]*)|(.+)'</span>
        <span class="keyword">if</span> f:find <span class="string">'_'</span> <span class="keyword">then</span>
            args = <span class="string">'_'</span>
            body = f
        <span class="keyword">else</span>
            <span class="keyword">if</span> <span class="keyword">not</span> args <span class="keyword">then</span> <span class="keyword">return</span> raise <span class="string">'bad string lambda'</span> <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">local</span> fstr = <span class="string">'return function('</span>..args..<span class="string">') return '</span>..body..<span class="string">' end'</span>
        <span class="keyword">local</span> fn,err = utils.<span class="global">load</span>(fstr)
        <span class="keyword">if</span> <span class="keyword">not</span> fn <span class="keyword">then</span> <span class="keyword">return</span> raise(err) <span class="keyword">end</span>
        fn = fn()
        <span class="keyword">return</span> fn
    <span class="keyword">else</span> <span class="keyword">return</span> raise <span class="string">'not a string lambda'</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- an anonymous function as a string. This string is either of the form
</span><span class="comment">-- '|args| expression' or is a function of one argument, '_'
</span><span class="comment">-- @param lf function as a string
</span><span class="comment">-- @return a function
</span><span class="comment">-- @usage string_lambda '|x|x+1' (2) == 3
</span><span class="comment">-- @usage string_lambda '_+1 (2) == 3
</span><span class="comment">-- @function utils.string_lambda
</span>utils.string_lambda = utils.memoize(_string_lambda)

<span class="keyword">local</span> ops

<span class="comment">--- process a function argument.
</span><span class="comment">-- This is used throughout Penlight and defines what is meant by a function:
</span><span class="comment">-- Something that is callable, or an operator string as defined by &lt;code&gt;pl.operator&lt;/code&gt;,
</span><span class="comment">-- such as '&gt;' or '#'. If a function factory has been registered for the type, it will
</span><span class="comment">-- be called to get the function.
</span><span class="comment">-- @param idx argument index
</span><span class="comment">-- @param f a function, operator string, or callable object
</span><span class="comment">-- @param msg optional error message
</span><span class="comment">-- @return a callable
</span><span class="comment">-- @raise if idx is not a number or if f is not callable
</span><span class="keyword">function</span> utils.function_arg (idx,f,msg)
    utils.assert_arg(<span class="number">1</span>,idx,<span class="string">'number'</span>)
    <span class="keyword">local</span> tp = <span class="global">type</span>(f)
    <span class="keyword">if</span> tp == <span class="string">'function'</span> <span class="keyword">then</span> <span class="keyword">return</span> f <span class="keyword">end</span>  <span class="comment">-- no worries!
</span>    <span class="comment">-- ok, a string can correspond to an operator (like '==')
</span>    <span class="keyword">if</span> tp == <span class="string">'string'</span> <span class="keyword">then</span>
        <span class="keyword">if</span> <span class="keyword">not</span> ops <span class="keyword">then</span> ops = <span class="global">require</span> <span class="string">'pl.operator'</span>.optable <span class="keyword">end</span>
        <span class="keyword">local</span> fn = ops[f]
        <span class="keyword">if</span> fn <span class="keyword">then</span> <span class="keyword">return</span> fn <span class="keyword">end</span>
        <span class="keyword">local</span> fn, err = utils.string_lambda(f)
        <span class="keyword">if</span> <span class="keyword">not</span> fn <span class="keyword">then</span> error(err..<span class="string">': '</span>..f) <span class="keyword">end</span>
        <span class="keyword">return</span> fn
    <span class="keyword">elseif</span> tp == <span class="string">'table'</span> <span class="keyword">or</span> tp == <span class="string">'userdata'</span> <span class="keyword">then</span>
        <span class="keyword">local</span> mt = <span class="global">getmetatable</span>(f)
        <span class="keyword">if</span> <span class="keyword">not</span> mt <span class="keyword">then</span> error(<span class="string">'not a callable object'</span>,<span class="number">2</span>) <span class="keyword">end</span>
        <span class="keyword">local</span> ff = _function_factories[mt]
        <span class="keyword">if</span> <span class="keyword">not</span> ff <span class="keyword">then</span>
            <span class="keyword">if</span> <span class="keyword">not</span> mt.__call <span class="keyword">then</span> error(<span class="string">'not a callable object'</span>,<span class="number">2</span>) <span class="keyword">end</span>
            <span class="keyword">return</span> f
        <span class="keyword">else</span>
            <span class="keyword">return</span> ff(f) <span class="comment">-- we have a function factory for this type!
</span>        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> <span class="keyword">not</span> msg <span class="keyword">then</span> msg = <span class="string">" must be callable"</span> <span class="keyword">end</span>
    <span class="keyword">if</span> idx &gt; <span class="number">0</span> <span class="keyword">then</span>
        error(<span class="string">"argument "</span>..idx..<span class="string">": "</span>..msg,<span class="number">2</span>)
    <span class="keyword">else</span>
        error(msg,<span class="number">2</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- bind the first argument of the function to a value.
</span><span class="comment">-- @param fn a function of at least two values (may be an operator string)
</span><span class="comment">-- @param p a value
</span><span class="comment">-- @return a function such that f(x) is fn(p,x)
</span><span class="comment">-- @raise same as ???
</span><span class="comment">-- @see func.bind1
</span><span class="keyword">function</span> utils.bind1 (fn,p)
    fn = utils.function_arg(<span class="number">1</span>,fn)
    <span class="keyword">return</span> <span class="keyword">function</span>(...) <span class="keyword">return</span> fn(p,...) <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- bind the second argument of the function to a value.
</span><span class="comment">-- @param fn a function of at least two values (may be an operator string)
</span><span class="comment">-- @param p a value
</span><span class="comment">-- @return a function such that f(x) is fn(x,p)
</span><span class="comment">-- @raise same as ???
</span><span class="keyword">function</span> utils.bind2 (fn,p)
    fn = utils.function_arg(<span class="number">1</span>,fn)
    <span class="keyword">return</span> <span class="keyword">function</span>(x,...) <span class="keyword">return</span> fn(x,p,...) <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="comment">--- assert that the given argument is in fact of the correct type.
</span><span class="comment">-- @param n argument index
</span><span class="comment">-- @param val the value
</span><span class="comment">-- @param tp the type
</span><span class="comment">-- @param verify an optional verfication function
</span><span class="comment">-- @param msg an optional custom message
</span><span class="comment">-- @param lev optional stack position for trace, default 2
</span><span class="comment">-- @raise if the argument n is not the correct type
</span><span class="comment">-- @usage assert_arg(1,t,'table')
</span><span class="comment">-- @usage assert_arg(n,val,'string',path.isdir,'not a directory')
</span><span class="keyword">function</span> utils.assert_arg (n,val,tp,verify,msg,lev)
    <span class="keyword">if</span> <span class="global">type</span>(val) ~= tp <span class="keyword">then</span>
        error((<span class="string">"argument %d expected a '%s', got a '%s'"</span>):format(n,tp,<span class="global">type</span>(val)),lev <span class="keyword">or</span> <span class="number">2</span>)
    <span class="keyword">end</span>
    <span class="keyword">if</span> verify <span class="keyword">and</span> <span class="keyword">not</span> verify(val) <span class="keyword">then</span>
        error((<span class="string">"argument %d: '%s' %s"</span>):format(n,val,msg),lev <span class="keyword">or</span> <span class="number">2</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- assert the common case that the argument is a string.
</span><span class="comment">-- @param n argument index
</span><span class="comment">-- @param val a value that must be a string
</span><span class="comment">-- @raise val must be a string
</span><span class="keyword">function</span> utils.assert_string (n,val)
    utils.assert_arg(n,val,<span class="string">'string'</span>,<span class="keyword">nil</span>,<span class="keyword">nil</span>,<span class="number">3</span>)
<span class="keyword">end</span>

<span class="keyword">local</span> err_mode = <span class="string">'default'</span>

<span class="comment">--- control the error strategy used by Penlight.
</span><span class="comment">-- Controls how &lt;code&gt;utils.raise&lt;/code&gt; works; the default is for it
</span><span class="comment">-- to return nil and the error string, but if the mode is 'error' then
</span><span class="comment">-- it will throw an error. If mode is 'quit' it will immediately terminate
</span><span class="comment">-- the program.
</span><span class="comment">-- @param mode - either 'default', 'quit'  or 'error'
</span><span class="comment">-- @see utils.raise
</span><span class="keyword">function</span> utils.on_error (mode)
    <span class="keyword">if</span> ({[<span class="string">'default'</span>] = <span class="number">1</span>, [<span class="string">'quit'</span>] = <span class="number">2</span>, [<span class="string">'error'</span>] = <span class="number">3</span>})[mode] <span class="keyword">then</span>
      err_mode = mode
    <span class="keyword">else</span>
      <span class="comment">-- fail loudly
</span>      <span class="keyword">if</span> err_mode == <span class="string">'default'</span> <span class="keyword">then</span> err_mode = <span class="string">'error'</span> <span class="keyword">end</span>
      utils.raise(<span class="string">"Bad argument expected string; 'default', 'quit', or 'error'. Got '"</span>..<span class="global">tostring</span>(mode)..<span class="string">"'"</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- used by Penlight functions to return errors.  Its global behaviour is controlled
</span><span class="comment">-- by &lt;code&gt;utils.on_error&lt;/code&gt;
</span><span class="comment">-- @param err the error string.
</span><span class="comment">-- @see utils.on_error
</span><span class="keyword">function</span> utils.raise (err)
    <span class="keyword">if</span> err_mode == <span class="string">'default'</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span>,err
    <span class="keyword">elseif</span> err_mode == <span class="string">'quit'</span> <span class="keyword">then</span> utils.quit(err)
    <span class="keyword">else</span> error(err,<span class="number">2</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- is the object of the specified type?.
</span><span class="comment">-- If the type is a string, then use type, otherwise compare with metatable
</span><span class="comment">-- @param obj An object to check
</span><span class="comment">-- @param tp String of what type it should be
</span><span class="keyword">function</span> utils.is_type (obj,tp)
    <span class="keyword">if</span> <span class="global">type</span>(tp) == <span class="string">'string'</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="global">type</span>(obj) == tp <span class="keyword">end</span>
    <span class="keyword">local</span> mt = <span class="global">getmetatable</span>(obj)
    <span class="keyword">return</span> tp == mt
<span class="keyword">end</span>

raise = utils.raise

<span class="comment">--- load a code string or bytecode chunk.
</span><span class="comment">-- @param code Lua code as a string or bytecode
</span><span class="comment">-- @param name for source errors
</span><span class="comment">-- @param mode kind of chunk, 't' for text, 'b' for bytecode, 'bt' for all (default)
</span><span class="comment">-- @param env  the environment for the new chunk (default nil)
</span><span class="comment">-- @return compiled chunk
</span><span class="comment">-- @return error message (chunk is nil)
</span><span class="comment">-- @function utils.load
</span>
<span class="comment">---------------
</span><span class="comment">-- Get environment of a function.
</span><span class="comment">-- With Lua 5.2, may return nil for a function with no global references!
</span><span class="comment">-- Based on code by [Sergey Rozhenko](http://lua-users.org/lists/lua-l/2010-06/msg00313.html)
</span><span class="comment">-- @param f a function or a call stack reference
</span><span class="comment">-- @function utils.setfenv
</span>
<span class="comment">---------------
</span><span class="comment">-- Set environment of a function
</span><span class="comment">-- @param f a function or a call stack reference
</span><span class="comment">-- @param env a table that becomes the new environment of <code>f</code>
</span><span class="comment">-- @function utils.setfenv
</span>
<span class="comment">--- execute a shell command.
</span><span class="comment">-- This is a compatibility function that returns the same for Lua 5.1 and Lua 5.2
</span><span class="comment">-- @param cmd a shell command
</span><span class="comment">-- @return true if successful
</span><span class="comment">-- @return actual return code
</span><span class="comment">-- @function utils.execute
</span>
<span class="keyword">return</span> utils</pre>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.3</a></i>
<i style="float:right;">Last updated 2014-11-01 18:36:39 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
