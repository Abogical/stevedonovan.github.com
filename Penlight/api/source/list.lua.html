<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Penlight Documentation</title>
    <link rel="stylesheet" href="../ldoc_fixed.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Penlight</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Source</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../source/app.lua.html">app.lua</a></li>
  <li><a href="../source/array2d.lua.html">array2d.lua</a></li>
  <li><a href="../source/class.lua.html">class.lua</a></li>
  <li><a href="../source/compat.lua.html">compat.lua</a></li>
  <li><a href="../source/comprehension.lua.html">comprehension.lua</a></li>
  <li><a href="../source/config.lua.html">config.lua</a></li>
  <li><a href="../source/data.lua.html">data.lua</a></li>
  <li><a href="../source/date.lua.html">date.lua</a></li>
  <li><a href="../source/dir.lua.html">dir.lua</a></li>
  <li><a href="../source/file.lua.html">file.lua</a></li>
  <li><a href="../source/func.lua.html">func.lua</a></li>
  <li><a href="../source/import_into.lua.html">import_into.lua</a></li>
  <li><a href="../source/init.lua.html">init.lua</a></li>
  <li><a href="../source/input.lua.html">input.lua</a></li>
  <li><a href="../source/lapp.lua.html">lapp.lua</a></li>
  <li><a href="../source/lexer.lua.html">lexer.lua</a></li>
  <li><strong>list.lua</strong></li>
  <li><a href="../source/luabalanced.lua.html">luabalanced.lua</a></li>
  <li><a href="../source/map.lua.html">map.lua</a></li>
  <li><a href="../source/multimap.lua.html">multimap.lua</a></li>
  <li><a href="../source/operator.lua.html">operator.lua</a></li>
  <li><a href="../source/orderedmap.lua.html">orderedmap.lua</a></li>
  <li><a href="../source/path.lua.html">path.lua</a></li>
  <li><a href="../source/permute.lua.html">permute.lua</a></li>
  <li><a href="../source/pretty.lua.html">pretty.lua</a></li>
  <li><a href="../source/seesubst.lua.html">seesubst.lua</a></li>
  <li><a href="../source/seq.lua.html">seq.lua</a></li>
  <li><a href="../source/set.lua.html">set.lua</a></li>
  <li><a href="../source/sip.lua.html">sip.lua</a></li>
  <li><a href="../source/sipscan.lua.html">sipscan.lua</a></li>
  <li><a href="../source/strict.lua.html">strict.lua</a></li>
  <li><a href="../source/stringio.lua.html">stringio.lua</a></li>
  <li><a href="../source/stringx.lua.html">stringx.lua</a></li>
  <li><a href="../source/symbols.lua.html">symbols.lua</a></li>
  <li><a href="../source/tablex.lua.html">tablex.lua</a></li>
  <li><a href="../source/template.lua.html">template.lua</a></li>
  <li><a href="../source/test-cmp.lua.html">test-cmp.lua</a></li>
  <li><a href="../source/test-data.lua.html">test-data.lua</a></li>
  <li><a href="../source/test-listcallbacks.lua.html">test-listcallbacks.lua</a></li>
  <li><a href="../source/test-pretty.lua.html">test-pretty.lua</a></li>
  <li><a href="../source/test-symbols.lua.html">test-symbols.lua</a></li>
  <li><a href="../source/test.lua.html">test.lua</a></li>
  <li><a href="../source/testapp.lua.html">testapp.lua</a></li>
  <li><a href="../source/testclone.lua.html">testclone.lua</a></li>
  <li><a href="../source/testconfig.lua.html">testconfig.lua</a></li>
  <li><a href="../source/testglobal.lua.html">testglobal.lua</a></li>
  <li><a href="../source/testinputfields.lua.html">testinputfields.lua</a></li>
  <li><a href="../source/testinputfields2.lua.html">testinputfields2.lua</a></li>
  <li><a href="../source/testxml.lua.html">testxml.lua</a></li>
  <li><a href="../source/text.lua.html">text.lua</a></li>
  <li><a href="../source/types.lua.html">types.lua</a></li>
  <li><a href="../source/url.lua.html">url.lua</a></li>
  <li><a href="../source/utils.lua.html">utils.lua</a></li>
  <li><a href="../source/which.lua.html">which.lua</a></li>
  <li><a href="../source/xml.lua.html">xml.lua</a></li>
</ul>
<h2>Libraries</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../libraries/pl.html">pl</a></li>
  <li><a href="../libraries/pl.app.html">pl.app</a></li>
  <li><a href="../libraries/pl.array2d.html">pl.array2d</a></li>
  <li><a href="../libraries/pl.class.html">pl.class</a></li>
  <li><a href="../libraries/pl.compat.html">pl.compat</a></li>
  <li><a href="../libraries/pl.comprehension.html">pl.comprehension</a></li>
  <li><a href="../libraries/pl.config.html">pl.config</a></li>
  <li><a href="../libraries/pl.data.html">pl.data</a></li>
  <li><a href="../libraries/pl.dir.html">pl.dir</a></li>
  <li><a href="../libraries/pl.file.html">pl.file</a></li>
  <li><a href="../libraries/pl.func.html">pl.func</a></li>
  <li><a href="../libraries/pl.import_into.html">pl.import_into</a></li>
  <li><a href="../libraries/pl.input.html">pl.input</a></li>
  <li><a href="../libraries/pl.lapp.html">pl.lapp</a></li>
  <li><a href="../libraries/pl.lexer.html">pl.lexer</a></li>
  <li><a href="../libraries/pl.luabalanced.html">pl.luabalanced</a></li>
  <li><a href="../libraries/pl.operator.html">pl.operator</a></li>
  <li><a href="../libraries/pl.path.html">pl.path</a></li>
  <li><a href="../libraries/pl.permute.html">pl.permute</a></li>
  <li><a href="../libraries/pl.pretty.html">pl.pretty</a></li>
  <li><a href="../libraries/pl.seq.html">pl.seq</a></li>
  <li><a href="../libraries/pl.sip.html">pl.sip</a></li>
  <li><a href="../libraries/pl.strict.html">pl.strict</a></li>
  <li><a href="../libraries/pl.stringio.html">pl.stringio</a></li>
  <li><a href="../libraries/pl.stringx.html">pl.stringx</a></li>
  <li><a href="../libraries/pl.tablex.html">pl.tablex</a></li>
  <li><a href="../libraries/pl.template.html">pl.template</a></li>
  <li><a href="../libraries/pl.test.html">pl.test</a></li>
  <li><a href="../libraries/pl.text.html">pl.text</a></li>
  <li><a href="../libraries/pl.types.html">pl.types</a></li>
  <li><a href="../libraries/pl.url.html">pl.url</a></li>
  <li><a href="../libraries/pl.utils.html">pl.utils</a></li>
  <li><a href="../libraries/pl.xml.html">pl.xml</a></li>
</ul>
<h2>Classes</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../classes/pl.Date.html">pl.Date</a></li>
  <li><a href="../classes/pl.List.html">pl.List</a></li>
  <li><a href="../classes/pl.Map.html">pl.Map</a></li>
  <li><a href="../classes/pl.MultiMap.html">pl.MultiMap</a></li>
  <li><a href="../classes/pl.OrderedMap.html">pl.OrderedMap</a></li>
  <li><a href="../classes/pl.Set.html">pl.Set</a></li>
</ul>
<h2>Manual</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../manual/01-introduction.md.html">Introduction</a></li>
  <li><a href="../manual/02-arrays.md.html">Tables and Arrays</a></li>
  <li><a href="../manual/03-strings.md.html">Strings. Higher-level operations on strings.</a></li>
  <li><a href="../manual/04-paths.md.html">Paths and Directories</a></li>
  <li><a href="../manual/05-dates.md.html">Date and Time</a></li>
  <li><a href="../manual/06-data.md.html">Data</a></li>
  <li><a href="../manual/07-functional.md.html">Functional Programming</a></li>
  <li><a href="../manual/08-additional.md.html">Additional Libraries</a></li>
  <li><a href="../manual/09-discussion.md.html">Technical Choices</a></li>
</ul>
<h2>Examples</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../examples/seesubst.lua.html">seesubst.lua</a></li>
  <li><a href="../examples/sipscan.lua.html">sipscan.lua</a></li>
  <li><a href="../examples/symbols.lua.html">symbols.lua</a></li>
  <li><a href="../examples/test-cmp.lua.html">test-cmp.lua</a></li>
  <li><a href="../examples/test-data.lua.html">test-data.lua</a></li>
  <li><a href="../examples/test-listcallbacks.lua.html">test-listcallbacks.lua</a></li>
  <li><a href="../examples/test-pretty.lua.html">test-pretty.lua</a></li>
  <li><a href="../examples/test-symbols.lua.html">test-symbols.lua</a></li>
  <li><a href="../examples/testapp.lua.html">testapp.lua</a></li>
  <li><a href="../examples/testclone.lua.html">testclone.lua</a></li>
  <li><a href="../examples/testconfig.lua.html">testconfig.lua</a></li>
  <li><a href="../examples/testglobal.lua.html">testglobal.lua</a></li>
  <li><a href="../examples/testinputfields.lua.html">testinputfields.lua</a></li>
  <li><a href="../examples/testinputfields2.lua.html">testinputfields2.lua</a></li>
  <li><a href="../examples/testxml.lua.html">testxml.lua</a></li>
  <li><a href="../examples/which.lua.html">which.lua</a></li>
</ul>

</div>

<div id="content">

    <h2>list.lua</h2>
<pre>
<span class="comment">--- Python-style list class.
</span><span class="comment">--
</span><span class="comment">-- **Please Note**: methods that change the list will return the list.
</span><span class="comment">-- This is to allow for method chaining, but please note that <code>ls = ls:sort()</code>
</span><span class="comment">-- does not mean that a new copy of the list is made. In-place (mutable) methods
</span><span class="comment">-- are marked as returning 'the list' in this documentation.
</span><span class="comment">--
</span><span class="comment">-- See the Guide for further <a href="../manual/02-arrays.md.html#Python_style_Lists">discussion</a>
</span><span class="comment">--
</span><span class="comment">-- See &lt;a href="http://www.python.org/doc/current/tut/tut.html"&gt;http://www.python.org/doc/current/tut/tut.html&lt;/a&gt;, section 5.1
</span><span class="comment">--
</span><span class="comment">-- **Note**: The comments before some of the functions are from the Python docs
</span><span class="comment">-- and contain Python code.
</span><span class="comment">--
</span><span class="comment">-- Written for Lua version Nick Trout 4.0; Redone for Lua 5.1, Steve Donovan.
</span><span class="comment">--
</span><span class="comment">-- Dependencies: <a href="../libraries/pl.utils.html#">pl.utils</a>, <a href="../libraries/pl.tablex.html#">pl.tablex</a>
</span><span class="comment">-- @classmod pl.List
</span><span class="comment">-- @pragma nostrip
</span>
<span class="keyword">local</span> tinsert,tremove,concat,tsort = <span class="global">table</span>.insert,<span class="global">table</span>.remove,<span class="global">table</span>.concat,<span class="global">table</span>.sort
<span class="keyword">local</span> <span class="global">setmetatable</span>, <span class="global">getmetatable</span>,<span class="global">type</span>,<span class="global">tostring</span>,<span class="global">assert</span>,<span class="global">string</span>,<span class="global">next</span> = <span class="global">setmetatable</span>,<span class="global">getmetatable</span>,<span class="global">type</span>,<span class="global">tostring</span>,<span class="global">assert</span>,<span class="global">string</span>,<span class="global">next</span>
<span class="keyword">local</span> tablex = <span class="global">require</span> <span class="string">'pl.tablex'</span>
<span class="keyword">local</span> filter,imap,imap2,reduce,transform,tremovevalues = tablex.filter,tablex.imap,tablex.imap2,tablex.reduce,tablex.transform,tablex.removevalues
<span class="keyword">local</span> tsub = tablex.sub
<span class="keyword">local</span> utils = <span class="global">require</span> <span class="string">'pl.utils'</span>
<span class="keyword">local</span> class = <span class="global">require</span> <span class="string">'pl.class'</span>

<span class="keyword">local</span> array_tostring,split,assert_arg,function_arg = utils.array_tostring,utils.split,utils.assert_arg,utils.function_arg
<span class="keyword">local</span> normalize_slice = tablex._normalize_slice

<span class="comment">-- metatable for our list and map objects has already been defined..
</span><span class="keyword">local</span> Multimap = utils.stdmt.MultiMap
<span class="keyword">local</span> List = utils.stdmt.List

<span class="keyword">local</span> iter

class(<span class="keyword">nil</span>,<span class="keyword">nil</span>,List)

<span class="comment">-- we want the result to be _covariant_, i.e. t must have type of obj if possible
</span><span class="keyword">local</span> <span class="keyword">function</span> makelist (t,obj)
    <span class="keyword">local</span> klass = List
    <span class="keyword">if</span> obj <span class="keyword">then</span>
        klass = <span class="global">getmetatable</span>(obj)
    <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="global">setmetatable</span>(t,klass)
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> simple_table(t)
    <span class="keyword">return</span> <span class="global">type</span>(t) == <span class="string">'table'</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="global">getmetatable</span>(t) <span class="keyword">and</span> #t &gt; <span class="number">0</span>
<span class="keyword">end</span>

<span class="keyword">function</span> List._create (src)
    <span class="keyword">if</span> simple_table(src) <span class="keyword">then</span> <span class="keyword">return</span> src <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> List:_init (src)
    <span class="keyword">if</span> self == src <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span> <span class="comment">-- existing table used as self!
</span>    <span class="keyword">if</span> src <span class="keyword">then</span>
        <span class="keyword">for</span> v <span class="keyword">in</span> iter(src) <span class="keyword">do</span>
            tinsert(self,v)
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- Create a new list. Can optionally pass a table;
</span><span class="comment">-- passing another instance of List will cause a copy to be created;
</span><span class="comment">-- this will return a plain table with an appropriate metatable.
</span><span class="comment">-- we pass anything which isn't a simple table to iterate() to work out
</span><span class="comment">-- an appropriate iterator
</span><span class="comment">--  @see List.iterate
</span><span class="comment">-- @param[opt] t An optional list-like table
</span><span class="comment">-- @return a new List
</span><span class="comment">-- @usage ls = List();  ls = List {1,2,3,4}
</span><span class="comment">-- @function List.new
</span><a id="77"></a>
List.new = List

<span class="comment">--- Make a copy of an existing list.
</span><span class="comment">-- The difference from a plain 'copy constructor' is that this returns
</span><a id="82"></a><span class="comment">-- the actual List subtype.
</span><span class="keyword">function</span> List:clone()
    <span class="keyword">local</span> ls = makelist({},self)
    ls:extend(self)
    <span class="keyword">return</span> ls
<span class="keyword">end</span>

<span class="comment">---Add an item to the end of the list.
</span><span class="comment">-- @param i An item
</span><a id="91"></a><span class="comment">-- @return the list
</span><span class="keyword">function</span> List:append(i)
    tinsert(self,i)
    <span class="keyword">return</span> self
<span class="keyword">end</span>

List.push = tinsert

<span class="comment">--- Extend the list by appending all the items in the given list.
</span><span class="comment">-- equivalent to 'a[len(a):] = L'.
</span><span class="comment">-- @tparam List L Another List
</span><a id="102"></a><span class="comment">-- @return the list
</span><span class="keyword">function</span> List:extend(L)
    assert_arg(<span class="number">1</span>,L,<span class="string">'table'</span>)
    <span class="keyword">for</span> i = <span class="number">1</span>,#L <span class="keyword">do</span> tinsert(self,L[i]) <span class="keyword">end</span>
    <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Insert an item at a given position. i is the index of the
</span><span class="comment">-- element before which to insert.
</span><span class="comment">-- @int i index of element before whichh to insert
</span><span class="comment">-- @param x A data item
</span><a id="113"></a><span class="comment">-- @return the list
</span><span class="keyword">function</span> List:insert(i, x)
    assert_arg(<span class="number">1</span>,i,<span class="string">'number'</span>)
    tinsert(self,i,x)
    <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Insert an item at the begining of the list.
</span><span class="comment">-- @param x a data item
</span><a id="122"></a><span class="comment">-- @return the list
</span><span class="keyword">function</span> List:put (x)
    <span class="keyword">return</span> self:insert(<span class="number">1</span>,x)
<span class="keyword">end</span>

<span class="comment">--- Remove an element given its index.
</span><span class="comment">-- (equivalent of Python's del s[i])
</span><span class="comment">-- @int i the index
</span><a id="130"></a><span class="comment">-- @return the list
</span><span class="keyword">function</span> List:remove (i)
    assert_arg(<span class="number">1</span>,i,<span class="string">'number'</span>)
    tremove(self,i)
    <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Remove the first item from the list whose value is given.
</span><span class="comment">-- (This is called 'remove' in Python; renamed to avoid confusion
</span><span class="comment">-- with table.remove)
</span><span class="comment">-- Return nil if there is no such item.
</span><span class="comment">-- @param x A data value
</span><a id="142"></a><span class="comment">-- @return the list
</span><span class="keyword">function</span> List:remove_value(x)
    <span class="keyword">for</span> i=<span class="number">1</span>,#self <span class="keyword">do</span>
        <span class="keyword">if</span> self[i]==x <span class="keyword">then</span> tremove(self,i) <span class="keyword">return</span> self <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> self
 <span class="keyword">end</span>

<span class="comment">--- Remove the item at the given position in the list, and return it.
</span><span class="comment">-- If no index is specified, a:pop() returns the last item in the list.
</span><span class="comment">-- The item is also removed from the list.
</span><span class="comment">-- @int[opt] i An index
</span><a id="154"></a><span class="comment">-- @return the item
</span><span class="keyword">function</span> List:pop(i)
    <span class="keyword">if</span> <span class="keyword">not</span> i <span class="keyword">then</span> i = #self <span class="keyword">end</span>
    assert_arg(<span class="number">1</span>,i,<span class="string">'number'</span>)
    <span class="keyword">return</span> tremove(self,i)
<span class="keyword">end</span>

List.get = List.pop

<span class="comment">--- Return the index in the list of the first item whose value is given.
</span><span class="comment">-- Return nil if there is no such item.
</span><span class="comment">-- @function List:index
</span><span class="comment">-- @param x A data value
</span><span class="comment">-- @int[opt=1] idx where to start search
</span><span class="comment">-- @return the index, or nil if not found.
</span><a id="169"></a>
<span class="keyword">local</span> tfind = tablex.find
List.index = tfind

<span class="comment">--- does this list contain the value?.
</span><span class="comment">-- @param x A data value
</span><a id="175"></a><span class="comment">-- @return true or false
</span><span class="keyword">function</span> List:contains(x)
    <span class="keyword">return</span> tfind(self,x) <span class="keyword">and</span> <span class="keyword">true</span> <span class="keyword">or</span> <span class="keyword">false</span>
<span class="keyword">end</span>

<span class="comment">--- Return the number of times value appears in the list.
</span><span class="comment">-- @param x A data value
</span><a id="182"></a><span class="comment">-- @return number of times x appears
</span><span class="keyword">function</span> List:count(x)
    <span class="keyword">local</span> cnt=<span class="number">0</span>
    <span class="keyword">for</span> i=<span class="number">1</span>,#self <span class="keyword">do</span>
        <span class="keyword">if</span> self[i]==x <span class="keyword">then</span> cnt=cnt+<span class="number">1</span> <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> cnt
<span class="keyword">end</span>

<span class="comment">--- Sort the items of the list, in place.
</span><span class="comment">-- @func[opt='&lt;'] cmp an optional comparison function
</span><a id="193"></a><span class="comment">-- @return the list
</span><span class="keyword">function</span> List:sort(cmp)
    <span class="keyword">if</span> cmp <span class="keyword">then</span> cmp = function_arg(<span class="number">1</span>,cmp) <span class="keyword">end</span>
    tsort(self,cmp)
    <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- return a sorted copy of this list.
</span><span class="comment">-- @func[opt='&lt;'] cmp an optional comparison function
</span><a id="202"></a><span class="comment">-- @return a new list
</span><span class="keyword">function</span> List:sorted(cmp)
    <span class="keyword">return</span> List(self):sort(cmp)
<span class="keyword">end</span>

<span class="comment">--- Reverse the elements of the list, in place.
</span><a id="208"></a><span class="comment">-- @return the list
</span><span class="keyword">function</span> List:reverse()
    <span class="keyword">local</span> t = self
    <span class="keyword">local</span> n = #t
    <span class="keyword">local</span> n2 = n/<span class="number">2</span>
    <span class="keyword">for</span> i = <span class="number">1</span>,n2 <span class="keyword">do</span>
        <span class="keyword">local</span> k = n-i+<span class="number">1</span>
        t[i],t[k] = t[k],t[i]
    <span class="keyword">end</span>
    <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- return the minimum and the maximum value of the list.
</span><span class="comment">-- @return minimum value
</span><a id="222"></a><span class="comment">-- @return maximum value
</span><span class="keyword">function</span> List:minmax()
    <span class="keyword">local</span> vmin,vmax = <span class="number">1e70</span>,-<span class="number">1e70</span>
    <span class="keyword">for</span> i = <span class="number">1</span>,#self <span class="keyword">do</span>
        <span class="keyword">local</span> v = self[i]
        <span class="keyword">if</span> v &lt; vmin <span class="keyword">then</span> vmin = v <span class="keyword">end</span>
        <span class="keyword">if</span> v &gt; vmax <span class="keyword">then</span> vmax = v <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> vmin,vmax
<span class="keyword">end</span>

<span class="comment">--- Emulate list slicing.  like  'list[first:last]' in Python.
</span><span class="comment">-- If first or last are negative then they are relative to the end of the list
</span><span class="comment">-- eg. slice(-2) gives last 2 entries in a list, and
</span><span class="comment">-- slice(-4,-2) gives from -4th to -2nd
</span><span class="comment">-- @param first An index
</span><span class="comment">-- @param last An index
</span><a id="239"></a><span class="comment">-- @return a new List
</span><span class="keyword">function</span> List:slice(first,last)
    <span class="keyword">return</span> tsub(self,first,last)
<span class="keyword">end</span>

<span class="comment">--- empty the list.
</span><a id="245"></a><span class="comment">-- @return the list
</span><span class="keyword">function</span> List:clear()
    <span class="keyword">for</span> i=<span class="number">1</span>,#self <span class="keyword">do</span> tremove(self) <span class="keyword">end</span>
    <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="keyword">local</span> eps = <span class="number">1.0e-10</span>

<span class="comment">--- Emulate Python's range(x) function.
</span><span class="comment">-- Include it in List table for tidiness
</span><span class="comment">-- @int start A number
</span><span class="comment">-- @int[opt] finish A number greater than start; if absent,
</span><span class="comment">-- then start is 1 and finish is start
</span><span class="comment">-- @int[opt=1] incr an increment (may be less than 1)
</span><span class="comment">-- @return a List from start .. finish
</span><span class="comment">-- @usage List.range(0,3) == List{0,1,2,3}
</span><span class="comment">-- @usage List.range(4) = List{1,2,3,4}
</span><a id="262"></a><span class="comment">-- @usage List.range(5,1,-1) == List{5,4,3,2,1}
</span><span class="keyword">function</span> List.range(start,finish,incr)
    <span class="keyword">if</span> <span class="keyword">not</span> finish <span class="keyword">then</span>
        finish = start
        start = <span class="number">1</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> incr <span class="keyword">then</span>
    assert_arg(<span class="number">3</span>,incr,<span class="string">'number'</span>)
    <span class="keyword">if</span> <span class="global">math</span>.ceil(incr) ~= incr <span class="keyword">then</span> finish = finish + eps <span class="keyword">end</span>
    <span class="keyword">else</span>
        incr = <span class="number">1</span>
    <span class="keyword">end</span>
    assert_arg(<span class="number">1</span>,start,<span class="string">'number'</span>)
    assert_arg(<span class="number">2</span>,finish,<span class="string">'number'</span>)
    <span class="keyword">local</span> t = List()
    <span class="keyword">for</span> i=start,finish,incr <span class="keyword">do</span> tinsert(t,i) <span class="keyword">end</span>
    <span class="keyword">return</span> t
<span class="keyword">end</span>

<a id="281"></a><span class="comment">--- list:len() is the same as #list.
</span><span class="keyword">function</span> List:len()
    <span class="keyword">return</span> #self
<span class="keyword">end</span>

<span class="comment">-- Extended operations --
</span>
<span class="comment">--- Remove a subrange of elements.
</span><span class="comment">-- equivalent to 'del s[i1:i2]' in Python.
</span><span class="comment">-- @int i1 start of range
</span><span class="comment">-- @int i2 end of range
</span><a id="292"></a><span class="comment">-- @return the list
</span><span class="keyword">function</span> List:chop(i1,i2)
    <span class="keyword">return</span> tremovevalues(self,i1,i2)
<span class="keyword">end</span>

<span class="comment">--- Insert a sublist into a list
</span><span class="comment">-- equivalent to 's[idx:idx] = list' in Python
</span><span class="comment">-- @int idx index
</span><span class="comment">-- @tparam List list list to insert
</span><span class="comment">-- @return the list
</span><a id="302"></a><span class="comment">-- @usage  l = List{10,20}; l:splice(2,{21,22});  assert(l == List{10,21,22,20})
</span><span class="keyword">function</span> List:splice(idx,list)
    assert_arg(<span class="number">1</span>,idx,<span class="string">'number'</span>)
    idx = idx - <span class="number">1</span>
    <span class="keyword">local</span> i = <span class="number">1</span>
    <span class="keyword">for</span> v <span class="keyword">in</span> iter(list) <span class="keyword">do</span>
        tinsert(self,i+idx,v)
        i = i + <span class="number">1</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- general slice assignment s[i1:i2] = seq.
</span><span class="comment">-- @int i1  start index
</span><span class="comment">-- @int i2  end index
</span><span class="comment">-- @tparam List seq a list
</span><a id="318"></a><span class="comment">-- @return the list
</span><span class="keyword">function</span> List:slice_assign(i1,i2,seq)
    assert_arg(<span class="number">1</span>,i1,<span class="string">'number'</span>)
    assert_arg(<span class="number">1</span>,i2,<span class="string">'number'</span>)
    i1,i2 = normalize_slice(self,i1,i2)
    <span class="keyword">if</span> i2 &gt;= i1 <span class="keyword">then</span> self:chop(i1,i2) <span class="keyword">end</span>
    self:splice(i1,seq)
    <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- concatenation operator.
</span><span class="comment">-- @within metamethods
</span><span class="comment">-- @tparam List L another List
</span><a id="331"></a><span class="comment">-- @return a new list consisting of the list with the elements of the new list appended
</span><span class="keyword">function</span> List:__concat(L)
    assert_arg(<span class="number">1</span>,L,<span class="string">'table'</span>)
    <span class="keyword">local</span> ls = self:clone()
    ls:extend(L)
    <span class="keyword">return</span> ls
<span class="keyword">end</span>

<span class="comment">--- equality operator ==.  True iff all elements of two lists are equal.
</span><span class="comment">-- @within metamethods
</span><span class="comment">-- @tparam List L another List
</span><a id="342"></a><span class="comment">-- @return true or false
</span><span class="keyword">function</span> List:__eq(L)
    <span class="keyword">if</span> #self ~= #L <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">end</span>
    <span class="keyword">for</span> i = <span class="number">1</span>,#self <span class="keyword">do</span>
        <span class="keyword">if</span> self[i] ~= L[i] <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="keyword">true</span>
<span class="keyword">end</span>

<span class="comment">--- join the elements of a list using a delimiter.
</span><span class="comment">-- This method uses tostring on all elements.
</span><span class="comment">-- @string[opt=''] delim a delimiter string, can be empty.
</span><a id="354"></a><span class="comment">-- @return a string
</span><span class="keyword">function</span> List:join (delim)
    delim = delim <span class="keyword">or</span> <span class="string">''</span>
    assert_arg(<span class="number">1</span>,delim,<span class="string">'string'</span>)
    <span class="keyword">return</span> concat(array_tostring(self),delim)
<span class="keyword">end</span>

<span class="comment">--- join a list of strings. &lt;br&gt;
</span><span class="comment">-- Uses <a href="http://www.lua.org/manual/5.1/manual.html#pdf-table.concat">table.concat</a> directly.
</span><span class="comment">-- @function List:concat
</span><span class="comment">-- @string[opt=''] delim a delimiter
</span><a id="365"></a><span class="comment">-- @return a string
</span>List.concat = concat

<span class="keyword">local</span> <span class="keyword">function</span> tostring_q(val)
    <span class="keyword">local</span> s = <span class="global">tostring</span>(val)
    <span class="keyword">if</span> <span class="global">type</span>(val) == <span class="string">'string'</span> <span class="keyword">then</span>
        s = <span class="string">'"'</span>..s..<span class="string">'"'</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> s
<span class="keyword">end</span>

<span class="comment">--- how our list should be rendered as a string. Uses join().
</span><span class="comment">-- @within metamethods
</span><a id="378"></a><span class="comment">-- @see List:join
</span><span class="keyword">function</span> List:__tostring()
    <span class="keyword">return</span> <span class="string">'{'</span>..self:join(<span class="string">','</span>,tostring_q)..<span class="string">'}'</span>
<span class="keyword">end</span>

<span class="comment">--- call the function on each element of the list.
</span><span class="comment">-- @func fun a function or callable object
</span><a id="385"></a><span class="comment">-- @param ... optional values to pass to function
</span><span class="keyword">function</span> List:foreach (fun,...)
    fun = function_arg(<span class="number">1</span>,fun)
    <span class="keyword">for</span> i = <span class="number">1</span>,#self <span class="keyword">do</span>
        fun(self[i],...)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> lookup_fun (obj,name)
    <span class="keyword">local</span> f = obj[name]
    <span class="keyword">if</span> <span class="keyword">not</span> f <span class="keyword">then</span> error(<span class="global">type</span>(obj)..<span class="string">" does not have method "</span>..name,<span class="number">3</span>) <span class="keyword">end</span>
    <span class="keyword">return</span> f
<span class="keyword">end</span>

<span class="comment">--- call the named method on each element of the list.
</span><span class="comment">-- @string name the method name
</span><a id="401"></a><span class="comment">-- @param ... optional values to pass to function
</span><span class="keyword">function</span> List:foreachm (name,...)
    <span class="keyword">for</span> i = <span class="number">1</span>,#self <span class="keyword">do</span>
        <span class="keyword">local</span> obj = self[i]
        <span class="keyword">local</span> f = lookup_fun(obj,name)
        f(obj,...)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- create a list of all elements which match a function.
</span><span class="comment">-- @func fun a boolean function
</span><span class="comment">-- @param[opt] arg optional argument to be passed as second argument of the predicate
</span><a id="413"></a><span class="comment">-- @return a new filtered list.
</span><span class="keyword">function</span> List:filter (fun,arg)
    <span class="keyword">return</span> makelist(filter(self,fun,arg),self)
<span class="keyword">end</span>

<span class="comment">--- split a string using a delimiter.
</span><span class="comment">-- @string s the string
</span><span class="comment">-- @string[opt] delim the delimiter (default spaces)
</span><span class="comment">-- @return a List of strings
</span><a id="422"></a><span class="comment">-- @see pl.utils.split
</span><span class="keyword">function</span> List.split (s,delim)
    assert_arg(<span class="number">1</span>,s,<span class="string">'string'</span>)
    <span class="keyword">return</span> makelist(split(s,delim))
<span class="keyword">end</span>

<span class="comment">--- apply a function to all elements.
</span><span class="comment">-- Any extra arguments will be passed to the function.
</span><span class="comment">-- @func fun a function of at least one argument
</span><span class="comment">-- @param ... arbitrary extra arguments.
</span><span class="comment">-- @return a new list: {f(x) for x in self}
</span><span class="comment">-- @usage List{'one','two'}:map(string.upper) == {'ONE','TWO'}
</span><a id="434"></a><span class="comment">-- @see pl.tablex.imap
</span><span class="keyword">function</span> List:map (fun,...)
    <span class="keyword">return</span> makelist(imap(fun,self,...),self)
<span class="keyword">end</span>

<span class="comment">--- apply a function to all elements, in-place.
</span><span class="comment">-- Any extra arguments are passed to the function.
</span><span class="comment">-- @func fun A function that takes at least one argument
</span><span class="comment">-- @param ... arbitrary extra arguments.
</span><a id="443"></a><span class="comment">-- @return the list.
</span><span class="keyword">function</span> List:transform (fun,...)
    transform(fun,self,...)
	<span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- apply a function to elements of two lists.
</span><span class="comment">-- Any extra arguments will be passed to the function
</span><span class="comment">-- @func fun a function of at least two arguments
</span><span class="comment">-- @tparam List ls another list
</span><span class="comment">-- @param ... arbitrary extra arguments.
</span><span class="comment">-- @return a new list: {f(x,y) for x in self, for x in arg1}
</span><a id="455"></a><span class="comment">-- @see pl.tablex.imap2
</span><span class="keyword">function</span> List:map2 (fun,ls,...)
    <span class="keyword">return</span> makelist(imap2(fun,self,ls,...),self)
<span class="keyword">end</span>

<span class="comment">--- apply a named method to all elements.
</span><span class="comment">-- Any extra arguments will be passed to the method.
</span><span class="comment">-- @string name name of method
</span><span class="comment">-- @param ... extra arguments
</span><span class="comment">-- @return a new list of the results
</span><a id="465"></a><span class="comment">-- @see pl.seq.mapmethod
</span><span class="keyword">function</span> List:mapm (name,...)
    <span class="keyword">local</span> res = {}
    <span class="keyword">for</span> i = <span class="number">1</span>,#self <span class="keyword">do</span>
      <span class="keyword">local</span> val = self[i]
      <span class="keyword">local</span> fn = lookup_fun(val,name)
      res[i] = fn(val,...)
    <span class="keyword">end</span>
    <span class="keyword">return</span> makelist(res,self)
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> composite_call (method,f)
    <span class="keyword">return</span> <span class="keyword">function</span>(self,...)
        <span class="keyword">return</span> self[method](self,f,...)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> List.default_map_with(T)
    <span class="keyword">return</span> <span class="keyword">function</span>(self,name)
        <span class="keyword">local</span> m
        <span class="keyword">if</span> T <span class="keyword">then</span>
            <span class="keyword">local</span> f = lookup_fun(T,name)
            m = composite_call(<span class="string">'map'</span>,f)
        <span class="keyword">else</span>
            m = composite_call(<span class="string">'mapn'</span>,name)
        <span class="keyword">end</span>
        <span class="global">getmetatable</span>(self)[name] = m <span class="comment">-- and cache..
</span>        <span class="keyword">return</span> m
    <span class="keyword">end</span>
<span class="keyword">end</span>

List.default_map = List.default_map_with

<span class="comment">--- 'reduce' a list using a binary function.
</span><span class="comment">-- @func fun a function of two arguments
</span><span class="comment">-- @return result of the function
</span><a id="501"></a><span class="comment">-- @see pl.tablex.reduce
</span><span class="keyword">function</span> List:reduce (fun)
    <span class="keyword">return</span> reduce(fun,self)
<span class="keyword">end</span>

<span class="comment">--- partition a list using a classifier function.
</span><span class="comment">-- The function may return nil, but this will be converted to the string key '&lt;nil&gt;'.
</span><span class="comment">-- @func fun a function of at least one argument
</span><span class="comment">-- @param ... will also be passed to the function
</span><span class="comment">-- @treturn MultiMap a table where the keys are the returned values, and the values are Lists
</span><span class="comment">-- of values where the function returned that key.
</span><a id="512"></a><span class="comment">-- @see pl.MultiMap
</span><span class="keyword">function</span> List:partition (fun,...)
    fun = function_arg(<span class="number">1</span>,fun)
    <span class="keyword">local</span> res = {}
    <span class="keyword">for</span> i = <span class="number">1</span>,#self <span class="keyword">do</span>
        <span class="keyword">local</span> val = self[i]
        <span class="keyword">local</span> klass = fun(val,...)
        <span class="keyword">if</span> klass == <span class="keyword">nil</span> <span class="keyword">then</span> klass = <span class="string">'&lt;nil&gt;'</span> <span class="keyword">end</span>
        <span class="keyword">if</span> <span class="keyword">not</span> res[klass] <span class="keyword">then</span> res[klass] = List() <span class="keyword">end</span>
        res[klass]:append(val)
    <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="global">setmetatable</span>(res,Multimap)
<span class="keyword">end</span>

<a id="526"></a><span class="comment">--- return an iterator over all values.
</span><span class="keyword">function</span> List:iter ()
    <span class="keyword">return</span> iter(self)
<span class="keyword">end</span>

<span class="comment">--- Create an iterator over a seqence.
</span><span class="comment">-- This captures the Python concept of 'sequence'.
</span><span class="comment">-- For tables, iterates over all values with integer indices.
</span><span class="comment">-- @param seq a sequence; a string (over characters), a table, a file object (over lines) or an iterator function
</span><span class="comment">-- @usage for x in iterate {1,10,22,55} do io.write(x,',') end ==&gt; 1,10,22,55
</span><a id="536"></a><span class="comment">-- @usage for ch in iterate 'help' do do io.write(ch,' ') end ==&gt; h e l p
</span><span class="keyword">function</span> List.iterate(seq)
    <span class="keyword">if</span> <span class="global">type</span>(seq) == <span class="string">'string'</span> <span class="keyword">then</span>
        <span class="keyword">local</span> idx = <span class="number">0</span>
        <span class="keyword">local</span> n = #seq
        <span class="keyword">local</span> sub = <span class="global">string</span>.sub
        <span class="keyword">return</span> <span class="keyword">function</span> ()
            idx = idx + <span class="number">1</span>
            <span class="keyword">if</span> idx &gt; n <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span>
            <span class="keyword">else</span>
                <span class="keyword">return</span> sub(seq,idx,idx)
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">elseif</span> <span class="global">type</span>(seq) == <span class="string">'table'</span> <span class="keyword">then</span>
        <span class="keyword">local</span> idx = <span class="number">0</span>
        <span class="keyword">local</span> n = #seq
        <span class="keyword">return</span> <span class="keyword">function</span>()
            idx = idx + <span class="number">1</span>
            <span class="keyword">if</span> idx &gt; n <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span>
            <span class="keyword">else</span>
                <span class="keyword">return</span> seq[idx]
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">elseif</span> <span class="global">type</span>(seq) == <span class="string">'function'</span> <span class="keyword">then</span>
        <span class="keyword">return</span> seq
    <span class="keyword">elseif</span> <span class="global">type</span>(seq) == <span class="string">'userdata'</span> <span class="keyword">and</span> <span class="global">io</span>.<span class="global">type</span>(seq) == <span class="string">'file'</span> <span class="keyword">then</span>
        <span class="keyword">return</span> seq:lines()
    <span class="keyword">end</span>
<span class="keyword">end</span>
iter = List.iterate

<span class="keyword">return</span> List</pre>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.3</a></i>
<i style="float:right;">Last updated 2014-11-01 18:36:39 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
