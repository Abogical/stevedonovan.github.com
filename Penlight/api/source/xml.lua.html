<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Penlight Documentation</title>
    <link rel="stylesheet" href="../ldoc_fixed.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Penlight</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Source</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../source/app.lua.html">app.lua</a></li>
  <li><a href="../source/array2d.lua.html">array2d.lua</a></li>
  <li><a href="../source/class.lua.html">class.lua</a></li>
  <li><a href="../source/compat.lua.html">compat.lua</a></li>
  <li><a href="../source/comprehension.lua.html">comprehension.lua</a></li>
  <li><a href="../source/config.lua.html">config.lua</a></li>
  <li><a href="../source/data.lua.html">data.lua</a></li>
  <li><a href="../source/date.lua.html">date.lua</a></li>
  <li><a href="../source/dir.lua.html">dir.lua</a></li>
  <li><a href="../source/file.lua.html">file.lua</a></li>
  <li><a href="../source/func.lua.html">func.lua</a></li>
  <li><a href="../source/import_into.lua.html">import_into.lua</a></li>
  <li><a href="../source/init.lua.html">init.lua</a></li>
  <li><a href="../source/input.lua.html">input.lua</a></li>
  <li><a href="../source/lapp.lua.html">lapp.lua</a></li>
  <li><a href="../source/lexer.lua.html">lexer.lua</a></li>
  <li><a href="../source/list.lua.html">list.lua</a></li>
  <li><a href="../source/luabalanced.lua.html">luabalanced.lua</a></li>
  <li><a href="../source/map.lua.html">map.lua</a></li>
  <li><a href="../source/multimap.lua.html">multimap.lua</a></li>
  <li><a href="../source/operator.lua.html">operator.lua</a></li>
  <li><a href="../source/orderedmap.lua.html">orderedmap.lua</a></li>
  <li><a href="../source/path.lua.html">path.lua</a></li>
  <li><a href="../source/permute.lua.html">permute.lua</a></li>
  <li><a href="../source/pretty.lua.html">pretty.lua</a></li>
  <li><a href="../source/seesubst.lua.html">seesubst.lua</a></li>
  <li><a href="../source/seq.lua.html">seq.lua</a></li>
  <li><a href="../source/set.lua.html">set.lua</a></li>
  <li><a href="../source/sip.lua.html">sip.lua</a></li>
  <li><a href="../source/sipscan.lua.html">sipscan.lua</a></li>
  <li><a href="../source/strict.lua.html">strict.lua</a></li>
  <li><a href="../source/stringio.lua.html">stringio.lua</a></li>
  <li><a href="../source/stringx.lua.html">stringx.lua</a></li>
  <li><a href="../source/symbols.lua.html">symbols.lua</a></li>
  <li><a href="../source/tablex.lua.html">tablex.lua</a></li>
  <li><a href="../source/template.lua.html">template.lua</a></li>
  <li><a href="../source/test-cmp.lua.html">test-cmp.lua</a></li>
  <li><a href="../source/test-data.lua.html">test-data.lua</a></li>
  <li><a href="../source/test-listcallbacks.lua.html">test-listcallbacks.lua</a></li>
  <li><a href="../source/test-pretty.lua.html">test-pretty.lua</a></li>
  <li><a href="../source/test-symbols.lua.html">test-symbols.lua</a></li>
  <li><a href="../source/test.lua.html">test.lua</a></li>
  <li><a href="../source/testapp.lua.html">testapp.lua</a></li>
  <li><a href="../source/testclone.lua.html">testclone.lua</a></li>
  <li><a href="../source/testconfig.lua.html">testconfig.lua</a></li>
  <li><a href="../source/testglobal.lua.html">testglobal.lua</a></li>
  <li><a href="../source/testinputfields.lua.html">testinputfields.lua</a></li>
  <li><a href="../source/testinputfields2.lua.html">testinputfields2.lua</a></li>
  <li><a href="../source/testxml.lua.html">testxml.lua</a></li>
  <li><a href="../source/text.lua.html">text.lua</a></li>
  <li><a href="../source/types.lua.html">types.lua</a></li>
  <li><a href="../source/url.lua.html">url.lua</a></li>
  <li><a href="../source/utils.lua.html">utils.lua</a></li>
  <li><a href="../source/which.lua.html">which.lua</a></li>
  <li><strong>xml.lua</strong></li>
</ul>
<h2>Libraries</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../libraries/pl.html">pl</a></li>
  <li><a href="../libraries/pl.app.html">pl.app</a></li>
  <li><a href="../libraries/pl.array2d.html">pl.array2d</a></li>
  <li><a href="../libraries/pl.class.html">pl.class</a></li>
  <li><a href="../libraries/pl.compat.html">pl.compat</a></li>
  <li><a href="../libraries/pl.comprehension.html">pl.comprehension</a></li>
  <li><a href="../libraries/pl.config.html">pl.config</a></li>
  <li><a href="../libraries/pl.data.html">pl.data</a></li>
  <li><a href="../libraries/pl.dir.html">pl.dir</a></li>
  <li><a href="../libraries/pl.file.html">pl.file</a></li>
  <li><a href="../libraries/pl.func.html">pl.func</a></li>
  <li><a href="../libraries/pl.import_into.html">pl.import_into</a></li>
  <li><a href="../libraries/pl.input.html">pl.input</a></li>
  <li><a href="../libraries/pl.lapp.html">pl.lapp</a></li>
  <li><a href="../libraries/pl.lexer.html">pl.lexer</a></li>
  <li><a href="../libraries/pl.luabalanced.html">pl.luabalanced</a></li>
  <li><a href="../libraries/pl.operator.html">pl.operator</a></li>
  <li><a href="../libraries/pl.path.html">pl.path</a></li>
  <li><a href="../libraries/pl.permute.html">pl.permute</a></li>
  <li><a href="../libraries/pl.pretty.html">pl.pretty</a></li>
  <li><a href="../libraries/pl.seq.html">pl.seq</a></li>
  <li><a href="../libraries/pl.sip.html">pl.sip</a></li>
  <li><a href="../libraries/pl.strict.html">pl.strict</a></li>
  <li><a href="../libraries/pl.stringio.html">pl.stringio</a></li>
  <li><a href="../libraries/pl.stringx.html">pl.stringx</a></li>
  <li><a href="../libraries/pl.tablex.html">pl.tablex</a></li>
  <li><a href="../libraries/pl.template.html">pl.template</a></li>
  <li><a href="../libraries/pl.test.html">pl.test</a></li>
  <li><a href="../libraries/pl.text.html">pl.text</a></li>
  <li><a href="../libraries/pl.types.html">pl.types</a></li>
  <li><a href="../libraries/pl.url.html">pl.url</a></li>
  <li><a href="../libraries/pl.utils.html">pl.utils</a></li>
  <li><a href="../libraries/pl.xml.html">pl.xml</a></li>
</ul>
<h2>Classes</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../classes/pl.Date.html">pl.Date</a></li>
  <li><a href="../classes/pl.List.html">pl.List</a></li>
  <li><a href="../classes/pl.Map.html">pl.Map</a></li>
  <li><a href="../classes/pl.MultiMap.html">pl.MultiMap</a></li>
  <li><a href="../classes/pl.OrderedMap.html">pl.OrderedMap</a></li>
  <li><a href="../classes/pl.Set.html">pl.Set</a></li>
</ul>
<h2>Manual</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../manual/01-introduction.md.html">Introduction</a></li>
  <li><a href="../manual/02-arrays.md.html">Tables and Arrays</a></li>
  <li><a href="../manual/03-strings.md.html">Strings. Higher-level operations on strings.</a></li>
  <li><a href="../manual/04-paths.md.html">Paths and Directories</a></li>
  <li><a href="../manual/05-dates.md.html">Date and Time</a></li>
  <li><a href="../manual/06-data.md.html">Data</a></li>
  <li><a href="../manual/07-functional.md.html">Functional Programming</a></li>
  <li><a href="../manual/08-additional.md.html">Additional Libraries</a></li>
  <li><a href="../manual/09-discussion.md.html">Technical Choices</a></li>
</ul>
<h2>Examples</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../examples/seesubst.lua.html">seesubst.lua</a></li>
  <li><a href="../examples/sipscan.lua.html">sipscan.lua</a></li>
  <li><a href="../examples/symbols.lua.html">symbols.lua</a></li>
  <li><a href="../examples/test-cmp.lua.html">test-cmp.lua</a></li>
  <li><a href="../examples/test-data.lua.html">test-data.lua</a></li>
  <li><a href="../examples/test-listcallbacks.lua.html">test-listcallbacks.lua</a></li>
  <li><a href="../examples/test-pretty.lua.html">test-pretty.lua</a></li>
  <li><a href="../examples/test-symbols.lua.html">test-symbols.lua</a></li>
  <li><a href="../examples/testapp.lua.html">testapp.lua</a></li>
  <li><a href="../examples/testclone.lua.html">testclone.lua</a></li>
  <li><a href="../examples/testconfig.lua.html">testconfig.lua</a></li>
  <li><a href="../examples/testglobal.lua.html">testglobal.lua</a></li>
  <li><a href="../examples/testinputfields.lua.html">testinputfields.lua</a></li>
  <li><a href="../examples/testinputfields2.lua.html">testinputfields2.lua</a></li>
  <li><a href="../examples/testxml.lua.html">testxml.lua</a></li>
  <li><a href="../examples/which.lua.html">which.lua</a></li>
</ul>

</div>

<div id="content">

    <h2>xml.lua</h2>
<pre>
<span class="comment">--- XML LOM Utilities.
</span><span class="comment">--
</span><span class="comment">-- This implements some useful things on [LOM](http://matthewwild.co.uk/projects/luaexpat/lom.html) documents, such as returned by <code>lxp.lom.parse</code>.
</span><span class="comment">-- In particular, it can convert LOM back into XML text, with optional pretty-printing control.
</span><span class="comment">-- It is s based on stanza.lua from [Prosody](http://hg.prosody.im/trunk/file/4621c92d2368/util/stanza.lua)
</span><span class="comment">--
</span><span class="comment">--     &gt; d = xml.parse "&lt;nodes&gt;&lt;node id='1'&gt;alice&lt;/node&gt;&lt;/nodes&gt;"
</span><span class="comment">--     &gt; = d
</span><span class="comment">--     &lt;nodes&gt;&lt;node id='1'&gt;alice&lt;/node&gt;&lt;/nodes&gt;
</span><span class="comment">--     &gt; = xml.tostring(d,'','  ')
</span><span class="comment">--     &lt;nodes&gt;
</span><span class="comment">--        &lt;node id='1'&gt;alice&lt;/node&gt;
</span><span class="comment">--     &lt;/nodes&gt;
</span><span class="comment">--
</span><span class="comment">-- Can be used as a lightweight one-stop-shop for simple XML processing; a simple XML parser is included
</span><span class="comment">-- but the default is to use <code>lxp.lom</code> if it can be found.
</span><span class="comment">-- &lt;pre&gt;
</span><span class="comment">-- Prosody IM
</span><span class="comment">-- Copyright (C) 2008-2010 Matthew Wild
</span><span class="comment">-- Copyright (C) 2008-2010 Waqas Hussain--
</span><span class="comment">-- classic Lua XML parser by Roberto Ierusalimschy.
</span><span class="comment">-- modified to output LOM format.
</span><span class="comment">-- http://lua-users.org/wiki/LuaXml
</span><span class="comment">-- &lt;/pre&gt;
</span><span class="comment">-- See <a href="../manual/06-data.md.html#XML">the Guide</a>
</span><span class="comment">--
</span><span class="comment">-- Dependencies: <a href="../libraries/pl.utils.html#">pl.utils</a>
</span><span class="comment">--
</span><span class="comment">-- Soft Dependencies: <code>lxp.lom</code> (fallback is to use basic Lua parser)
</span><span class="comment">-- @module pl.xml
</span>
<span class="keyword">local</span> utils = <span class="global">require</span> <span class="string">'pl.utils'</span>
<span class="keyword">local</span> split         =   utils.split;
<span class="keyword">local</span> t_insert      =  <span class="global">table</span>.insert;
<span class="keyword">local</span> t_concat      =  <span class="global">table</span>.concat;
<span class="keyword">local</span> t_remove      =  <span class="global">table</span>.remove;
<span class="keyword">local</span> s_format      = <span class="global">string</span>.format;
<span class="keyword">local</span> s_match       =  <span class="global">string</span>.match;
<span class="keyword">local</span> <span class="global">tostring</span>      =      <span class="global">tostring</span>;
<span class="keyword">local</span> <span class="global">setmetatable</span>  =  <span class="global">setmetatable</span>;
<span class="keyword">local</span> <span class="global">getmetatable</span>  =  <span class="global">getmetatable</span>;
<span class="keyword">local</span> <span class="global">pairs</span>         =         <span class="global">pairs</span>;
<span class="keyword">local</span> <span class="global">ipairs</span>        =        <span class="global">ipairs</span>;
<span class="keyword">local</span> <span class="global">type</span>          =          <span class="global">type</span>;
<span class="keyword">local</span> <span class="global">next</span>          =          <span class="global">next</span>;
<span class="keyword">local</span> <span class="global">print</span>         =         <span class="global">print</span>;
<span class="keyword">local</span> <span class="global">unpack</span>        =  utils.<span class="global">unpack</span>;
<span class="keyword">local</span> s_gsub        =   <span class="global">string</span>.gsub;
<span class="keyword">local</span> s_char        =   <span class="global">string</span>.char;
<span class="keyword">local</span> s_find        =   <span class="global">string</span>.find;
<span class="keyword">local</span> <span class="global">os</span>            =            <span class="global">os</span>;
<span class="keyword">local</span> <span class="global">pcall</span>,<span class="global">require</span>,<span class="global">io</span>     =   <span class="global">pcall</span>,<span class="global">require</span>,<span class="global">io</span>

<span class="keyword">local</span> _M = {}
<span class="keyword">local</span> Doc = { __type = <span class="string">"doc"</span> };
Doc.__index = Doc;

<span class="comment">--- create a new document node.
</span><span class="comment">-- @param tag the tag name
</span><a id="61"></a><span class="comment">-- @param attr optional attributes (table of name-value pairs)
</span><span class="keyword">function</span> _M.new(tag, attr)
    <span class="keyword">local</span> doc = { tag = tag, attr = attr <span class="keyword">or</span> {}, last_add = {}};
    <span class="keyword">return</span> <span class="global">setmetatable</span>(doc, Doc);
<span class="keyword">end</span>

<span class="comment">--- parse an XML document.  By default, this uses lxp.lom.parse, but
</span><span class="comment">-- falls back to basic_parse, or if use_basic is true
</span><span class="comment">-- @param text_or_file  file or string representation
</span><span class="comment">-- @param is_file whether text_or_file is a file name or not
</span><span class="comment">-- @param use_basic do a basic parse
</span><span class="comment">-- @return a parsed LOM document with the document metatatables set
</span><a id="73"></a><span class="comment">-- @return nil, error the error can either be a file error or a parse error
</span><span class="keyword">function</span> _M.parse(text_or_file, is_file, use_basic)
    <span class="keyword">local</span> parser,status,lom
    <span class="keyword">if</span> use_basic <span class="keyword">then</span> parser = _M.basic_parse
    <span class="keyword">else</span>
        status,lom = <span class="global">pcall</span>(<span class="global">require</span>,<span class="string">'lxp.lom'</span>)
        <span class="keyword">if</span> <span class="keyword">not</span> status <span class="keyword">then</span> parser = _M.basic_parse <span class="keyword">else</span> parser = lom.parse <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> is_file <span class="keyword">then</span>
        <span class="keyword">local</span> f,err = <span class="global">io</span>.open(text_or_file)
        <span class="keyword">if</span> <span class="keyword">not</span> f <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span>,err <span class="keyword">end</span>
        text_or_file = f:read <span class="string">'*a'</span>
        f:close()
    <span class="keyword">end</span>
    <span class="keyword">local</span> doc,err = parser(text_or_file)
    <span class="keyword">if</span> <span class="keyword">not</span> doc <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span>,err <span class="keyword">end</span>
    <span class="keyword">if</span> lom <span class="keyword">then</span>
        _M.walk(doc,<span class="keyword">false</span>,<span class="keyword">function</span>(_,d)
            <span class="global">setmetatable</span>(d,Doc)
        <span class="keyword">end</span>)
    <span class="keyword">end</span>
    <span class="keyword">return</span> doc
<span class="keyword">end</span>

<span class="comment">---- convenient function to add a document node, This updates the last inserted position.
</span><span class="comment">-- @param tag a tag name
</span><a id="99"></a><span class="comment">-- @param attrs optional set of attributes (name-string pairs)
</span><span class="keyword">function</span> Doc:addtag(tag, attrs)
    <span class="keyword">local</span> s = _M.new(tag, attrs);
    (self.last_add[#self.last_add] <span class="keyword">or</span> self):add_direct_child(s);
    t_insert(self.last_add, s);
    <span class="keyword">return</span> self;
<span class="keyword">end</span>

<span class="comment">--- convenient function to add a text node.  This updates the last inserted position.
</span><a id="108"></a><span class="comment">-- @param text a string
</span><span class="keyword">function</span> Doc:text(text)
    (self.last_add[#self.last_add] <span class="keyword">or</span> self):add_direct_child(text);
    <span class="keyword">return</span> self;
<span class="keyword">end</span>

<a id="114"></a><span class="comment">---- go up one level in a document
</span><span class="keyword">function</span> Doc:up()
    t_remove(self.last_add);
    <span class="keyword">return</span> self;
<span class="keyword">end</span>

<span class="keyword">function</span> Doc:reset()
    <span class="keyword">local</span> last_add = self.last_add;
    <span class="keyword">for</span> i = <span class="number">1</span>,#last_add <span class="keyword">do</span>
        last_add[i] = <span class="keyword">nil</span>;
    <span class="keyword">end</span>
    <span class="keyword">return</span> self;
<span class="keyword">end</span>

<span class="comment">--- append a child to a document directly.
</span><a id="129"></a><span class="comment">-- @param child a child node (either text or a document)
</span><span class="keyword">function</span> Doc:add_direct_child(child)
    t_insert(self, child);
<span class="keyword">end</span>

<span class="comment">--- append a child to a document at the last element added
</span><a id="135"></a><span class="comment">-- @param child a child node (either text or a document)
</span><span class="keyword">function</span> Doc:add_child(child)
    (self.last_add[#self.last_add] <span class="keyword">or</span> self):add_direct_child(child);
    <span class="keyword">return</span> self;
<span class="keyword">end</span>

<span class="comment">--accessing attributes: useful not to have to expose implementation (attr)
</span><span class="comment">--but also can allow attr to be nil in any future optimizations
</span>
<span class="comment">--- set attributes of a document node.
</span><a id="145"></a><span class="comment">-- @param t a table containing attribute/value pairs
</span><span class="keyword">function</span> Doc:set_attribs (t)
    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(t) <span class="keyword">do</span>
        self.attr[k] = v
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- set a single attribute of a document node.
</span><span class="comment">-- @param a attribute
</span><a id="154"></a><span class="comment">-- @param v its value
</span><span class="keyword">function</span> Doc:set_attrib(a,v)
    self.attr[a] = v
<span class="keyword">end</span>

<a id="159"></a><span class="comment">--- access the attributes of a document node.
</span><span class="keyword">function</span> Doc:get_attribs()
    <span class="keyword">return</span> self.attr
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> is_text(s) <span class="keyword">return</span> <span class="global">type</span>(s) == <span class="string">'string'</span> <span class="keyword">end</span>

<span class="comment">--- function to create an element with a given tag name and a set of children.
</span><span class="comment">-- @param tag a tag name
</span><a id="168"></a><span class="comment">-- @param items either text or a table where the hash part is the attributes and the list part is the children.
</span><span class="keyword">function</span> _M.elem(tag,items)
    <span class="keyword">local</span> s = _M.new(tag)
    <span class="keyword">if</span> is_text(items) <span class="keyword">then</span> items = {items} <span class="keyword">end</span>
    <span class="keyword">if</span> _M.is_tag(items) <span class="keyword">then</span>
       t_insert(s,items)
    <span class="keyword">elseif</span> <span class="global">type</span>(items) == <span class="string">'table'</span> <span class="keyword">then</span>
       <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(items) <span class="keyword">do</span>
           <span class="keyword">if</span> is_text(k) <span class="keyword">then</span>
               s.attr[k] = v
               t_insert(s.attr,k)
           <span class="keyword">else</span>
               s[k] = v
           <span class="keyword">end</span>
       <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> s
<span class="keyword">end</span>

<span class="comment">--- given a list of names, return a number of element constructors.
</span><span class="comment">-- @param list  a list of names, or a comma-separated string.
</span><span class="comment">-- @usage local parent,children = doc.tags 'parent,children' &lt;br&gt;
</span><a id="190"></a><span class="comment">--  doc = parent {child 'one', child 'two'}
</span><span class="keyword">function</span> _M.tags(list)
    <span class="keyword">local</span> ctors = {}
    <span class="keyword">local</span> elem = _M.elem
    <span class="keyword">if</span> is_text(list) <span class="keyword">then</span> list = split(list,<span class="string">'%s*,%s*'</span>) <span class="keyword">end</span>
    <span class="keyword">for</span> _,tag <span class="keyword">in</span> <span class="global">ipairs</span>(list) <span class="keyword">do</span>
        <span class="keyword">local</span> ctor = <span class="keyword">function</span>(items) <span class="keyword">return</span> _M.elem(tag,items) <span class="keyword">end</span>
        t_insert(ctors,ctor)
    <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="global">unpack</span>(ctors)
<span class="keyword">end</span>

<span class="keyword">local</span> templ_cache = {}

<span class="keyword">local</span> <span class="keyword">function</span> template_cache (templ)
    <span class="keyword">if</span> is_text(templ) <span class="keyword">then</span>
        <span class="keyword">if</span> templ_cache[templ] <span class="keyword">then</span>
            templ = templ_cache[templ]
        <span class="keyword">else</span>
            <span class="keyword">local</span> str,err = templ
            templ,err = _M.parse(str,<span class="keyword">false</span>,<span class="keyword">true</span>)
            <span class="keyword">if</span> <span class="keyword">not</span> templ <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span>,err <span class="keyword">end</span>
            templ_cache[str] = templ
        <span class="keyword">end</span>
    <span class="keyword">elseif</span> <span class="keyword">not</span> _M.is_tag(templ) <span class="keyword">then</span>
        <span class="keyword">return</span> <span class="keyword">nil</span>, <span class="string">"template is not a document"</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> templ
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> is_data(data)
    <span class="keyword">return</span> #data == <span class="number">0</span> <span class="keyword">or</span> <span class="global">type</span>(data[<span class="number">1</span>]) ~= <span class="string">'table'</span>
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> prepare_data(data)
    <span class="comment">-- a hack for ensuring that $1 maps to first element of data, etc.
</span>    <span class="comment">-- Either this or could change the gsub call just below.
</span>    <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="global">ipairs</span>(data) <span class="keyword">do</span>
        data[<span class="global">tostring</span>(i)] = v
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- create a substituted copy of a document,
</span><span class="comment">-- @param templ  may be a document or a string representation which will be parsed and cached
</span><span class="comment">-- @param data  a table of name-value pairs or a list of such tables
</span><a id="235"></a><span class="comment">-- @return an XML document
</span><span class="keyword">function</span> Doc.subst(templ, data)
    <span class="keyword">local</span> err
    <span class="keyword">if</span> <span class="global">type</span>(data) ~= <span class="string">'table'</span> <span class="keyword">or</span> <span class="keyword">not</span> <span class="global">next</span>(data) <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span>, <span class="string">"data must be a non-empty table"</span> <span class="keyword">end</span>
    <span class="keyword">if</span> is_data(data) <span class="keyword">then</span>
        prepare_data(data)
    <span class="keyword">end</span>
    templ,err = template_cache(templ)
    <span class="keyword">if</span> err <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span>, err <span class="keyword">end</span>
    <span class="keyword">local</span> <span class="keyword">function</span> _subst(item)
        <span class="keyword">return</span> _M.clone(templ,<span class="keyword">function</span>(s)
            <span class="keyword">return</span> s:gsub(<span class="string">'%$(%w+)'</span>,item)
        <span class="keyword">end</span>)
    <span class="keyword">end</span>
    <span class="keyword">if</span> is_data(data) <span class="keyword">then</span> <span class="keyword">return</span> _subst(data) <span class="keyword">end</span>
    <span class="keyword">local</span> list = {}
    <span class="keyword">for</span> _,item <span class="keyword">in</span> <span class="global">ipairs</span>(data) <span class="keyword">do</span>
        prepare_data(item)
        t_insert(list,_subst(item))
    <span class="keyword">end</span>
    <span class="keyword">if</span> data.tag <span class="keyword">then</span>
        list = _M.elem(data.tag,list)
    <span class="keyword">end</span>
    <span class="keyword">return</span> list
<span class="keyword">end</span>


<span class="comment">--- get the first child with a given tag name.
</span><a id="263"></a><span class="comment">-- @param tag the tag name
</span><span class="keyword">function</span> Doc:child_with_name(tag)
    <span class="keyword">for</span> _, child <span class="keyword">in</span> <span class="global">ipairs</span>(self) <span class="keyword">do</span>
        <span class="keyword">if</span> child.tag == tag <span class="keyword">then</span> <span class="keyword">return</span> child; <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">local</span> _children_with_name
<span class="keyword">function</span> _children_with_name(self,tag,list,recurse)
    <span class="keyword">for</span> _, child <span class="keyword">in</span> <span class="global">ipairs</span>(self) <span class="keyword">do</span> <span class="keyword">if</span> <span class="global">type</span>(child) == <span class="string">'table'</span> <span class="keyword">then</span>
        <span class="keyword">if</span> child.tag == tag <span class="keyword">then</span> t_insert(list,child) <span class="keyword">end</span>
        <span class="keyword">if</span> recurse <span class="keyword">then</span> _children_with_name(child,tag,list,recurse) <span class="keyword">end</span>
    <span class="keyword">end</span> <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- get all elements in a document that have a given tag.
</span><span class="comment">-- @param tag a tag name
</span><span class="comment">-- @param dont_recurse optionally only return the immediate children with this tag name
</span><a id="281"></a><span class="comment">-- @return a list of elements
</span><span class="keyword">function</span> Doc:get_elements_with_name(tag,dont_recurse)
    <span class="keyword">local</span> res = {}
    _children_with_name(self,tag,res,<span class="keyword">not</span> dont_recurse)
    <span class="keyword">return</span> res
<span class="keyword">end</span>

<span class="comment">-- iterate over all children of a document node, including text nodes.
</span><span class="keyword">function</span> Doc:children()
    <span class="keyword">local</span> i = <span class="number">0</span>;
    <span class="keyword">return</span> <span class="keyword">function</span> (a)
            i = i + <span class="number">1</span>
            <span class="keyword">return</span> a[i];
    <span class="keyword">end</span>, self, i;
<span class="keyword">end</span>

<span class="comment">-- return the first child element of a node, if it exists.
</span><span class="keyword">function</span> Doc:first_childtag()
    <span class="keyword">if</span> #self == <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span>
    <span class="keyword">for</span> _,t <span class="keyword">in</span> <span class="global">ipairs</span>(self) <span class="keyword">do</span>
        <span class="keyword">if</span> <span class="global">type</span>(t) == <span class="string">'table'</span> <span class="keyword">then</span> <span class="keyword">return</span> t <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> Doc:matching_tags(tag, xmlns)
    xmlns = xmlns <span class="keyword">or</span> self.attr.xmlns;
    <span class="keyword">local</span> tags = self;
    <span class="keyword">local</span> start_i, max_i, v = <span class="number">1</span>, #tags;
    <span class="keyword">return</span> <span class="keyword">function</span> ()
            <span class="keyword">for</span> i=start_i,max_i <span class="keyword">do</span>
                v = tags[i];
                <span class="keyword">if</span> (<span class="keyword">not</span> tag <span class="keyword">or</span> v.tag == tag)
                <span class="keyword">and</span> (<span class="keyword">not</span> xmlns <span class="keyword">or</span> xmlns == v.attr.xmlns) <span class="keyword">then</span>
                    start_i = i+<span class="number">1</span>;
                    <span class="keyword">return</span> v;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>, tags, start_i;
<span class="keyword">end</span>

<a id="321"></a><span class="comment">--- iterate over all child elements of a document node.
</span><span class="keyword">function</span> Doc:childtags()
    <span class="keyword">local</span> i = <span class="number">0</span>;
    <span class="keyword">return</span> <span class="keyword">function</span> (a)
        <span class="keyword">local</span> v
            <span class="keyword">repeat</span>
                i = i + <span class="number">1</span>
                v = self[i]
                <span class="keyword">if</span> v <span class="keyword">and</span> <span class="global">type</span>(v) == <span class="string">'table'</span> <span class="keyword">then</span> <span class="keyword">return</span> v; <span class="keyword">end</span>
            <span class="keyword">until</span> <span class="keyword">not</span> v
        <span class="keyword">end</span>, self[<span class="number">1</span>], i;
<span class="keyword">end</span>

<span class="comment">--- visit child element  of a node and call a function, possibility modifying the document.
</span><span class="comment">-- @param callback  a function passed the node (text or element). If it returns nil, that node will be removed.
</span><a id="336"></a><span class="comment">-- If it returns a value, that will replace the current node.
</span><span class="keyword">function</span> Doc:maptags(callback)
    <span class="keyword">local</span> is_tag = _M.is_tag
    <span class="keyword">local</span> i = <span class="number">1</span>;
    <span class="keyword">while</span> i &lt;= #self <span class="keyword">do</span>
        <span class="keyword">if</span> is_tag(self[i]) <span class="keyword">then</span>
            <span class="keyword">local</span> ret = callback(self[i]);
            <span class="keyword">if</span> ret == <span class="keyword">nil</span> <span class="keyword">then</span>
                t_remove(self, i);
            <span class="keyword">else</span>
                self[i] = ret;
                i = i + <span class="number">1</span>;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> self;
<span class="keyword">end</span>

<span class="keyword">local</span> xml_escape
<span class="keyword">do</span>
    <span class="keyword">local</span> escape_table = { [<span class="string">"'"</span>] = <span class="string">"&amp;apos;"</span>, [<span class="string">"\""</span>] = <span class="string">"&amp;quot;"</span>, [<span class="string">"&lt;"</span>] = <span class="string">"&amp;lt;"</span>, [<span class="string">"&gt;"</span>] = <span class="string">"&amp;gt;"</span>, [<span class="string">"&amp;"</span>] = <span class="string">"&amp;amp;"</span> };
    <span class="keyword">function</span> xml_escape(str) <span class="keyword">return</span> (s_gsub(str, <span class="string">"['&amp;&lt;&gt;\"]"</span>, escape_table)); <span class="keyword">end</span>
    _M.xml_escape = xml_escape;
<span class="keyword">end</span>

<span class="comment">-- pretty printing
</span><span class="comment">-- if indent, then put each new tag on its own line
</span><span class="comment">-- if attr_indent, put each new attribute on its own line
</span><span class="keyword">local</span> <span class="keyword">function</span> _dostring(t, buf, self, xml_escape, parentns, idn, indent, attr_indent)
    <span class="keyword">local</span> nsid = <span class="number">0</span>;
    <span class="keyword">local</span> tag = t.tag
    <span class="keyword">local</span> lf,alf = <span class="string">""</span>,<span class="string">" "</span>
    <span class="keyword">if</span> indent <span class="keyword">then</span> lf = <span class="string">'\n'</span>..idn <span class="keyword">end</span>
    <span class="keyword">if</span> attr_indent <span class="keyword">then</span> alf = <span class="string">'\n'</span>..idn..attr_indent <span class="keyword">end</span>
    t_insert(buf, lf..<span class="string">"&lt;"</span>..tag);
    <span class="keyword">local</span> <span class="keyword">function</span> write_attr(k,v)
        <span class="keyword">if</span> s_find(k, <span class="string">"\1"</span>, <span class="number">1</span>, <span class="keyword">true</span>) <span class="keyword">then</span>
            <span class="keyword">local</span> ns, attrk = s_match(k, <span class="string">"^([^\1]*)\1?(.*)$"</span>);
            nsid = nsid + <span class="number">1</span>;
            t_insert(buf, <span class="string">" xmlns:ns"</span>..nsid..<span class="string">"='"</span>..xml_escape(ns)..<span class="string">"' "</span>..<span class="string">"ns"</span>..nsid..<span class="string">":"</span>..attrk..<span class="string">"='"</span>..xml_escape(v)..<span class="string">"'"</span>);
        <span class="keyword">elseif</span> <span class="keyword">not</span>(k == <span class="string">"xmlns"</span> <span class="keyword">and</span> v == parentns) <span class="keyword">then</span>
            t_insert(buf, alf..k..<span class="string">"='"</span>..xml_escape(v)..<span class="string">"'"</span>);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="comment">-- it's useful for testing to have predictable attribute ordering, if available
</span>    <span class="keyword">if</span> #t.attr &gt; <span class="number">0</span> <span class="keyword">then</span>
        <span class="keyword">for</span> _,k <span class="keyword">in</span> <span class="global">ipairs</span>(t.attr) <span class="keyword">do</span>
            write_attr(k,t.attr[k])
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="global">pairs</span>(t.attr) <span class="keyword">do</span>
            write_attr(k,v)
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">local</span> len,has_children = #t;
    <span class="keyword">if</span> len == <span class="number">0</span> <span class="keyword">then</span>
    <span class="keyword">local</span> out = <span class="string">"/&gt;"</span>
    <span class="keyword">if</span> attr_indent <span class="keyword">then</span> out = <span class="string">'\n'</span>..idn..out <span class="keyword">end</span>
        t_insert(buf, out);
    <span class="keyword">else</span>
        t_insert(buf, <span class="string">"&gt;"</span>);
        <span class="keyword">for</span> n=<span class="number">1</span>,len <span class="keyword">do</span>
            <span class="keyword">local</span> child = t[n];
            <span class="keyword">if</span> child.tag <span class="keyword">then</span>
                self(child, buf, self, xml_escape, t.attr.xmlns,idn <span class="keyword">and</span> idn..indent, indent, attr_indent );
                has_children = <span class="keyword">true</span>
            <span class="keyword">else</span> <span class="comment">-- text element
</span>                t_insert(buf, xml_escape(child));
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        t_insert(buf, (has_children <span class="keyword">and</span> lf <span class="keyword">or</span> <span class="string">''</span>)..<span class="string">"&lt;/"</span>..tag..<span class="string">"&gt;"</span>);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">---- pretty-print an XML document
</span><span class="comment">--- @param t an XML document
</span><span class="comment">--- @param idn an initial indent (indents are all strings)
</span><span class="comment">--- @param indent an indent for each level
</span><span class="comment">--- @param attr_indent if given, indent each attribute pair and put on a separate line
</span><span class="comment">--- @param xml force prefacing with &lt;?xml...&gt;
</span><a id="416"></a><span class="comment">--- @return a string representation
</span><span class="keyword">function</span> _M.<span class="global">tostring</span>(t,idn,indent, attr_indent, xml)
    <span class="keyword">local</span> buf = {};
    <span class="keyword">if</span> xml <span class="keyword">then</span> buf[<span class="number">1</span>] = <span class="string">"&lt;?xml version='1.0'?&gt;"</span> <span class="keyword">end</span>
    _dostring(t, buf, _dostring, xml_escape, <span class="keyword">nil</span>,idn,indent, attr_indent);
    <span class="keyword">return</span> t_concat(buf);
<span class="keyword">end</span>

Doc.__tostring = _M.<span class="global">tostring</span>

<a id="426"></a><span class="comment">--- get the full text value of an element
</span><span class="keyword">function</span> Doc:get_text()
    <span class="keyword">local</span> res = {}
    <span class="keyword">for</span> i,el <span class="keyword">in</span> <span class="global">ipairs</span>(self) <span class="keyword">do</span>
        <span class="keyword">if</span> is_text(el) <span class="keyword">then</span> t_insert(res,el) <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> t_concat(res);
<span class="keyword">end</span>

<span class="comment">--- make a copy of a document
</span><span class="comment">-- @param doc the original document
</span><a id="437"></a><span class="comment">-- @param strsubst an optional function for handling string copying which could do substitution, etc.
</span><span class="keyword">function</span> _M.clone(doc, strsubst)
    <span class="keyword">local</span> lookup_table = {};
    <span class="keyword">local</span> <span class="keyword">function</span> _copy(object,kind,parent)
        <span class="keyword">if</span> <span class="global">type</span>(object) ~= <span class="string">"table"</span> <span class="keyword">then</span>
            <span class="keyword">if</span> strsubst <span class="keyword">and</span> is_text(object) <span class="keyword">then</span> <span class="keyword">return</span> strsubst(object,kind,parent)
            <span class="keyword">else</span> <span class="keyword">return</span> object
            <span class="keyword">end</span>
        <span class="keyword">elseif</span> lookup_table[object] <span class="keyword">then</span>
            <span class="keyword">return</span> lookup_table[object]
        <span class="keyword">end</span>
        <span class="keyword">local</span> new_table = {};
        lookup_table[object] = new_table
        <span class="keyword">local</span> tag = object.tag
        new_table.tag = _copy(tag,<span class="string">'*TAG'</span>,parent)
        <span class="keyword">if</span> object.attr <span class="keyword">then</span>
            <span class="keyword">local</span> res = {}
            <span class="keyword">for</span> attr,value <span class="keyword">in</span> <span class="global">pairs</span>(object.attr) <span class="keyword">do</span>
                res[attr] = _copy(value,attr,object)
            <span class="keyword">end</span>
            new_table.attr = res
        <span class="keyword">end</span>
        <span class="keyword">for</span> index = <span class="number">1</span>,#object <span class="keyword">do</span>
            <span class="keyword">local</span> v = _copy(object[index],<span class="string">'*TEXT'</span>,object)
            t_insert(new_table,v)
        <span class="keyword">end</span>
        <span class="keyword">return</span> <span class="global">setmetatable</span>(new_table, <span class="global">getmetatable</span>(object))
    <span class="keyword">end</span>

    <span class="keyword">return</span> _copy(doc)
<span class="keyword">end</span>

Doc.filter = _M.clone <span class="comment">-- also available as method
</span>
<span class="comment">--- compare two documents.
</span><span class="comment">-- @param t1 any value
</span><a id="473"></a><span class="comment">-- @param t2 any value
</span><span class="keyword">function</span> _M.compare(t1,t2)
    <span class="keyword">local</span> ty1 = <span class="global">type</span>(t1)
    <span class="keyword">local</span> ty2 = <span class="global">type</span>(t2)
    <span class="keyword">if</span> ty1 ~= ty2 <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span>, <span class="string">'type mismatch'</span> <span class="keyword">end</span>
    <span class="keyword">if</span> ty1 == <span class="string">'string'</span> <span class="keyword">then</span>
        <span class="keyword">return</span> t1 == t2 <span class="keyword">and</span> <span class="keyword">true</span> <span class="keyword">or</span> <span class="string">'text '</span>..t1..<span class="string">' ~= text '</span>..t2
    <span class="keyword">end</span>
    <span class="keyword">if</span> ty1 ~= <span class="string">'table'</span> <span class="keyword">or</span> ty2 ~= <span class="string">'table'</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span>, <span class="string">'not a document'</span> <span class="keyword">end</span>
    <span class="keyword">if</span> t1.tag ~= t2.tag <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span>, <span class="string">'tag  '</span>..t1.tag..<span class="string">' ~= tag '</span>..t2.tag <span class="keyword">end</span>
    <span class="keyword">if</span> #t1 ~= #t2 <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span>, <span class="string">'size '</span>..#t1..<span class="string">' ~= size '</span>..#t2..<span class="string">' for tag '</span>..t1.tag <span class="keyword">end</span>
    <span class="comment">-- compare attributes
</span>    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(t1.attr) <span class="keyword">do</span>
        <span class="keyword">if</span> t2.attr[k] ~= v <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span>, <span class="string">'mismatch attrib'</span> <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(t2.attr) <span class="keyword">do</span>
        <span class="keyword">if</span> t1.attr[k] ~= v <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span>, <span class="string">'mismatch attrib'</span> <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="comment">-- compare children
</span>    <span class="keyword">for</span> i = <span class="number">1</span>,#t1 <span class="keyword">do</span>
        <span class="keyword">local</span> yes,err = _M.compare(t1[i],t2[i])
        <span class="keyword">if</span> <span class="keyword">not</span> yes <span class="keyword">then</span> <span class="keyword">return</span> err <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="keyword">true</span>
<span class="keyword">end</span>

<span class="comment">--- is this value a document element?
</span><a id="500"></a><span class="comment">-- @param d any value
</span><span class="keyword">function</span> _M.is_tag(d)
    <span class="keyword">return</span> <span class="global">type</span>(d) == <span class="string">'table'</span> <span class="keyword">and</span> is_text(d.tag)
<span class="keyword">end</span>

<span class="comment">--- call the desired function recursively over the document.
</span><span class="comment">-- @param doc the document
</span><span class="comment">-- @param depth_first  visit child notes first, then the current node
</span><a id="508"></a><span class="comment">-- @param operation a function which will receive the current tag name and current node.
</span><span class="keyword">function</span> _M.walk (doc, depth_first, operation)
    <span class="keyword">if</span> <span class="keyword">not</span> depth_first <span class="keyword">then</span> operation(doc.tag,doc) <span class="keyword">end</span>
    <span class="keyword">for</span> _,d <span class="keyword">in</span> <span class="global">ipairs</span>(doc) <span class="keyword">do</span>
        <span class="keyword">if</span> _M.is_tag(d) <span class="keyword">then</span>
            _M.walk(d,depth_first,operation)
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> depth_first <span class="keyword">then</span> operation(doc.tag,doc) <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">local</span> html_empty_elements = { <span class="comment">--lists all HTML empty (void) elements
</span>	br      = <span class="keyword">true</span>,
	img     = <span class="keyword">true</span>,
	meta    = <span class="keyword">true</span>,
	frame   = <span class="keyword">true</span>,
	area    = <span class="keyword">true</span>,
	hr      = <span class="keyword">true</span>,
	base    = <span class="keyword">true</span>,
	col     = <span class="keyword">true</span>,
	link    = <span class="keyword">true</span>,
	input   = <span class="keyword">true</span>,
	option  = <span class="keyword">true</span>,
	param   = <span class="keyword">true</span>,
    isindex = <span class="keyword">true</span>,
    embed = <span class="keyword">true</span>,
}

<span class="keyword">local</span> escapes = { quot = <span class="string">"\""</span>, apos = <span class="string">"'"</span>, lt = <span class="string">"&lt;"</span>, gt = <span class="string">"&gt;"</span>, amp = <span class="string">"&amp;"</span> }
<span class="keyword">local</span> <span class="keyword">function</span> unescape(str) <span class="keyword">return</span> (str:gsub( <span class="string">"&amp;(%a+);"</span>, escapes)); <span class="keyword">end</span>

<span class="comment">--- Parse a well-formed HTML file as a string.
</span><span class="comment">-- Tags are case-insenstive, DOCTYPE is ignored, and empty elements can be .. empty.
</span><a id="541"></a><span class="comment">-- @param s the HTML
</span><span class="keyword">function</span> _M.parsehtml (s)
    <span class="keyword">return</span> _M.basic_parse(s,<span class="keyword">false</span>,<span class="keyword">true</span>)
<span class="keyword">end</span>

<span class="comment">--- Parse a simple XML document using a pure Lua parser based on Robero Ierusalimschy's original version.
</span><span class="comment">-- @param s the XML document to be parsed.
</span><span class="comment">-- @param all_text  if true, preserves all whitespace. Otherwise only text containing non-whitespace is included.
</span><a id="549"></a><span class="comment">-- @param html if true, uses relaxed HTML rules for parsing
</span><span class="keyword">function</span> _M.basic_parse(s,all_text,html)
    <span class="keyword">local</span> t_insert,t_remove = <span class="global">table</span>.insert,<span class="global">table</span>.remove
    <span class="keyword">local</span> s_find,s_sub = <span class="global">string</span>.find,<span class="global">string</span>.sub
    <span class="keyword">local</span> stack = {}
    <span class="keyword">local</span> top = {}

    <span class="keyword">local</span> <span class="keyword">function</span> parseargs(s)
      <span class="keyword">local</span> arg = {}
      s:gsub(<span class="string">"([%w:]+)%s*=%s*([\"'])(.-)%2"</span>, <span class="keyword">function</span> (w, _, a)
        <span class="keyword">if</span> html <span class="keyword">then</span> w = w:lower() <span class="keyword">end</span>
        arg[w] = unescape(a)
      <span class="keyword">end</span>)
      <span class="keyword">if</span> html <span class="keyword">then</span>
        s:gsub(<span class="string">"([%w:]+)%s*=%s*([^\"']+)%s*"</span>, <span class="keyword">function</span> (w, a)
          w = w:lower()
          arg[w] = unescape(a)
        <span class="keyword">end</span>)
      <span class="keyword">end</span>
      <span class="keyword">return</span> arg
    <span class="keyword">end</span>

    t_insert(stack, top)
    <span class="keyword">local</span> ni,c,label,xarg, empty, _, istart
    <span class="keyword">local</span> i, j = <span class="number">1</span>, <span class="number">1</span>
    <span class="keyword">if</span> <span class="keyword">not</span> html <span class="keyword">then</span> <span class="comment">-- we're not interested in &lt;?xml version="1.0"?&gt;
</span>        _,istart = s_find(s,<span class="string">'^%s*&lt;%?[^%?]+%?&gt;%s*'</span>)
    <span class="keyword">else</span> <span class="comment">-- or &lt;!DOCTYPE ...&gt;
</span>        _,istart = s_find(s,<span class="string">'^%s*&lt;!DOCTYPE.-&gt;%s*'</span>)
    <span class="keyword">end</span>
    <span class="keyword">if</span> istart <span class="keyword">then</span> i = istart+<span class="number">1</span> <span class="keyword">end</span>
    <span class="keyword">while</span> <span class="keyword">true</span> <span class="keyword">do</span>
        ni,j,c,label,xarg, empty = s_find(s, <span class="string">"&lt;([%/!]?)([%w:%-_]+)(.-)(%/?)&gt;"</span>, i)
        <span class="keyword">if</span> <span class="keyword">not</span> ni <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span>
        <span class="keyword">if</span> c == <span class="string">"!"</span> <span class="keyword">then</span> <span class="comment">-- comment
</span>            <span class="comment">-- case where there's no space inside comment
</span>            <span class="keyword">if</span> <span class="keyword">not</span> (label:match <span class="string">'%-%-$'</span> <span class="keyword">and</span> xarg == <span class="string">''</span>) <span class="keyword">then</span>
                <span class="keyword">if</span> xarg:match <span class="string">'%-%-$'</span> <span class="keyword">then</span> <span class="comment">-- we've grabbed it all
</span>                    j = j - <span class="number">2</span>
                <span class="keyword">end</span>
                <span class="comment">-- match end of comment
</span>                _,j = s_find(s, <span class="string">"--&gt;"</span>, j, <span class="keyword">true</span>)
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            <span class="keyword">local</span> text = s_sub(s, i, ni-<span class="number">1</span>)
            <span class="keyword">if</span> html <span class="keyword">then</span>
                label = label:lower()
                <span class="keyword">if</span> html_empty_elements[label] <span class="keyword">then</span> empty = <span class="string">"/"</span> <span class="keyword">end</span>
                <span class="keyword">if</span> label == <span class="string">'script'</span> <span class="keyword">then</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="keyword">if</span> all_text <span class="keyword">or</span> <span class="keyword">not</span> s_find(text, <span class="string">"^%s*$"</span>) <span class="keyword">then</span>
                t_insert(top, unescape(text))
            <span class="keyword">end</span>
            <span class="keyword">if</span> empty == <span class="string">"/"</span> <span class="keyword">then</span>  <span class="comment">-- empty element tag
</span>                t_insert(top, <span class="global">setmetatable</span>({tag=label, attr=parseargs(xarg), empty=<span class="number">1</span>},Doc))
            <span class="keyword">elseif</span> c == <span class="string">""</span> <span class="keyword">then</span>   <span class="comment">-- start tag
</span>                top = <span class="global">setmetatable</span>({tag=label, attr=parseargs(xarg)},Doc)
                t_insert(stack, top)   <span class="comment">-- new level
</span>            <span class="keyword">else</span>  <span class="comment">-- end tag
</span>                <span class="keyword">local</span> toclose = t_remove(stack)  <span class="comment">-- remove top
</span>                top = stack[#stack]
                <span class="keyword">if</span> #stack &lt; <span class="number">1</span> <span class="keyword">then</span>
                    error(<span class="string">"nothing to close with "</span>..label..<span class="string">':'</span>..text)
                <span class="keyword">end</span>
                <span class="keyword">if</span> toclose.tag ~= label <span class="keyword">then</span>
                    error(<span class="string">"trying to close "</span>..toclose.tag..<span class="string">" with "</span>..label..<span class="string">" "</span>..text)
                <span class="keyword">end</span>
                t_insert(top, toclose)
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    i = j+<span class="number">1</span>
    <span class="keyword">end</span>
    <span class="keyword">local</span> text = s_sub(s, i)
    <span class="keyword">if</span> all_text <span class="keyword">or</span>  <span class="keyword">not</span> s_find(text, <span class="string">"^%s*$"</span>) <span class="keyword">then</span>
        t_insert(stack[#stack], unescape(text))
    <span class="keyword">end</span>
    <span class="keyword">if</span> #stack &gt; <span class="number">1</span> <span class="keyword">then</span>
        error(<span class="string">"unclosed "</span>..stack[#stack].tag)
    <span class="keyword">end</span>
    <span class="keyword">local</span> res = stack[<span class="number">1</span>]
    <span class="keyword">return</span> is_text(res[<span class="number">1</span>]) <span class="keyword">and</span> res[<span class="number">2</span>] <span class="keyword">or</span> res[<span class="number">1</span>]
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> empty(attr) <span class="keyword">return</span> <span class="keyword">not</span> attr <span class="keyword">or</span> <span class="keyword">not</span> <span class="global">next</span>(attr) <span class="keyword">end</span>
<span class="keyword">local</span> <span class="keyword">function</span> is_element(d) <span class="keyword">return</span> <span class="global">type</span>(d) == <span class="string">'table'</span> <span class="keyword">and</span> d.tag ~= <span class="keyword">nil</span> <span class="keyword">end</span>

<span class="comment">-- returns the key,value pair from a table if it has exactly one entry
</span><span class="keyword">local</span> <span class="keyword">function</span> has_one_element(t)
    <span class="keyword">local</span> key,value = <span class="global">next</span>(t)
    <span class="keyword">if</span> <span class="global">next</span>(t,key) ~= <span class="keyword">nil</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">end</span>
    <span class="keyword">return</span> key,value
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> append_capture(res,tbl)
    <span class="keyword">if</span> <span class="keyword">not</span> empty(tbl) <span class="keyword">then</span> <span class="comment">-- no point in capturing empty tables...
</span>        <span class="keyword">local</span> key
        <span class="keyword">if</span> tbl._ <span class="keyword">then</span>  <span class="comment">-- if $_ was set then it is meant as the top-level key for the captured table
</span>            key = tbl._
            tbl._ = <span class="keyword">nil</span>
            <span class="keyword">if</span> empty(tbl) <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="comment">-- a table with only one pair {[0]=value} shall be reduced to that value
</span>        <span class="keyword">local</span> numkey,val = has_one_element(tbl)
        <span class="keyword">if</span> numkey == <span class="number">0</span> <span class="keyword">then</span> tbl = val <span class="keyword">end</span>
        <span class="keyword">if</span> key <span class="keyword">then</span>
            res[key] = tbl
        <span class="keyword">else</span> <span class="comment">-- otherwise, we append the captured table
</span>            t_insert(res,tbl)
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> make_number(pat)
    <span class="keyword">if</span> pat:find <span class="string">'^%d+$'</span> <span class="keyword">then</span> <span class="comment">-- $1 etc means use this as an array location
</span>        pat = <span class="global">tonumber</span>(pat)
    <span class="keyword">end</span>
    <span class="keyword">return</span> pat
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> capture_attrib(res,pat,value)
    pat = make_number(pat:sub(<span class="number">2</span>))
    res[pat] = value
    <span class="keyword">return</span> <span class="keyword">true</span>
<span class="keyword">end</span>

<span class="keyword">local</span> match
<span class="keyword">function</span> match(d,pat,res,keep_going)
    <span class="keyword">local</span> ret = <span class="keyword">true</span>
    <span class="keyword">if</span> d == <span class="keyword">nil</span> <span class="keyword">then</span> d = <span class="string">''</span> <span class="keyword">end</span> <span class="comment">--return false end
</span>    <span class="comment">-- attribute string matching is straight equality, except if the pattern is a $ capture,
</span>    <span class="comment">-- which always succeeds.
</span>    <span class="keyword">if</span> is_text(d) <span class="keyword">then</span>
        <span class="keyword">if</span> <span class="keyword">not</span> is_text(pat) <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">end</span>
        <span class="keyword">if</span> _M.<span class="global">debug</span> <span class="keyword">then</span> <span class="global">print</span>(d,pat) <span class="keyword">end</span>
        <span class="keyword">if</span> pat:find <span class="string">'^%$'</span> <span class="keyword">then</span>
            <span class="keyword">return</span> capture_attrib(res,pat,d)
        <span class="keyword">else</span>
            <span class="keyword">return</span> d == pat
        <span class="keyword">end</span>
    <span class="keyword">else</span>
    <span class="keyword">if</span> _M.<span class="global">debug</span> <span class="keyword">then</span> <span class="global">print</span>(d.tag,pat.tag) <span class="keyword">end</span>
        <span class="comment">-- this is an element node. For a match to succeed, the attributes must
</span>        <span class="comment">-- match as well.
</span>        <span class="comment">-- a tagname in the pattern ending with '-' is a wildcard and matches like an attribute
</span>        <span class="keyword">local</span> tagpat = pat.tag:match <span class="string">'^(.-)%-$'</span>
        <span class="keyword">if</span> tagpat <span class="keyword">then</span>
            tagpat = make_number(tagpat)
            res[tagpat] = d.tag
        <span class="keyword">end</span>
        <span class="keyword">if</span> d.tag == pat.tag <span class="keyword">or</span> tagpat <span class="keyword">then</span>

            <span class="keyword">if</span> <span class="keyword">not</span> empty(pat.attr) <span class="keyword">then</span>
                <span class="keyword">if</span> empty(d.attr) <span class="keyword">then</span> ret =  <span class="keyword">false</span>
                <span class="keyword">else</span>
                    <span class="keyword">for</span> prop,pval <span class="keyword">in</span> <span class="global">pairs</span>(pat.attr) <span class="keyword">do</span>
                        <span class="keyword">local</span> dval = d.attr[prop]
                        <span class="keyword">if</span> <span class="keyword">not</span> match(dval,pval,res) <span class="keyword">then</span> ret = <span class="keyword">false</span>;  <span class="keyword">break</span> <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="comment">-- the pattern may have child nodes. We match partially, so that {P1,P2} shall match {X,P1,X,X,P2,..}
</span>            <span class="keyword">if</span> ret <span class="keyword">and</span> #pat &gt; <span class="number">0</span> <span class="keyword">then</span>
                <span class="keyword">local</span> i,j = <span class="number">1</span>,<span class="number">1</span>
                <span class="keyword">local</span> <span class="keyword">function</span> next_elem()
                    j = j + <span class="number">1</span>  <span class="comment">-- next child element of data
</span>                    <span class="keyword">if</span> is_text(d[j]) <span class="keyword">then</span> j = j + <span class="number">1</span> <span class="keyword">end</span>
                    <span class="keyword">return</span> j &lt;= #d
                <span class="keyword">end</span>
                <span class="keyword">repeat</span>
                    <span class="keyword">local</span> p = pat[i]
                    <span class="comment">-- repeated {{&lt;...&gt;}} patterns  shall match one or more elements
</span>                    <span class="comment">-- so e.g. {P+} will match {X,X,P,P,X,P,X,X,X}
</span>                    <span class="keyword">if</span> is_element(p) <span class="keyword">and</span> p.repeated <span class="keyword">then</span>
                        <span class="keyword">local</span> found
                        <span class="keyword">repeat</span>
                            <span class="keyword">local</span> tbl = {}
                            ret = match(d[j],p,tbl,<span class="keyword">false</span>)
                            <span class="keyword">if</span> ret <span class="keyword">then</span>
                                found = <span class="keyword">false</span> <span class="comment">--true
</span>                                append_capture(res,tbl)
                            <span class="keyword">end</span>
                        <span class="keyword">until</span> <span class="keyword">not</span> next_elem() <span class="keyword">or</span> (found <span class="keyword">and</span> <span class="keyword">not</span> ret)
                        i = i + <span class="number">1</span>
                    <span class="keyword">else</span>
                        ret = match(d[j],p,res,<span class="keyword">false</span>)
                        <span class="keyword">if</span> ret <span class="keyword">then</span> i = i + <span class="number">1</span> <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">until</span> <span class="keyword">not</span> next_elem() <span class="keyword">or</span> i &gt; #pat <span class="comment">-- run out of elements or patterns to match
</span>                <span class="comment">-- if every element in our pattern matched ok, then it's been a successful match
</span>                <span class="keyword">if</span> i &gt; #pat <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="keyword">if</span> ret <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">end</span>
        <span class="keyword">else</span>
            ret = <span class="keyword">false</span>
        <span class="keyword">end</span>
        <span class="comment">-- keep going anyway - look at the children!
</span>        <span class="keyword">if</span> keep_going <span class="keyword">then</span>
            <span class="keyword">for</span> child <span class="keyword">in</span> d:childtags() <span class="keyword">do</span>
                ret = match(child,pat,res,keep_going)
                <span class="keyword">if</span> ret <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> ret
<span class="keyword">end</span>

<span class="keyword">function</span> Doc:match(pat)
    <span class="keyword">local</span> err
    pat,err = template_cache(pat)
    <span class="keyword">if</span> <span class="keyword">not</span> pat <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span>, err <span class="keyword">end</span>
    _M.walk(pat,<span class="keyword">false</span>,<span class="keyword">function</span>(_,d)
        <span class="keyword">if</span> is_text(d[<span class="number">1</span>]) <span class="keyword">and</span> is_element(d[<span class="number">2</span>]) <span class="keyword">and</span> is_text(d[<span class="number">3</span>]) <span class="keyword">and</span>
           d[<span class="number">1</span>]:find <span class="string">'%s*{{'</span> <span class="keyword">and</span> d[<span class="number">3</span>]:find <span class="string">'}}%s*'</span> <span class="keyword">then</span>
           t_remove(d,<span class="number">1</span>)
           t_remove(d,<span class="number">2</span>)
           d[<span class="number">1</span>].repeated = <span class="keyword">true</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>)

    <span class="keyword">local</span> res = {}
    <span class="keyword">local</span> ret = match(self,pat,res,<span class="keyword">true</span>)
    <span class="keyword">return</span> res,ret
<span class="keyword">end</span>


<span class="keyword">return</span> _M</pre>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.3</a></i>
<i style="float:right;">Last updated 2014-11-01 18:36:39 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
