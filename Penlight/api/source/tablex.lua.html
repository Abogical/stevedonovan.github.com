<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Penlight Documentation</title>
    <link rel="stylesheet" href="../ldoc_fixed.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Penlight</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Source</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../source/app.lua.html">app.lua</a></li>
  <li><a href="../source/array2d.lua.html">array2d.lua</a></li>
  <li><a href="../source/class.lua.html">class.lua</a></li>
  <li><a href="../source/compat.lua.html">compat.lua</a></li>
  <li><a href="../source/comprehension.lua.html">comprehension.lua</a></li>
  <li><a href="../source/config.lua.html">config.lua</a></li>
  <li><a href="../source/data.lua.html">data.lua</a></li>
  <li><a href="../source/date.lua.html">date.lua</a></li>
  <li><a href="../source/dir.lua.html">dir.lua</a></li>
  <li><a href="../source/file.lua.html">file.lua</a></li>
  <li><a href="../source/func.lua.html">func.lua</a></li>
  <li><a href="../source/import_into.lua.html">import_into.lua</a></li>
  <li><a href="../source/init.lua.html">init.lua</a></li>
  <li><a href="../source/input.lua.html">input.lua</a></li>
  <li><a href="../source/lapp.lua.html">lapp.lua</a></li>
  <li><a href="../source/lexer.lua.html">lexer.lua</a></li>
  <li><a href="../source/list.lua.html">list.lua</a></li>
  <li><a href="../source/luabalanced.lua.html">luabalanced.lua</a></li>
  <li><a href="../source/map.lua.html">map.lua</a></li>
  <li><a href="../source/multimap.lua.html">multimap.lua</a></li>
  <li><a href="../source/operator.lua.html">operator.lua</a></li>
  <li><a href="../source/orderedmap.lua.html">orderedmap.lua</a></li>
  <li><a href="../source/path.lua.html">path.lua</a></li>
  <li><a href="../source/permute.lua.html">permute.lua</a></li>
  <li><a href="../source/pretty.lua.html">pretty.lua</a></li>
  <li><a href="../source/seesubst.lua.html">seesubst.lua</a></li>
  <li><a href="../source/seq.lua.html">seq.lua</a></li>
  <li><a href="../source/set.lua.html">set.lua</a></li>
  <li><a href="../source/sip.lua.html">sip.lua</a></li>
  <li><a href="../source/sipscan.lua.html">sipscan.lua</a></li>
  <li><a href="../source/strict.lua.html">strict.lua</a></li>
  <li><a href="../source/stringio.lua.html">stringio.lua</a></li>
  <li><a href="../source/stringx.lua.html">stringx.lua</a></li>
  <li><a href="../source/symbols.lua.html">symbols.lua</a></li>
  <li><strong>tablex.lua</strong></li>
  <li><a href="../source/template.lua.html">template.lua</a></li>
  <li><a href="../source/test-cmp.lua.html">test-cmp.lua</a></li>
  <li><a href="../source/test-data.lua.html">test-data.lua</a></li>
  <li><a href="../source/test-listcallbacks.lua.html">test-listcallbacks.lua</a></li>
  <li><a href="../source/test-pretty.lua.html">test-pretty.lua</a></li>
  <li><a href="../source/test-symbols.lua.html">test-symbols.lua</a></li>
  <li><a href="../source/test.lua.html">test.lua</a></li>
  <li><a href="../source/testapp.lua.html">testapp.lua</a></li>
  <li><a href="../source/testclone.lua.html">testclone.lua</a></li>
  <li><a href="../source/testconfig.lua.html">testconfig.lua</a></li>
  <li><a href="../source/testglobal.lua.html">testglobal.lua</a></li>
  <li><a href="../source/testinputfields.lua.html">testinputfields.lua</a></li>
  <li><a href="../source/testinputfields2.lua.html">testinputfields2.lua</a></li>
  <li><a href="../source/testxml.lua.html">testxml.lua</a></li>
  <li><a href="../source/text.lua.html">text.lua</a></li>
  <li><a href="../source/types.lua.html">types.lua</a></li>
  <li><a href="../source/url.lua.html">url.lua</a></li>
  <li><a href="../source/utils.lua.html">utils.lua</a></li>
  <li><a href="../source/which.lua.html">which.lua</a></li>
  <li><a href="../source/xml.lua.html">xml.lua</a></li>
</ul>
<h2>Libraries</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../libraries/pl.html">pl</a></li>
  <li><a href="../libraries/pl.app.html">pl.app</a></li>
  <li><a href="../libraries/pl.array2d.html">pl.array2d</a></li>
  <li><a href="../libraries/pl.class.html">pl.class</a></li>
  <li><a href="../libraries/pl.compat.html">pl.compat</a></li>
  <li><a href="../libraries/pl.comprehension.html">pl.comprehension</a></li>
  <li><a href="../libraries/pl.config.html">pl.config</a></li>
  <li><a href="../libraries/pl.data.html">pl.data</a></li>
  <li><a href="../libraries/pl.dir.html">pl.dir</a></li>
  <li><a href="../libraries/pl.file.html">pl.file</a></li>
  <li><a href="../libraries/pl.func.html">pl.func</a></li>
  <li><a href="../libraries/pl.import_into.html">pl.import_into</a></li>
  <li><a href="../libraries/pl.input.html">pl.input</a></li>
  <li><a href="../libraries/pl.lapp.html">pl.lapp</a></li>
  <li><a href="../libraries/pl.lexer.html">pl.lexer</a></li>
  <li><a href="../libraries/pl.luabalanced.html">pl.luabalanced</a></li>
  <li><a href="../libraries/pl.operator.html">pl.operator</a></li>
  <li><a href="../libraries/pl.path.html">pl.path</a></li>
  <li><a href="../libraries/pl.permute.html">pl.permute</a></li>
  <li><a href="../libraries/pl.pretty.html">pl.pretty</a></li>
  <li><a href="../libraries/pl.seq.html">pl.seq</a></li>
  <li><a href="../libraries/pl.sip.html">pl.sip</a></li>
  <li><a href="../libraries/pl.strict.html">pl.strict</a></li>
  <li><a href="../libraries/pl.stringio.html">pl.stringio</a></li>
  <li><a href="../libraries/pl.stringx.html">pl.stringx</a></li>
  <li><a href="../libraries/pl.tablex.html">pl.tablex</a></li>
  <li><a href="../libraries/pl.template.html">pl.template</a></li>
  <li><a href="../libraries/pl.test.html">pl.test</a></li>
  <li><a href="../libraries/pl.text.html">pl.text</a></li>
  <li><a href="../libraries/pl.types.html">pl.types</a></li>
  <li><a href="../libraries/pl.url.html">pl.url</a></li>
  <li><a href="../libraries/pl.utils.html">pl.utils</a></li>
  <li><a href="../libraries/pl.xml.html">pl.xml</a></li>
</ul>
<h2>Classes</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../classes/pl.Date.html">pl.Date</a></li>
  <li><a href="../classes/pl.List.html">pl.List</a></li>
  <li><a href="../classes/pl.Map.html">pl.Map</a></li>
  <li><a href="../classes/pl.MultiMap.html">pl.MultiMap</a></li>
  <li><a href="../classes/pl.OrderedMap.html">pl.OrderedMap</a></li>
  <li><a href="../classes/pl.Set.html">pl.Set</a></li>
</ul>
<h2>Manual</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../manual/01-introduction.md.html">Introduction</a></li>
  <li><a href="../manual/02-arrays.md.html">Tables and Arrays</a></li>
  <li><a href="../manual/03-strings.md.html">Strings. Higher-level operations on strings.</a></li>
  <li><a href="../manual/04-paths.md.html">Paths and Directories</a></li>
  <li><a href="../manual/05-dates.md.html">Date and Time</a></li>
  <li><a href="../manual/06-data.md.html">Data</a></li>
  <li><a href="../manual/07-functional.md.html">Functional Programming</a></li>
  <li><a href="../manual/08-additional.md.html">Additional Libraries</a></li>
  <li><a href="../manual/09-discussion.md.html">Technical Choices</a></li>
</ul>
<h2>Examples</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../examples/seesubst.lua.html">seesubst.lua</a></li>
  <li><a href="../examples/sipscan.lua.html">sipscan.lua</a></li>
  <li><a href="../examples/symbols.lua.html">symbols.lua</a></li>
  <li><a href="../examples/test-cmp.lua.html">test-cmp.lua</a></li>
  <li><a href="../examples/test-data.lua.html">test-data.lua</a></li>
  <li><a href="../examples/test-listcallbacks.lua.html">test-listcallbacks.lua</a></li>
  <li><a href="../examples/test-pretty.lua.html">test-pretty.lua</a></li>
  <li><a href="../examples/test-symbols.lua.html">test-symbols.lua</a></li>
  <li><a href="../examples/testapp.lua.html">testapp.lua</a></li>
  <li><a href="../examples/testclone.lua.html">testclone.lua</a></li>
  <li><a href="../examples/testconfig.lua.html">testconfig.lua</a></li>
  <li><a href="../examples/testglobal.lua.html">testglobal.lua</a></li>
  <li><a href="../examples/testinputfields.lua.html">testinputfields.lua</a></li>
  <li><a href="../examples/testinputfields2.lua.html">testinputfields2.lua</a></li>
  <li><a href="../examples/testxml.lua.html">testxml.lua</a></li>
  <li><a href="../examples/which.lua.html">which.lua</a></li>
</ul>

</div>

<div id="content">

    <h2>tablex.lua</h2>
<pre>
<span class="comment">--- Extended operations on Lua tables.
</span><span class="comment">--
</span><span class="comment">-- See <a href="../manual/02-arrays.md.html#Useful_Operations_on_Tables">the Guide</a>
</span><span class="comment">--
</span><span class="comment">-- Dependencies: <a href="../libraries/pl.utils.html#">pl.utils</a>, <a href="../libraries/pl.types.html#">pl.types</a>
</span><span class="comment">-- @module pl.tablex
</span><span class="keyword">local</span> utils = <span class="global">require</span> (<span class="string">'pl.utils'</span>)
<span class="keyword">local</span> types = <span class="global">require</span> (<span class="string">'pl.types'</span>)
<span class="keyword">local</span> <span class="global">getmetatable</span>,<span class="global">setmetatable</span>,<span class="global">require</span> = <span class="global">getmetatable</span>,<span class="global">setmetatable</span>,<span class="global">require</span>
<span class="keyword">local</span> tsort,append,remove = <span class="global">table</span>.sort,<span class="global">table</span>.insert,<span class="global">table</span>.remove
<span class="keyword">local</span> min,max = <span class="global">math</span>.min,<span class="global">math</span>.max
<span class="keyword">local</span> <span class="global">pairs</span>,<span class="global">type</span>,<span class="global">unpack</span>,<span class="global">next</span>,<span class="global">select</span>,<span class="global">tostring</span> = <span class="global">pairs</span>,<span class="global">type</span>,utils.<span class="global">unpack</span>,<span class="global">next</span>,<span class="global">select</span>,<span class="global">tostring</span>
<span class="keyword">local</span> function_arg = utils.function_arg
<span class="keyword">local</span> Set = utils.stdmt.Set
<span class="keyword">local</span> List = utils.stdmt.List
<span class="keyword">local</span> Map = utils.stdmt.Map
<span class="keyword">local</span> assert_arg = utils.assert_arg

<span class="keyword">local</span> tablex = {}

<span class="comment">-- generally, functions that make copies of tables try to preserve the metatable.
</span><span class="comment">-- However, when the source has no obvious type, then we attach appropriate metatables
</span><span class="comment">-- like List, Map, etc to the result.
</span><span class="keyword">local</span> <span class="keyword">function</span> setmeta (res,tbl,def)
    <span class="keyword">local</span> mt = <span class="global">getmetatable</span>(tbl) <span class="keyword">or</span> def
    <span class="keyword">return</span> <span class="global">setmetatable</span>(res, mt)
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> makelist (res)
    <span class="keyword">return</span> <span class="global">setmetatable</span>(res,List)
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> complain (idx,msg)
    error((<span class="string">'argument %d is not %s'</span>):format(idx,msg),<span class="number">3</span>)
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> assert_arg_indexable (idx,val)
    <span class="keyword">if</span> <span class="keyword">not</span> types.is_indexable(val) <span class="keyword">then</span>
        complain(idx,<span class="string">"indexable"</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> assert_arg_iterable (idx,val)
    <span class="keyword">if</span> <span class="keyword">not</span> types.is_iterable(val) <span class="keyword">then</span>
        complain(idx,<span class="string">"iterable"</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> assert_arg_writeable (idx,val)
    <span class="keyword">if</span> <span class="keyword">not</span> types.is_writeable(val) <span class="keyword">then</span>
        complain(idx,<span class="string">"writeable"</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- copy a table into another, in-place.
</span><span class="comment">-- @within Copying
</span><span class="comment">-- @tab t1 destination table
</span><span class="comment">-- @tab t2 source (actually any iterable object)
</span><a id="60"></a><span class="comment">-- @return first table
</span><span class="keyword">function</span> tablex.update (t1,t2)
    assert_arg_writeable(<span class="number">1</span>,t1)
    assert_arg_iterable(<span class="number">2</span>,t2)
    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(t2) <span class="keyword">do</span>
        t1[k] = v
    <span class="keyword">end</span>
    <span class="keyword">return</span> t1
<span class="keyword">end</span>

<span class="comment">--- total number of elements in this table.
</span><span class="comment">-- Note that this is distinct from <code>#t</code>, which is the number
</span><span class="comment">-- of values in the array part; this value will always
</span><span class="comment">-- be greater or equal. The difference gives the size of
</span><span class="comment">-- the hash part, for practical purposes. Works for any
</span><span class="comment">-- object with a __pairs metamethod.
</span><span class="comment">-- @tab t a table
</span><a id="77"></a><span class="comment">-- @return the size
</span><span class="keyword">function</span> tablex.size (t)
    assert_arg_iterable(<span class="number">1</span>,t)
    <span class="keyword">local</span> i = <span class="number">0</span>
    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="global">pairs</span>(t) <span class="keyword">do</span> i = i + <span class="number">1</span> <span class="keyword">end</span>
    <span class="keyword">return</span> i
<span class="keyword">end</span>

<span class="comment">--- make a shallow copy of a table
</span><span class="comment">-- @within Copying
</span><span class="comment">-- @tab t an iterable source
</span><a id="88"></a><span class="comment">-- @return new table
</span><span class="keyword">function</span> tablex.copy (t)
    assert_arg_iterable(<span class="number">1</span>,t)
    <span class="keyword">local</span> res = {}
    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(t) <span class="keyword">do</span>
        res[k] = v
    <span class="keyword">end</span>
    <span class="keyword">return</span> res
<span class="keyword">end</span>

<span class="comment">--- make a deep copy of a table, recursively copying all the keys and fields.
</span><span class="comment">-- This will also set the copied table's metatable to that of the original.
</span><span class="comment">-- @within Copying
</span><span class="comment">-- @tab t A table
</span><a id="102"></a><span class="comment">-- @return new table
</span><span class="keyword">function</span> tablex.deepcopy(t)
    <span class="keyword">if</span> <span class="global">type</span>(t) ~= <span class="string">'table'</span> <span class="keyword">then</span> <span class="keyword">return</span> t <span class="keyword">end</span>
    assert_arg_iterable(<span class="number">1</span>,t)
    <span class="keyword">local</span> mt = <span class="global">getmetatable</span>(t)
    <span class="keyword">local</span> res = {}
    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(t) <span class="keyword">do</span>
        <span class="keyword">if</span> <span class="global">type</span>(v) == <span class="string">'table'</span> <span class="keyword">then</span>
            v = tablex.deepcopy(v)
        <span class="keyword">end</span>
        res[k] = v
    <span class="keyword">end</span>
    <span class="global">setmetatable</span>(res,mt)
    <span class="keyword">return</span> res
<span class="keyword">end</span>

<span class="keyword">local</span> abs, deepcompare = <span class="global">math</span>.abs

<span class="comment">--- compare two values.
</span><span class="comment">-- if they are tables, then compare their keys and fields recursively.
</span><span class="comment">-- @within Comparing
</span><span class="comment">-- @param t1 A value
</span><span class="comment">-- @param t2 A value
</span><span class="comment">-- @bool[opt] ignore_mt if true, ignore __eq metamethod (default false)
</span><span class="comment">-- @number[opt] eps if defined, then used for any number comparisons
</span><a id="127"></a><span class="comment">-- @return true or false
</span><span class="keyword">function</span> tablex.deepcompare(t1,t2,ignore_mt,eps)
    <span class="keyword">local</span> ty1 = <span class="global">type</span>(t1)
    <span class="keyword">local</span> ty2 = <span class="global">type</span>(t2)
    <span class="keyword">if</span> ty1 ~= ty2 <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">end</span>
    <span class="comment">-- non-table types can be directly compared
</span>    <span class="keyword">if</span> ty1 ~= <span class="string">'table'</span> <span class="keyword">then</span>
        <span class="keyword">if</span> ty1 == <span class="string">'number'</span> <span class="keyword">and</span> eps <span class="keyword">then</span> <span class="keyword">return</span> abs(t1-t2) &lt; eps <span class="keyword">end</span>
        <span class="keyword">return</span> t1 == t2
    <span class="keyword">end</span>
    <span class="comment">-- as well as tables which have the metamethod __eq
</span>    <span class="keyword">local</span> mt = <span class="global">getmetatable</span>(t1)
    <span class="keyword">if</span> <span class="keyword">not</span> ignore_mt <span class="keyword">and</span> mt <span class="keyword">and</span> mt.__eq <span class="keyword">then</span> <span class="keyword">return</span> t1 == t2 <span class="keyword">end</span>
    <span class="keyword">for</span> k1 <span class="keyword">in</span> <span class="global">pairs</span>(t1) <span class="keyword">do</span>
        <span class="keyword">if</span> t2[k1]==<span class="keyword">nil</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">for</span> k2 <span class="keyword">in</span> <span class="global">pairs</span>(t2) <span class="keyword">do</span>
        <span class="keyword">if</span> t1[k2]==<span class="keyword">nil</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">for</span> k1,v1 <span class="keyword">in</span> <span class="global">pairs</span>(t1) <span class="keyword">do</span>
        <span class="keyword">local</span> v2 = t2[k1]
        <span class="keyword">if</span> <span class="keyword">not</span> deepcompare(v1,v2,ignore_mt,eps) <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">return</span> <span class="keyword">true</span>
<span class="keyword">end</span>

deepcompare = tablex.deepcompare

<span class="comment">--- compare two arrays using a predicate.
</span><span class="comment">-- @within Comparing
</span><span class="comment">-- @array t1 an array
</span><span class="comment">-- @array t2 an array
</span><a id="160"></a><span class="comment">-- @func cmp A comparison function
</span><span class="keyword">function</span> tablex.compare (t1,t2,cmp)
    assert_arg_indexable(<span class="number">1</span>,t1)
    assert_arg_indexable(<span class="number">2</span>,t2)
    <span class="keyword">if</span> #t1 ~= #t2 <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">end</span>
    cmp = function_arg(<span class="number">3</span>,cmp)
    <span class="keyword">for</span> k = <span class="number">1</span>,#t1 <span class="keyword">do</span>
        <span class="keyword">if</span> <span class="keyword">not</span> cmp(t1[k],t2[k]) <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="keyword">true</span>
<span class="keyword">end</span>

<span class="comment">--- compare two list-like tables using an optional predicate, without regard for element order.
</span><span class="comment">-- @within Comparing
</span><span class="comment">-- @array t1 a list-like table
</span><span class="comment">-- @array t2 a list-like table
</span><a id="176"></a><span class="comment">-- @param cmp A comparison function (may be nil)
</span><span class="keyword">function</span> tablex.compare_no_order (t1,t2,cmp)
    assert_arg_indexable(<span class="number">1</span>,t1)
    assert_arg_indexable(<span class="number">2</span>,t2)
    <span class="keyword">if</span> cmp <span class="keyword">then</span> cmp = function_arg(<span class="number">3</span>,cmp) <span class="keyword">end</span>
    <span class="keyword">if</span> #t1 ~= #t2 <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">end</span>
    <span class="keyword">local</span> visited = {}
    <span class="keyword">for</span> i = <span class="number">1</span>,#t1 <span class="keyword">do</span>
        <span class="keyword">local</span> val = t1[i]
        <span class="keyword">local</span> gotcha
        <span class="keyword">for</span> j = <span class="number">1</span>,#t2 <span class="keyword">do</span> <span class="keyword">if</span> <span class="keyword">not</span> visited[j] <span class="keyword">then</span>
            <span class="keyword">local</span> match
            <span class="keyword">if</span> cmp <span class="keyword">then</span> match = cmp(val,t2[j]) <span class="keyword">else</span> match = val == t2[j] <span class="keyword">end</span>
            <span class="keyword">if</span> match <span class="keyword">then</span>
                gotcha = j
                <span class="keyword">break</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span> <span class="keyword">end</span>
        <span class="keyword">if</span> <span class="keyword">not</span> gotcha <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">false</span> <span class="keyword">end</span>
        visited[gotcha] = <span class="keyword">true</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="keyword">true</span>
<span class="keyword">end</span>


<span class="comment">--- return the index of a value in a list.
</span><span class="comment">-- Like string.find, there is an optional index to start searching,
</span><span class="comment">-- which can be negative.
</span><span class="comment">-- @within Finding
</span><span class="comment">-- @array t A list-like table
</span><span class="comment">-- @param val A value
</span><span class="comment">-- @int idx index to start; -1 means last element,etc (default 1)
</span><span class="comment">-- @return index of value or nil if not found
</span><span class="comment">-- @usage find({10,20,30},20) == 2
</span><a id="210"></a><span class="comment">-- @usage find({'a','b','a','c'},'a',2) == 3
</span><span class="keyword">function</span> tablex.find(t,val,idx)
    assert_arg_indexable(<span class="number">1</span>,t)
    idx = idx <span class="keyword">or</span> <span class="number">1</span>
    <span class="keyword">if</span> idx &lt; <span class="number">0</span> <span class="keyword">then</span> idx = #t + idx + <span class="number">1</span> <span class="keyword">end</span>
    <span class="keyword">for</span> i = idx,#t <span class="keyword">do</span>
        <span class="keyword">if</span> t[i] == val <span class="keyword">then</span> <span class="keyword">return</span> i <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="keyword">nil</span>
<span class="keyword">end</span>

<span class="comment">--- return the index of a value in a list, searching from the end.
</span><span class="comment">-- Like string.find, there is an optional index to start searching,
</span><span class="comment">-- which can be negative.
</span><span class="comment">-- @within Finding
</span><span class="comment">-- @array t A list-like table
</span><span class="comment">-- @param val A value
</span><span class="comment">-- @param idx index to start; -1 means last element,etc (default 1)
</span><span class="comment">-- @return index of value or nil if not found
</span><a id="229"></a><span class="comment">-- @usage rfind({10,10,10},10) == 3
</span><span class="keyword">function</span> tablex.rfind(t,val,idx)
    assert_arg_indexable(<span class="number">1</span>,t)
    idx = idx <span class="keyword">or</span> #t
    <span class="keyword">if</span> idx &lt; <span class="number">0</span> <span class="keyword">then</span> idx = #t + idx + <span class="number">1</span> <span class="keyword">end</span>
    <span class="keyword">for</span> i = idx,<span class="number">1</span>,-<span class="number">1</span> <span class="keyword">do</span>
        <span class="keyword">if</span> t[i] == val <span class="keyword">then</span> <span class="keyword">return</span> i <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="keyword">nil</span>
<span class="keyword">end</span>


<span class="comment">--- return the index (or key) of a value in a table using a comparison function.
</span><span class="comment">-- @within Finding
</span><span class="comment">-- @tab t A table
</span><span class="comment">-- @func cmp A comparison function
</span><span class="comment">-- @param arg an optional second argument to the function
</span><span class="comment">-- @return index of value, or nil if not found
</span><a id="247"></a><span class="comment">-- @return value returned by comparison function
</span><span class="keyword">function</span> tablex.find_if(t,cmp,arg)
    assert_arg_iterable(<span class="number">1</span>,t)
    cmp = function_arg(<span class="number">2</span>,cmp)
    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(t) <span class="keyword">do</span>
        <span class="keyword">local</span> c = cmp(v,arg)
        <span class="keyword">if</span> c <span class="keyword">then</span> <span class="keyword">return</span> k,c <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="keyword">nil</span>
<span class="keyword">end</span>

<span class="comment">--- return a list of all values in a table indexed by another list.
</span><span class="comment">-- @tab tbl a table
</span><span class="comment">-- @array idx an index table (a list of keys)
</span><span class="comment">-- @return a list-like table
</span><span class="comment">-- @usage index_by({10,20,30,40},{2,4}) == {20,40}
</span><a id="263"></a><span class="comment">-- @usage index_by({one=1,two=2,three=3},{'one','three'}) == {1,3}
</span><span class="keyword">function</span> tablex.index_by(tbl,idx)
    assert_arg_indexable(<span class="number">1</span>,tbl)
    assert_arg_indexable(<span class="number">2</span>,idx)
    <span class="keyword">local</span> res = {}
    <span class="keyword">for</span> i = <span class="number">1</span>,#idx <span class="keyword">do</span>
        res[i] = tbl[idx[i]]
    <span class="keyword">end</span>
    <span class="keyword">return</span> setmeta(res,tbl,List)
<span class="keyword">end</span>

<span class="comment">--- apply a function to all values of a table.
</span><span class="comment">-- This returns a table of the results.
</span><span class="comment">-- Any extra arguments are passed to the function.
</span><span class="comment">-- @within MappingAndFiltering
</span><span class="comment">-- @func fun A function that takes at least one argument
</span><span class="comment">-- @tab t A table
</span><span class="comment">-- @param ... optional arguments
</span><a id="281"></a><span class="comment">-- @usage map(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900,fred=4}
</span><span class="keyword">function</span> tablex.map(fun,t,...)
    assert_arg_iterable(<span class="number">1</span>,t)
    fun = function_arg(<span class="number">1</span>,fun)
    <span class="keyword">local</span> res = {}
    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(t) <span class="keyword">do</span>
        res[k] = fun(v,...)
    <span class="keyword">end</span>
    <span class="keyword">return</span> setmeta(res,t)
<span class="keyword">end</span>

<span class="comment">--- apply a function to all values of a list.
</span><span class="comment">-- This returns a table of the results.
</span><span class="comment">-- Any extra arguments are passed to the function.
</span><span class="comment">-- @within MappingAndFiltering
</span><span class="comment">-- @func fun A function that takes at least one argument
</span><span class="comment">-- @array t a table (applies to array part)
</span><span class="comment">-- @param ... optional arguments
</span><span class="comment">-- @return a list-like table
</span><a id="300"></a><span class="comment">-- @usage imap(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900}
</span><span class="keyword">function</span> tablex.imap(fun,t,...)
    assert_arg_indexable(<span class="number">1</span>,t)
    fun = function_arg(<span class="number">1</span>,fun)
    <span class="keyword">local</span> res = {}
    <span class="keyword">for</span> i = <span class="number">1</span>,#t <span class="keyword">do</span>
        res[i] = fun(t[i],...) <span class="keyword">or</span> <span class="keyword">false</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> setmeta(res,t,List)
<span class="keyword">end</span>

<span class="comment">--- apply a named method to values from a table.
</span><span class="comment">-- @within MappingAndFiltering
</span><span class="comment">-- @string name the method name
</span><span class="comment">-- @array t a list-like table
</span><a id="315"></a><span class="comment">-- @param ... any extra arguments to the method
</span><span class="keyword">function</span> tablex.map_named_method (name,t,...)
    utils.assert_string(<span class="number">1</span>,name)
    assert_arg_indexable(<span class="number">2</span>,t)
    <span class="keyword">local</span> res = {}
    <span class="keyword">for</span> i = <span class="number">1</span>,#t <span class="keyword">do</span>
        <span class="keyword">local</span> val = t[i]
        <span class="keyword">local</span> fun = val[name]
        res[i] = fun(val,...)
    <span class="keyword">end</span>
    <span class="keyword">return</span> setmeta(res,t,List)
<span class="keyword">end</span>

<span class="comment">--- apply a function to all values of a table, in-place.
</span><span class="comment">-- Any extra arguments are passed to the function.
</span><span class="comment">-- @func fun A function that takes at least one argument
</span><span class="comment">-- @tab t a table
</span><a id="332"></a><span class="comment">-- @param ... extra arguments
</span><span class="keyword">function</span> tablex.transform (fun,t,...)
    assert_arg_iterable(<span class="number">1</span>,t)
    fun = function_arg(<span class="number">1</span>,fun)
    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(t) <span class="keyword">do</span>
        t[k] = fun(v,...)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- generate a table of all numbers in a range.
</span><span class="comment">-- This is consistent with a numerical for loop.
</span><span class="comment">-- @int start  number
</span><span class="comment">-- @int finish number
</span><a id="345"></a><span class="comment">-- @int[opt=1] step  make this negative for start &lt; finish
</span><span class="keyword">function</span> tablex.range (start,finish,step)
    <span class="keyword">local</span> res
    step = step <span class="keyword">or</span> <span class="number">1</span>
    <span class="keyword">if</span> start == finish <span class="keyword">then</span>
        res = {start}
    <span class="keyword">elseif</span> (start &gt; finish <span class="keyword">and</span> step &gt; <span class="number">0</span>) <span class="keyword">or</span> (finish &gt; start <span class="keyword">and</span> step &lt; <span class="number">0</span>) <span class="keyword">then</span>
        res = {}
    <span class="keyword">else</span>
        <span class="keyword">local</span> k = <span class="number">1</span>
        res = {}
        <span class="keyword">for</span> i=start,finish,step <span class="keyword">do</span> res[k]=i; k=k+<span class="number">1</span> <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> makelist(res)
<span class="keyword">end</span>

<span class="comment">--- apply a function to values from two tables.
</span><span class="comment">-- @within MappingAndFiltering
</span><span class="comment">-- @func fun a function of at least two arguments
</span><span class="comment">-- @tab t1 a table
</span><span class="comment">-- @tab t2 a table
</span><span class="comment">-- @param ... extra arguments
</span><span class="comment">-- @return a table
</span><a id="368"></a><span class="comment">-- @usage map2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23,m=44}
</span><span class="keyword">function</span> tablex.map2 (fun,t1,t2,...)
    assert_arg_iterable(<span class="number">1</span>,t1)
    assert_arg_iterable(<span class="number">2</span>,t2)
    fun = function_arg(<span class="number">1</span>,fun)
    <span class="keyword">local</span> res = {}
    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(t1) <span class="keyword">do</span>
        res[k] = fun(v,t2[k],...)
    <span class="keyword">end</span>
    <span class="keyword">return</span> setmeta(res,t1,List)
<span class="keyword">end</span>

<span class="comment">--- apply a function to values from two arrays.
</span><span class="comment">-- The result will be the length of the shortest array.
</span><span class="comment">-- @within MappingAndFiltering
</span><span class="comment">-- @func fun a function of at least two arguments
</span><span class="comment">-- @array t1 a list-like table
</span><span class="comment">-- @array t2 a list-like table
</span><span class="comment">-- @param ... extra arguments
</span><a id="387"></a><span class="comment">-- @usage imap2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23}
</span><span class="keyword">function</span> tablex.imap2 (fun,t1,t2,...)
    assert_arg_indexable(<span class="number">2</span>,t1)
    assert_arg_indexable(<span class="number">3</span>,t2)
    fun = function_arg(<span class="number">1</span>,fun)
    <span class="keyword">local</span> res,n = {},<span class="global">math</span>.min(#t1,#t2)
    <span class="keyword">for</span> i = <span class="number">1</span>,n <span class="keyword">do</span>
        res[i] = fun(t1[i],t2[i],...)
    <span class="keyword">end</span>
    <span class="keyword">return</span> res
<span class="keyword">end</span>

<span class="comment">--- 'reduce' a list using a binary function.
</span><span class="comment">-- @func fun a function of two arguments
</span><span class="comment">-- @array t a list-like table
</span><span class="comment">-- @return the result of the function
</span><a id="403"></a><span class="comment">-- @usage reduce('+',{1,2,3,4}) == 10
</span><span class="keyword">function</span> tablex.reduce (fun,t)
    assert_arg_indexable(<span class="number">2</span>,t)
    fun = function_arg(<span class="number">1</span>,fun)
    <span class="keyword">local</span> n = #t
    <span class="keyword">local</span> res = t[<span class="number">1</span>]
    <span class="keyword">for</span> i = <span class="number">2</span>,n <span class="keyword">do</span>
        res = fun(res,t[i])
    <span class="keyword">end</span>
    <span class="keyword">return</span> res
<span class="keyword">end</span>

<span class="comment">--- apply a function to all elements of a table.
</span><span class="comment">-- The arguments to the function will be the value,
</span><span class="comment">-- the key and _finally_ any extra arguments passed to this function.
</span><span class="comment">-- Note that the Lua 5.0 function table.foreach passed the _key_ first.
</span><span class="comment">-- @within Iterating
</span><span class="comment">-- @tab t a table
</span><span class="comment">-- @func fun a function with at least one argument
</span><a id="422"></a><span class="comment">-- @param ... extra arguments
</span><span class="keyword">function</span> tablex.foreach(t,fun,...)
    assert_arg_iterable(<span class="number">1</span>,t)
    fun = function_arg(<span class="number">2</span>,fun)
    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(t) <span class="keyword">do</span>
        fun(v,k,...)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- apply a function to all elements of a list-like table in order.
</span><span class="comment">-- The arguments to the function will be the value,
</span><span class="comment">-- the index and _finally_ any extra arguments passed to this function
</span><span class="comment">-- @within Iterating
</span><span class="comment">-- @array t a table
</span><span class="comment">-- @func fun a function with at least one argument
</span><a id="437"></a><span class="comment">-- @param ... optional arguments
</span><span class="keyword">function</span> tablex.foreachi(t,fun,...)
    assert_arg_indexable(<span class="number">1</span>,t)
    fun = function_arg(<span class="number">2</span>,fun)
    <span class="keyword">for</span> i = <span class="number">1</span>,#t <span class="keyword">do</span>
        fun(t[i],i,...)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- Apply a function to a number of tables.
</span><span class="comment">-- A more general version of map
</span><span class="comment">-- The result is a table containing the result of applying that function to the
</span><span class="comment">-- ith value of each table. Length of output list is the minimum length of all the lists
</span><span class="comment">-- @within MappingAndFiltering
</span><span class="comment">-- @func fun a function of n arguments
</span><span class="comment">-- @tab ... n tables
</span><span class="comment">-- @usage mapn(function(x,y,z) return x+y+z end, {1,2,3},{10,20,30},{100,200,300}) is {111,222,333}
</span><span class="comment">-- @usage mapn(math.max, {1,20,300},{10,2,3},{100,200,100}) is	{100,200,300}
</span><a id="455"></a><span class="comment">-- @param fun A function that takes as many arguments as there are tables
</span><span class="keyword">function</span> tablex.mapn(fun,...)
    fun = function_arg(<span class="number">1</span>,fun)
    <span class="keyword">local</span> res = {}
    <span class="keyword">local</span> lists = {...}
    <span class="keyword">local</span> minn = <span class="number">1e40</span>
    <span class="keyword">for</span> i = <span class="number">1</span>,#lists <span class="keyword">do</span>
        minn = min(minn,#(lists[i]))
    <span class="keyword">end</span>
    <span class="keyword">for</span> i = <span class="number">1</span>,minn <span class="keyword">do</span>
        <span class="keyword">local</span> args,k = {},<span class="number">1</span>
        <span class="keyword">for</span> j = <span class="number">1</span>,#lists <span class="keyword">do</span>
            args[k] = lists[j][i]
            k = k + <span class="number">1</span>
        <span class="keyword">end</span>
        res[#res+<span class="number">1</span>] = fun(<span class="global">unpack</span>(args))
    <span class="keyword">end</span>
    <span class="keyword">return</span> res
<span class="keyword">end</span>

<span class="comment">--- call the function with the key and value pairs from a table.
</span><span class="comment">-- The function can return a value and a key (note the order!). If both
</span><span class="comment">-- are not nil, then this pair is inserted into the result. If only value is not nil, then
</span><span class="comment">-- it is appended to the result.
</span><span class="comment">-- @within MappingAndFiltering
</span><span class="comment">-- @func fun A function which will be passed each key and value as arguments, plus any extra arguments to pairmap.
</span><span class="comment">-- @tab t A table
</span><span class="comment">-- @param ... optional arguments
</span><span class="comment">-- @usage pairmap(function(k,v) return v end,{fred=10,bonzo=20}) is {10,20} _or_ {20,10}
</span><a id="484"></a><span class="comment">-- @usage pairmap(function(k,v) return {k,v},k end,{one=1,two=2}) is {one={'one',1},two={'two',2}}
</span><span class="keyword">function</span> tablex.pairmap(fun,t,...)
    assert_arg_iterable(<span class="number">1</span>,t)
    fun = function_arg(<span class="number">1</span>,fun)
    <span class="keyword">local</span> res = {}
    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(t) <span class="keyword">do</span>
        <span class="keyword">local</span> rv,rk = fun(k,v,...)
        <span class="keyword">if</span> rk <span class="keyword">then</span>
            res[rk] = rv
        <span class="keyword">else</span>
            res[#res+<span class="number">1</span>] = rv
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> res
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> keys_op(i,v) <span class="keyword">return</span> i <span class="keyword">end</span>

<span class="comment">--- return all the keys of a table in arbitrary order.
</span><span class="comment">-- @within Extraction
</span><a id="504"></a><span class="comment">--  @tab t A table
</span><span class="keyword">function</span> tablex.keys(t)
    assert_arg_iterable(<span class="number">1</span>,t)
    <span class="keyword">return</span> makelist(tablex.pairmap(keys_op,t))
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> values_op(i,v) <span class="keyword">return</span> v <span class="keyword">end</span>

<span class="comment">--- return all the values of the table in arbitrary order
</span><span class="comment">-- @within Extraction
</span><a id="514"></a><span class="comment">--  @tab t A table
</span><span class="keyword">function</span> tablex.values(t)
    assert_arg_iterable(<span class="number">1</span>,t)
    <span class="keyword">return</span> makelist(tablex.pairmap(values_op,t))
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> index_map_op (i,v) <span class="keyword">return</span> i,v <span class="keyword">end</span>

<span class="comment">--- create an index map from a list-like table. The original values become keys,
</span><span class="comment">-- and the associated values are the indices into the original list.
</span><span class="comment">-- @array t a list-like table
</span><a id="525"></a><span class="comment">-- @return a map-like table
</span><span class="keyword">function</span> tablex.index_map (t)
    assert_arg_indexable(<span class="number">1</span>,t)
    <span class="keyword">return</span> <span class="global">setmetatable</span>(tablex.pairmap(index_map_op,t),Map)
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> set_op(i,v) <span class="keyword">return</span> <span class="keyword">true</span>,v <span class="keyword">end</span>

<span class="comment">--- create a set from a list-like table. A set is a table where the original values
</span><span class="comment">-- become keys, and the associated values are all true.
</span><span class="comment">-- @array t a list-like table
</span><a id="536"></a><span class="comment">-- @return a set (a map-like table)
</span><span class="keyword">function</span> tablex.makeset (t)
    assert_arg_indexable(<span class="number">1</span>,t)
    <span class="keyword">return</span> <span class="global">setmetatable</span>(tablex.pairmap(set_op,t),Set)
<span class="keyword">end</span>

<span class="comment">--- combine two tables, either as union or intersection. Corresponds to
</span><span class="comment">-- set operations for sets () but more general. Not particularly
</span><span class="comment">-- useful for list-like tables.
</span><span class="comment">-- @within Merging
</span><span class="comment">-- @tab t1 a table
</span><span class="comment">-- @tab t2 a table
</span><span class="comment">-- @bool dup true for a union, false for an intersection.
</span><span class="comment">-- @usage merge({alice=23,fred=34},{bob=25,fred=34}) is {fred=34}
</span><span class="comment">-- @usage merge({alice=23,fred=34},{bob=25,fred=34},true) is {bob=25,fred=34,alice=23}
</span><a id="551"></a><span class="comment">-- @see tablex.index_map
</span><span class="keyword">function</span> tablex.merge (t1,t2,dup)
    assert_arg_iterable(<span class="number">1</span>,t1)
    assert_arg_iterable(<span class="number">2</span>,t2)
    <span class="keyword">local</span> res = {}
    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(t1) <span class="keyword">do</span>
        <span class="keyword">if</span> dup <span class="keyword">or</span> t2[k] <span class="keyword">then</span> res[k] = v <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> dup <span class="keyword">then</span>
      <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(t2) <span class="keyword">do</span>
        res[k] = v
      <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> setmeta(res,t1,Map)
<span class="keyword">end</span>

<span class="comment">--- a new table which is the difference of two tables.
</span><span class="comment">-- With sets (where the values are all true) this is set difference and
</span><span class="comment">-- symmetric difference depending on the third parameter.
</span><span class="comment">-- @within Merging
</span><span class="comment">-- @tab s1 a map-like table or set
</span><span class="comment">-- @tab s2 a map-like table or set
</span><span class="comment">-- @bool symm symmetric difference (default false)
</span><a id="574"></a><span class="comment">-- @return a map-like table or set
</span><span class="keyword">function</span> tablex.difference (s1,s2,symm)
    assert_arg_iterable(<span class="number">1</span>,s1)
    assert_arg_iterable(<span class="number">2</span>,s2)
    <span class="keyword">local</span> res = {}
    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(s1) <span class="keyword">do</span>
        <span class="keyword">if</span> s2[k] == <span class="keyword">nil</span> <span class="keyword">then</span> res[k] = v <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> symm <span class="keyword">then</span>
        <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(s2) <span class="keyword">do</span>
            <span class="keyword">if</span> s1[k] == <span class="keyword">nil</span> <span class="keyword">then</span> res[k] = v <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> setmeta(res,s1,Map)
<span class="keyword">end</span>

<span class="comment">--- A table where the key/values are the values and value counts of the table.
</span><span class="comment">-- @array t a list-like table
</span><span class="comment">-- @func cmp a function that defines equality (otherwise uses ==)
</span><span class="comment">-- @return a map-like table
</span><a id="594"></a><span class="comment">-- @see seq.count_map
</span><span class="keyword">function</span> tablex.count_map (t,cmp)
    assert_arg_indexable(<span class="number">1</span>,t)
    <span class="keyword">local</span> res,mask = {},{}
    cmp = function_arg(<span class="number">2</span>,cmp)
    <span class="keyword">local</span> n = #t
    <span class="keyword">for</span> i = <span class="number">1</span>,#t <span class="keyword">do</span>
        <span class="keyword">local</span> v = t[i]
        <span class="keyword">if</span> <span class="keyword">not</span> mask[v] <span class="keyword">then</span>
            mask[v] = <span class="keyword">true</span>
            <span class="comment">-- check this value against all other values
</span>            res[v] = <span class="number">1</span>  <span class="comment">-- there's at least one instance
</span>            <span class="keyword">for</span> j = i+<span class="number">1</span>,n <span class="keyword">do</span>
                <span class="keyword">local</span> w = t[j]
                <span class="keyword">local</span> ok
                <span class="keyword">if</span> cmp <span class="keyword">then</span>
                    ok = cmp(v,w)
                <span class="keyword">else</span>
                    ok = v == w
                <span class="keyword">end</span>
                <span class="keyword">if</span> ok <span class="keyword">then</span>
                    res[v] = res[v] + <span class="number">1</span>
                    mask[w] = <span class="keyword">true</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="global">setmetatable</span>(res,Map)
<span class="keyword">end</span>

<span class="comment">--- filter an array's values using a predicate function
</span><span class="comment">-- @within MappingAndFiltering
</span><span class="comment">-- @array t a list-like table
</span><span class="comment">-- @func pred a boolean function
</span><a id="628"></a><span class="comment">-- @param arg optional argument to be passed as second argument of the predicate
</span><span class="keyword">function</span> tablex.filter (t,pred,arg)
    assert_arg_indexable(<span class="number">1</span>,t)
    pred = function_arg(<span class="number">2</span>,pred)
    <span class="keyword">local</span> res,k = {},<span class="number">1</span>
    <span class="keyword">for</span> i = <span class="number">1</span>,#t <span class="keyword">do</span>
        <span class="keyword">local</span> v = t[i]
        <span class="keyword">if</span> pred(v,arg) <span class="keyword">then</span>
            res[k] = v
            k = k + <span class="number">1</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> setmeta(res,t,List)
<span class="keyword">end</span>

<span class="comment">--- return a table where each element is a table of the ith values of an arbitrary
</span><span class="comment">-- number of tables. It is equivalent to a matrix transpose.
</span><span class="comment">-- @within Merging
</span><span class="comment">-- @usage zip({10,20,30},{100,200,300}) is {{10,100},{20,200},{30,300}}
</span><a id="647"></a><span class="comment">-- @array ... arrays to be zipped
</span><span class="keyword">function</span> tablex.zip(...)
    <span class="keyword">return</span> tablex.mapn(<span class="keyword">function</span>(...) <span class="keyword">return</span> {...} <span class="keyword">end</span>,...)
<span class="keyword">end</span>

<span class="keyword">local</span> _copy
<span class="keyword">function</span> _copy (dest,src,idest,isrc,nsrc,clean_tail)
    idest = idest <span class="keyword">or</span> <span class="number">1</span>
    isrc = isrc <span class="keyword">or</span> <span class="number">1</span>
    <span class="keyword">local</span> iend
    <span class="keyword">if</span> <span class="keyword">not</span> nsrc <span class="keyword">then</span>
        nsrc = #src
        iend = #src
    <span class="keyword">else</span>
        iend = isrc + min(nsrc-<span class="number">1</span>,#src-isrc)
    <span class="keyword">end</span>
    <span class="keyword">if</span> dest == src <span class="keyword">then</span> <span class="comment">-- special case
</span>        <span class="keyword">if</span> idest &gt; isrc <span class="keyword">and</span> iend &gt;= idest <span class="keyword">then</span> <span class="comment">-- overlapping ranges
</span>            src = tablex.sub(src,isrc,nsrc)
            isrc = <span class="number">1</span>; iend = #src
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">for</span> i = isrc,iend <span class="keyword">do</span>
        dest[idest] = src[i]
        idest = idest + <span class="number">1</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> clean_tail <span class="keyword">then</span>
        tablex.clear(dest,idest)
    <span class="keyword">end</span>
    <span class="keyword">return</span> dest
<span class="keyword">end</span>

<span class="comment">--- copy an array into another one, clearing <code>dest</code> after <code>idest+nsrc</code>, if necessary.
</span><span class="comment">-- @within Copying
</span><span class="comment">-- @array dest a list-like table
</span><span class="comment">-- @array src a list-like table
</span><span class="comment">-- @int[opt=1] idest where to start copying values into destination
</span><span class="comment">-- @int[opt=1] isrc where to start copying values from source
</span><a id="685"></a><span class="comment">-- @int[opt=#src] nsrc number of elements to copy from source
</span><span class="keyword">function</span> tablex.icopy (dest,src,idest,isrc,nsrc)
    assert_arg_indexable(<span class="number">1</span>,dest)
    assert_arg_indexable(<span class="number">2</span>,src)
    <span class="keyword">return</span> _copy(dest,src,idest,isrc,nsrc,<span class="keyword">true</span>)
<span class="keyword">end</span>

<span class="comment">--- copy an array into another one.
</span><span class="comment">-- @within Copying
</span><span class="comment">-- @array dest a list-like table
</span><span class="comment">-- @array src a list-like table
</span><span class="comment">-- @int[opt=1] idest where to start copying values into destination
</span><span class="comment">-- @int[opt=1] isrc where to start copying values from source
</span><a id="698"></a><span class="comment">-- @int[opt=#src] nsrc number of elements to copy from source
</span><span class="keyword">function</span> tablex.move (dest,src,idest,isrc,nsrc)
    assert_arg_indexable(<span class="number">1</span>,dest)
    assert_arg_indexable(<span class="number">2</span>,src)
    <span class="keyword">return</span> _copy(dest,src,idest,isrc,nsrc,<span class="keyword">false</span>)
<span class="keyword">end</span>

<span class="keyword">function</span> tablex._normalize_slice(self,first,last)
  <span class="keyword">local</span> sz = #self
  <span class="keyword">if</span> <span class="keyword">not</span> first <span class="keyword">then</span> first=<span class="number">1</span> <span class="keyword">end</span>
  <span class="keyword">if</span> first&lt;<span class="number">0</span> <span class="keyword">then</span> first=sz+first+<span class="number">1</span> <span class="keyword">end</span>
  <span class="comment">-- make the range _inclusive_!
</span>  <span class="keyword">if</span> <span class="keyword">not</span> last <span class="keyword">then</span> last=sz <span class="keyword">end</span>
  <span class="keyword">if</span> last &lt; <span class="number">0</span> <span class="keyword">then</span> last=sz+<span class="number">1</span>+last <span class="keyword">end</span>
  <span class="keyword">return</span> first,last
<span class="keyword">end</span>

<span class="comment">--- Extract a range from a table, like  'string.sub'.
</span><span class="comment">-- If first or last are negative then they are relative to the end of the list
</span><span class="comment">-- eg. sub(t,-2) gives last 2 entries in a list, and
</span><span class="comment">-- sub(t,-4,-2) gives from -4th to -2nd
</span><span class="comment">-- @within Extraction
</span><span class="comment">-- @array t a list-like table
</span><span class="comment">-- @int first An index
</span><span class="comment">-- @int last An index
</span><a id="723"></a><span class="comment">-- @return a new List
</span><span class="keyword">function</span> tablex.sub(t,first,last)
    assert_arg_indexable(<span class="number">1</span>,t)
    first,last = tablex._normalize_slice(t,first,last)
    <span class="keyword">local</span> res={}
    <span class="keyword">for</span> i=first,last <span class="keyword">do</span> append(res,t[i]) <span class="keyword">end</span>
    <span class="keyword">return</span> setmeta(res,t,List)
<span class="keyword">end</span>

<span class="comment">--- set an array range to a value. If it's a function we use the result
</span><span class="comment">-- of applying it to the indices.
</span><span class="comment">-- @array t a list-like table
</span><span class="comment">-- @param val a value
</span><span class="comment">-- @int[opt=1] i1 start range
</span><a id="737"></a><span class="comment">-- @int[opt=#t] i2 end range
</span><span class="keyword">function</span> tablex.set (t,val,i1,i2)
    assert_arg_indexable(<span class="number">1</span>,t)
    i1,i2 = i1 <span class="keyword">or</span> <span class="number">1</span>,i2 <span class="keyword">or</span> #t
    <span class="keyword">if</span> types.is_callable(val) <span class="keyword">then</span>
        <span class="keyword">for</span> i = i1,i2 <span class="keyword">do</span>
            t[i] = val(i)
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        <span class="keyword">for</span> i = i1,i2 <span class="keyword">do</span>
            t[i] = val
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- create a new array of specified size with initial value.
</span><span class="comment">-- @int n size
</span><span class="comment">-- @param val initial value (can be <code>nil</code>, but don't expect <code>#</code> to work!)
</span><a id="755"></a><span class="comment">-- @return the table
</span><span class="keyword">function</span> tablex.new (n,val)
    <span class="keyword">local</span> res = {}
    tablex.set(res,val,<span class="number">1</span>,n)
    <span class="keyword">return</span> res
<span class="keyword">end</span>

<span class="comment">--- clear out the contents of a table.
</span><span class="comment">-- @array t a list
</span><a id="764"></a><span class="comment">-- @param istart optional start position
</span><span class="keyword">function</span> tablex.clear(t,istart)
    istart = istart <span class="keyword">or</span> <span class="number">1</span>
    <span class="keyword">for</span> i = istart,#t <span class="keyword">do</span> remove(t) <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- insert values into a table.
</span><span class="comment">-- similar to <a href="http://www.lua.org/manual/5.1/manual.html#pdf-table.insert">table.insert</a> but inserts values from given table <code>values</code>,
</span><span class="comment">-- not the object itself, into table <code>t</code> at position <code>pos</code>.
</span><span class="comment">-- @within Copying
</span><span class="comment">-- @array t the list
</span><span class="comment">-- @int[opt] position (default is at end)
</span><a id="776"></a><span class="comment">-- @array values
</span><span class="keyword">function</span> tablex.insertvalues(t, ...)
    assert_arg(<span class="number">1</span>,t,<span class="string">'table'</span>)
    <span class="keyword">local</span> pos, values
    <span class="keyword">if</span> <span class="global">select</span>(<span class="string">'#'</span>, ...) == <span class="number">1</span> <span class="keyword">then</span>
        pos,values = #t+<span class="number">1</span>, ...
    <span class="keyword">else</span>
        pos,values = ...
    <span class="keyword">end</span>
    <span class="keyword">if</span> #values &gt; <span class="number">0</span> <span class="keyword">then</span>
        <span class="keyword">for</span> i=#t,pos,-<span class="number">1</span> <span class="keyword">do</span>
            t[i+#values] = t[i]
        <span class="keyword">end</span>
        <span class="keyword">local</span> offset = <span class="number">1</span> - pos
        <span class="keyword">for</span> i=pos,pos+#values-<span class="number">1</span> <span class="keyword">do</span>
            t[i] = values[i + offset]
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> t
<span class="keyword">end</span>

<span class="comment">--- remove a range of values from a table.
</span><span class="comment">-- End of range may be negative.
</span><span class="comment">-- @array t a list-like table
</span><span class="comment">-- @int i1 start index
</span><span class="comment">-- @int i2 end index
</span><a id="802"></a><span class="comment">-- @return the table
</span><span class="keyword">function</span> tablex.removevalues (t,i1,i2)
    assert_arg(<span class="number">1</span>,t,<span class="string">'table'</span>)
    i1,i2 = tablex._normalize_slice(t,i1,i2)
    <span class="keyword">for</span> i = i1,i2 <span class="keyword">do</span>
        remove(t,i1)
    <span class="keyword">end</span>
    <span class="keyword">return</span> t
<span class="keyword">end</span>

<span class="keyword">local</span> _find
_find = <span class="keyword">function</span> (t,value,tables)
    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(t) <span class="keyword">do</span>
        <span class="keyword">if</span> v == value <span class="keyword">then</span> <span class="keyword">return</span> k <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(t) <span class="keyword">do</span>
        <span class="keyword">if</span> <span class="keyword">not</span> tables[v] <span class="keyword">and</span> <span class="global">type</span>(v) == <span class="string">'table'</span> <span class="keyword">then</span>
            tables[v] = <span class="keyword">true</span>
            <span class="keyword">local</span> res = _find(v,value,tables)
            <span class="keyword">if</span> res <span class="keyword">then</span>
                res = <span class="global">tostring</span>(res)
                <span class="keyword">if</span> <span class="global">type</span>(k) ~= <span class="string">'string'</span> <span class="keyword">then</span>
                    <span class="keyword">return</span> <span class="string">'['</span>..k..<span class="string">']'</span>..res
                <span class="keyword">else</span>
                    <span class="keyword">return</span> k..<span class="string">'.'</span>..res
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- find a value in a table by recursive search.
</span><span class="comment">-- @within Finding
</span><span class="comment">-- @tab t the table
</span><span class="comment">-- @param value the value
</span><span class="comment">-- @array[opt] exclude any tables to avoid searching
</span><span class="comment">-- @usage search(_G,math.sin,{package.path}) == 'math.sin'
</span><a id="839"></a><span class="comment">-- @return a fieldspec, e.g. 'a.b' or 'math.sin'
</span><span class="keyword">function</span> tablex.search (t,value,exclude)
    assert_arg_iterable(<span class="number">1</span>,t)
    <span class="keyword">local</span> tables = {[t]=<span class="keyword">true</span>}
    <span class="keyword">if</span> exclude <span class="keyword">then</span>
        <span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="global">pairs</span>(exclude) <span class="keyword">do</span> tables[v] = <span class="keyword">true</span> <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> _find(t,value,tables)
<span class="keyword">end</span>

<span class="comment">--- return an iterator to a table sorted by its keys
</span><span class="comment">-- @within Iterating
</span><span class="comment">-- @tab t the table
</span><span class="comment">-- @func f an optional comparison function (f(x,y) is true if x &lt; y)
</span><span class="comment">-- @usage for k,v in tablex.sort(t) do print(k,v) end
</span><a id="854"></a><span class="comment">-- @return an iterator to traverse elements sorted by the keys
</span><span class="keyword">function</span> tablex.sort(t,f)
    <span class="keyword">local</span> keys = {}
    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="global">pairs</span>(t) <span class="keyword">do</span> keys[#keys + <span class="number">1</span>] = k <span class="keyword">end</span>
    tsort(keys,f)
    <span class="keyword">local</span> i = <span class="number">0</span>
    <span class="keyword">return</span> <span class="keyword">function</span>()
        i = i + <span class="number">1</span>
        <span class="keyword">return</span> keys[i], t[keys[i]]
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- return an iterator to a table sorted by its values
</span><span class="comment">-- @within Iterating
</span><span class="comment">-- @tab t the table
</span><span class="comment">-- @func f an optional comparison function (f(x,y) is true if x &lt; y)
</span><span class="comment">-- @usage for k,v in tablex.sortv(t) do print(k,v) end
</span><a id="871"></a><span class="comment">-- @return an iterator to traverse elements sorted by the values
</span><span class="keyword">function</span> tablex.sortv(t,f)
    <span class="keyword">local</span> rev = {}
    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(t) <span class="keyword">do</span> rev[v] = k <span class="keyword">end</span>
    <span class="keyword">local</span> <span class="global">next</span> = tablex.sort(rev,f)
    <span class="keyword">return</span> <span class="keyword">function</span>()
        <span class="keyword">local</span> value,key = <span class="global">next</span>()
        <span class="keyword">return</span> key,value
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- modifies a table to be read only.
</span><span class="comment">-- This only offers weak protection. Tables can still be modified with
</span><span class="comment">-- <a href="http://www.lua.org/manual/5.1/manual.html#pdf-table.insert">table.insert</a> and <a href="http://www.lua.org/manual/5.1/manual.html#pdf-rawset">rawset</a>.
</span><span class="comment">-- @tab t the table
</span><a id="886"></a><span class="comment">-- @return the table read only.
</span><span class="keyword">function</span> tablex.readonly(t)
    <span class="keyword">local</span> mt = {
        __index=t,
        __newindex=<span class="keyword">function</span>(t, k, v) error(<span class="string">"Attempt to modify read-only table"</span>, <span class="number">2</span>) <span class="keyword">end</span>,
        __pairs=<span class="keyword">function</span>() <span class="keyword">return</span> <span class="global">pairs</span>(t) <span class="keyword">end</span>,
        __ipairs=<span class="keyword">function</span>() <span class="keyword">return</span> <span class="global">ipairs</span>(t) <span class="keyword">end</span>,
        __len=<span class="keyword">function</span>() <span class="keyword">return</span> #t <span class="keyword">end</span>,
        __metatable=<span class="keyword">false</span>
    }
    <span class="keyword">return</span> <span class="global">setmetatable</span>({}, mt)
<span class="keyword">end</span>

<span class="keyword">return</span> tablex</pre>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.3</a></i>
<i style="float:right;">Last updated 2014-11-01 18:36:39 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
