<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Penlight Documentation</title>
    <link rel="stylesheet" href="../ldoc_fixed.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Penlight</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Source</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../source/app.lua.html">app.lua</a></li>
  <li><a href="../source/array2d.lua.html">array2d.lua</a></li>
  <li><a href="../source/class.lua.html">class.lua</a></li>
  <li><a href="../source/compat.lua.html">compat.lua</a></li>
  <li><a href="../source/comprehension.lua.html">comprehension.lua</a></li>
  <li><a href="../source/config.lua.html">config.lua</a></li>
  <li><a href="../source/data.lua.html">data.lua</a></li>
  <li><a href="../source/date.lua.html">date.lua</a></li>
  <li><a href="../source/dir.lua.html">dir.lua</a></li>
  <li><a href="../source/file.lua.html">file.lua</a></li>
  <li><a href="../source/func.lua.html">func.lua</a></li>
  <li><a href="../source/import_into.lua.html">import_into.lua</a></li>
  <li><a href="../source/init.lua.html">init.lua</a></li>
  <li><a href="../source/input.lua.html">input.lua</a></li>
  <li><a href="../source/lapp.lua.html">lapp.lua</a></li>
  <li><a href="../source/lexer.lua.html">lexer.lua</a></li>
  <li><a href="../source/list.lua.html">list.lua</a></li>
  <li><strong>luabalanced.lua</strong></li>
  <li><a href="../source/map.lua.html">map.lua</a></li>
  <li><a href="../source/multimap.lua.html">multimap.lua</a></li>
  <li><a href="../source/operator.lua.html">operator.lua</a></li>
  <li><a href="../source/orderedmap.lua.html">orderedmap.lua</a></li>
  <li><a href="../source/path.lua.html">path.lua</a></li>
  <li><a href="../source/permute.lua.html">permute.lua</a></li>
  <li><a href="../source/pretty.lua.html">pretty.lua</a></li>
  <li><a href="../source/seesubst.lua.html">seesubst.lua</a></li>
  <li><a href="../source/seq.lua.html">seq.lua</a></li>
  <li><a href="../source/set.lua.html">set.lua</a></li>
  <li><a href="../source/sip.lua.html">sip.lua</a></li>
  <li><a href="../source/sipscan.lua.html">sipscan.lua</a></li>
  <li><a href="../source/strict.lua.html">strict.lua</a></li>
  <li><a href="../source/stringio.lua.html">stringio.lua</a></li>
  <li><a href="../source/stringx.lua.html">stringx.lua</a></li>
  <li><a href="../source/symbols.lua.html">symbols.lua</a></li>
  <li><a href="../source/tablex.lua.html">tablex.lua</a></li>
  <li><a href="../source/template.lua.html">template.lua</a></li>
  <li><a href="../source/test-cmp.lua.html">test-cmp.lua</a></li>
  <li><a href="../source/test-data.lua.html">test-data.lua</a></li>
  <li><a href="../source/test-listcallbacks.lua.html">test-listcallbacks.lua</a></li>
  <li><a href="../source/test-pretty.lua.html">test-pretty.lua</a></li>
  <li><a href="../source/test-symbols.lua.html">test-symbols.lua</a></li>
  <li><a href="../source/test.lua.html">test.lua</a></li>
  <li><a href="../source/testapp.lua.html">testapp.lua</a></li>
  <li><a href="../source/testclone.lua.html">testclone.lua</a></li>
  <li><a href="../source/testconfig.lua.html">testconfig.lua</a></li>
  <li><a href="../source/testglobal.lua.html">testglobal.lua</a></li>
  <li><a href="../source/testinputfields.lua.html">testinputfields.lua</a></li>
  <li><a href="../source/testinputfields2.lua.html">testinputfields2.lua</a></li>
  <li><a href="../source/testxml.lua.html">testxml.lua</a></li>
  <li><a href="../source/text.lua.html">text.lua</a></li>
  <li><a href="../source/types.lua.html">types.lua</a></li>
  <li><a href="../source/url.lua.html">url.lua</a></li>
  <li><a href="../source/utils.lua.html">utils.lua</a></li>
  <li><a href="../source/which.lua.html">which.lua</a></li>
  <li><a href="../source/xml.lua.html">xml.lua</a></li>
</ul>
<h2>Libraries</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../libraries/pl.html">pl</a></li>
  <li><a href="../libraries/pl.app.html">pl.app</a></li>
  <li><a href="../libraries/pl.array2d.html">pl.array2d</a></li>
  <li><a href="../libraries/pl.class.html">pl.class</a></li>
  <li><a href="../libraries/pl.compat.html">pl.compat</a></li>
  <li><a href="../libraries/pl.comprehension.html">pl.comprehension</a></li>
  <li><a href="../libraries/pl.config.html">pl.config</a></li>
  <li><a href="../libraries/pl.data.html">pl.data</a></li>
  <li><a href="../libraries/pl.dir.html">pl.dir</a></li>
  <li><a href="../libraries/pl.file.html">pl.file</a></li>
  <li><a href="../libraries/pl.func.html">pl.func</a></li>
  <li><a href="../libraries/pl.import_into.html">pl.import_into</a></li>
  <li><a href="../libraries/pl.input.html">pl.input</a></li>
  <li><a href="../libraries/pl.lapp.html">pl.lapp</a></li>
  <li><a href="../libraries/pl.lexer.html">pl.lexer</a></li>
  <li><a href="../libraries/pl.luabalanced.html">pl.luabalanced</a></li>
  <li><a href="../libraries/pl.operator.html">pl.operator</a></li>
  <li><a href="../libraries/pl.path.html">pl.path</a></li>
  <li><a href="../libraries/pl.permute.html">pl.permute</a></li>
  <li><a href="../libraries/pl.pretty.html">pl.pretty</a></li>
  <li><a href="../libraries/pl.seq.html">pl.seq</a></li>
  <li><a href="../libraries/pl.sip.html">pl.sip</a></li>
  <li><a href="../libraries/pl.strict.html">pl.strict</a></li>
  <li><a href="../libraries/pl.stringio.html">pl.stringio</a></li>
  <li><a href="../libraries/pl.stringx.html">pl.stringx</a></li>
  <li><a href="../libraries/pl.tablex.html">pl.tablex</a></li>
  <li><a href="../libraries/pl.template.html">pl.template</a></li>
  <li><a href="../libraries/pl.test.html">pl.test</a></li>
  <li><a href="../libraries/pl.text.html">pl.text</a></li>
  <li><a href="../libraries/pl.types.html">pl.types</a></li>
  <li><a href="../libraries/pl.url.html">pl.url</a></li>
  <li><a href="../libraries/pl.utils.html">pl.utils</a></li>
  <li><a href="../libraries/pl.xml.html">pl.xml</a></li>
</ul>
<h2>Classes</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../classes/pl.Date.html">pl.Date</a></li>
  <li><a href="../classes/pl.List.html">pl.List</a></li>
  <li><a href="../classes/pl.Map.html">pl.Map</a></li>
  <li><a href="../classes/pl.MultiMap.html">pl.MultiMap</a></li>
  <li><a href="../classes/pl.OrderedMap.html">pl.OrderedMap</a></li>
  <li><a href="../classes/pl.Set.html">pl.Set</a></li>
</ul>
<h2>Manual</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../manual/01-introduction.md.html">Introduction</a></li>
  <li><a href="../manual/02-arrays.md.html">Tables and Arrays</a></li>
  <li><a href="../manual/03-strings.md.html">Strings. Higher-level operations on strings.</a></li>
  <li><a href="../manual/04-paths.md.html">Paths and Directories</a></li>
  <li><a href="../manual/05-dates.md.html">Date and Time</a></li>
  <li><a href="../manual/06-data.md.html">Data</a></li>
  <li><a href="../manual/07-functional.md.html">Functional Programming</a></li>
  <li><a href="../manual/08-additional.md.html">Additional Libraries</a></li>
  <li><a href="../manual/09-discussion.md.html">Technical Choices</a></li>
</ul>
<h2>Examples</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../examples/seesubst.lua.html">seesubst.lua</a></li>
  <li><a href="../examples/sipscan.lua.html">sipscan.lua</a></li>
  <li><a href="../examples/symbols.lua.html">symbols.lua</a></li>
  <li><a href="../examples/test-cmp.lua.html">test-cmp.lua</a></li>
  <li><a href="../examples/test-data.lua.html">test-data.lua</a></li>
  <li><a href="../examples/test-listcallbacks.lua.html">test-listcallbacks.lua</a></li>
  <li><a href="../examples/test-pretty.lua.html">test-pretty.lua</a></li>
  <li><a href="../examples/test-symbols.lua.html">test-symbols.lua</a></li>
  <li><a href="../examples/testapp.lua.html">testapp.lua</a></li>
  <li><a href="../examples/testclone.lua.html">testclone.lua</a></li>
  <li><a href="../examples/testconfig.lua.html">testconfig.lua</a></li>
  <li><a href="../examples/testglobal.lua.html">testglobal.lua</a></li>
  <li><a href="../examples/testinputfields.lua.html">testinputfields.lua</a></li>
  <li><a href="../examples/testinputfields2.lua.html">testinputfields2.lua</a></li>
  <li><a href="../examples/testxml.lua.html">testxml.lua</a></li>
  <li><a href="../examples/which.lua.html">which.lua</a></li>
</ul>

</div>

<div id="content">

    <h2>luabalanced.lua</h2>
<pre>
<span class="comment">--- Extract delimited Lua sequences from strings.
</span><span class="comment">-- Inspired by Damian Conway's Text::Balanced in Perl. &lt;br/&gt;
</span><span class="comment">-- &lt;ul&gt;
</span><span class="comment">--   &lt;li&gt;[1] &lt;a href="http://lua-users.org/wiki/LuaBalanced"&gt;Lua Wiki Page&lt;/a&gt;&lt;/li&gt;
</span><span class="comment">--   &lt;li&gt;[2] http://search.cpan.org/dist/Text-Balanced/lib/Text/Balanced.pm&lt;/li&gt;
</span><span class="comment">-- &lt;/ul&gt; &lt;br/&gt;
</span><span class="comment">-- &lt;pre class=example&gt;
</span><span class="comment">-- local lb = require "pl.luabalanced"
</span><span class="comment">-- --Extract Lua expression starting at position 4.
</span><span class="comment">--  print(lb.match_expression("if x^2 + x &gt; 5 then print(x) end", 4))
</span><span class="comment">--  --&gt; x^2 + x &gt; 5     16
</span><span class="comment">-- --Extract Lua string starting at (default) position 1.
</span><span class="comment">-- print(lb.match_string([["test\"123" .. "more"]]))
</span><span class="comment">-- --&gt; "test\"123"     12
</span><span class="comment">-- &lt;/pre&gt;
</span><span class="comment">-- (c) 2008, David Manura, Licensed under the same terms as Lua (MIT license).
</span><span class="comment">-- @class module
</span><span class="comment">-- @name pl.luabalanced
</span>
<span class="keyword">local</span> M = {}

<span class="keyword">local</span> <span class="global">assert</span> = <span class="global">assert</span>
<span class="keyword">local</span> table_concat = <span class="global">table</span>.concat

<span class="comment">-- map opening brace &lt;-&gt; closing brace.
</span><span class="keyword">local</span> ends = { [<span class="string">'('</span>] = <span class="string">')'</span>, [<span class="string">'{'</span>] = <span class="string">'}'</span>, [<span class="string">'['</span>] = <span class="string">']'</span> }
<span class="keyword">local</span> begins = {}; <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="global">pairs</span>(ends) <span class="keyword">do</span> begins[v] = k <span class="keyword">end</span>


<span class="comment">-- Match Lua string in string &lt;s&gt; starting at position &lt;pos&gt;.
</span><span class="comment">-- Returns &lt;string&gt;, &lt;posnew&gt;, where &lt;string&gt; is the matched
</span><span class="comment">-- string (or nil on no match) and &lt;posnew&gt; is the character
</span><span class="comment">-- following the match (or &lt;pos&gt; on no match).
</span><span class="comment">-- Supports all Lua string syntax: "...", '...', [[...]], [=[...]=], etc.
</span><span class="keyword">local</span> <span class="keyword">function</span> match_string(s, pos)
  pos = pos <span class="keyword">or</span> <span class="number">1</span>
  <span class="keyword">local</span> posa = pos
  <span class="keyword">local</span> c = s:sub(pos,pos)
  <span class="keyword">if</span> c == <span class="string">'"'</span> <span class="keyword">or</span> c == <span class="string">"'"</span> <span class="keyword">then</span>
    pos = pos + <span class="number">1</span>
    <span class="keyword">while</span> <span class="number">1</span> <span class="keyword">do</span>
      pos = <span class="global">assert</span>(s:find(<span class="string">"["</span> .. c .. <span class="string">"\\]"</span>, pos), <span class="string">'syntax error'</span>)
      <span class="keyword">if</span> s:sub(pos,pos) == c <span class="keyword">then</span>
        <span class="keyword">local</span> part = s:sub(posa, pos)
        <span class="keyword">return</span> part, pos + <span class="number">1</span>
      <span class="keyword">else</span>
        pos = pos + <span class="number">2</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">else</span>
    <span class="keyword">local</span> sc = s:match(<span class="string">"^%[(=*)%["</span>, pos)
    <span class="keyword">if</span> sc <span class="keyword">then</span>
      <span class="keyword">local</span> _; _, pos = s:find(<span class="string">"%]"</span> .. sc .. <span class="string">"%]"</span>, pos)
      <span class="global">assert</span>(pos)
      <span class="keyword">local</span> part = s:sub(posa, pos)
      <span class="keyword">return</span> part, pos + <span class="number">1</span>
    <span class="keyword">else</span>
      <span class="keyword">return</span> <span class="keyword">nil</span>, pos
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>
M.match_string = match_string


<span class="comment">-- Match bracketed Lua expression, e.g. "(...)", "{...}", "[...]", "[[...]]",
</span><span class="comment">-- [=[...]=], etc.
</span><span class="comment">-- Function interface is similar to match_string.
</span><span class="keyword">local</span> <span class="keyword">function</span> match_bracketed(s, pos)
  pos = pos <span class="keyword">or</span> <span class="number">1</span>
  <span class="keyword">local</span> posa = pos
  <span class="keyword">local</span> ca = s:sub(pos,pos)
  <span class="keyword">if</span> <span class="keyword">not</span> ends[ca] <span class="keyword">then</span>
    <span class="keyword">return</span> <span class="keyword">nil</span>, pos
  <span class="keyword">end</span>
  <span class="keyword">local</span> stack = {}
  <span class="keyword">while</span> <span class="number">1</span> <span class="keyword">do</span>
    pos = s:find(<span class="string">'[%(%{%[%)%}%]\"\']'</span>, pos)
    <span class="global">assert</span>(pos, <span class="string">'syntax error: unbalanced'</span>)
    <span class="keyword">local</span> c = s:sub(pos,pos)
    <span class="keyword">if</span> c == <span class="string">'"'</span> <span class="keyword">or</span> c == <span class="string">"'"</span> <span class="keyword">then</span>
      <span class="keyword">local</span> part; part, pos = match_string(s, pos)
      <span class="global">assert</span>(part)
    <span class="keyword">elseif</span> ends[c] <span class="keyword">then</span> <span class="comment">-- open
</span>      <span class="keyword">local</span> mid, posb
      <span class="keyword">if</span> c == <span class="string">'['</span> <span class="keyword">then</span> mid, posb = s:match(<span class="string">'^%[(=*)%[()'</span>, pos) <span class="keyword">end</span>
      <span class="keyword">if</span> mid <span class="keyword">then</span>
        pos = s:match(<span class="string">'%]'</span> .. mid .. <span class="string">'%]()'</span>, posb)
        <span class="global">assert</span>(pos, <span class="string">'syntax error: long string not terminated'</span>)
        <span class="keyword">if</span> #stack == <span class="number">0</span> <span class="keyword">then</span>
          <span class="keyword">local</span> part = s:sub(posa, pos-<span class="number">1</span>)
          <span class="keyword">return</span> part, pos
        <span class="keyword">end</span>
      <span class="keyword">else</span>
        stack[#stack+<span class="number">1</span>] = c
        pos = pos + <span class="number">1</span>
      <span class="keyword">end</span>
    <span class="keyword">else</span> <span class="comment">-- close
</span>      <span class="global">assert</span>(stack[#stack] == <span class="global">assert</span>(begins[c]), <span class="string">'syntax error: unbalanced'</span>)
      stack[#stack] = <span class="keyword">nil</span>
      <span class="keyword">if</span> #stack == <span class="number">0</span> <span class="keyword">then</span>
        <span class="keyword">local</span> part = s:sub(posa, pos)
        <span class="keyword">return</span> part, pos+<span class="number">1</span>
      <span class="keyword">end</span>
      pos = pos + <span class="number">1</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>
M.match_bracketed = match_bracketed


<span class="comment">-- Match Lua comment, e.g. "--...\n", "--[[...]]", "--[=[...]=]", etc.
</span><span class="comment">-- Function interface is similar to match_string.
</span><span class="keyword">local</span> <span class="keyword">function</span> match_comment(s, pos)
  pos = pos <span class="keyword">or</span> <span class="number">1</span>
  <span class="keyword">if</span> s:sub(pos, pos+<span class="number">1</span>) ~= <span class="string">'--'</span> <span class="keyword">then</span>
    <span class="keyword">return</span> <span class="keyword">nil</span>, pos
  <span class="keyword">end</span>
  pos = pos + <span class="number">2</span>
  <span class="keyword">local</span> partt, post = match_string(s, pos)
  <span class="keyword">if</span> partt <span class="keyword">then</span>
    <span class="keyword">return</span> <span class="string">'--'</span> .. partt, post
  <span class="keyword">end</span>
  <span class="keyword">local</span> part; part, pos = s:match(<span class="string">'^([^\n]*\n?)()'</span>, pos)
  <span class="keyword">return</span> <span class="string">'--'</span> .. part, pos
<span class="keyword">end</span>


<span class="comment">-- Match Lua expression, e.g. "a + b * c[e]".
</span><span class="comment">-- Function interface is similar to match_string.
</span><span class="keyword">local</span> wordop = {[<span class="string">'and'</span>]=<span class="keyword">true</span>, [<span class="string">'or'</span>]=<span class="keyword">true</span>, [<span class="string">'not'</span>]=<span class="keyword">true</span>}
<span class="keyword">local</span> is_compare = {[<span class="string">'&gt;'</span>]=<span class="keyword">true</span>, [<span class="string">'&lt;'</span>]=<span class="keyword">true</span>, [<span class="string">'~'</span>]=<span class="keyword">true</span>}
<span class="keyword">local</span> <span class="keyword">function</span> match_expression(s, pos)
  pos = pos <span class="keyword">or</span> <span class="number">1</span>
  <span class="keyword">local</span> posa = pos
  <span class="keyword">local</span> lastident
  <span class="keyword">local</span> poscs, posce
  <span class="keyword">while</span> pos <span class="keyword">do</span>
    <span class="keyword">local</span> c = s:sub(pos,pos)
    <span class="keyword">if</span> c == <span class="string">'"'</span> <span class="keyword">or</span> c == <span class="string">"'"</span> <span class="keyword">or</span> c == <span class="string">'['</span> <span class="keyword">and</span> s:find(<span class="string">'^[=%[]'</span>, pos+<span class="number">1</span>) <span class="keyword">then</span>
      <span class="keyword">local</span> part; part, pos = match_string(s, pos)
      <span class="global">assert</span>(part, <span class="string">'syntax error'</span>)
    <span class="keyword">elseif</span> c == <span class="string">'-'</span> <span class="keyword">and</span> s:sub(pos+<span class="number">1</span>,pos+<span class="number">1</span>) == <span class="string">'-'</span> <span class="keyword">then</span>
      <span class="comment">-- note: handle adjacent comments in loop to properly support
</span>      <span class="comment">-- backtracing (poscs/posce).
</span>      poscs = pos
      <span class="keyword">while</span> s:sub(pos,pos+<span class="number">1</span>) == <span class="string">'--'</span> <span class="keyword">do</span>
        <span class="keyword">local</span> part; part, pos = match_comment(s, pos)
        <span class="global">assert</span>(part)
        pos = s:match(<span class="string">'^%s*()'</span>, pos)
        posce = pos
      <span class="keyword">end</span>
    <span class="keyword">elseif</span> c == <span class="string">'('</span> <span class="keyword">or</span> c == <span class="string">'{'</span> <span class="keyword">or</span> c == <span class="string">'['</span> <span class="keyword">then</span>
      <span class="keyword">local</span> part; part, pos = match_bracketed(s, pos)
    <span class="keyword">elseif</span> c == <span class="string">'='</span> <span class="keyword">and</span> s:sub(pos+<span class="number">1</span>,pos+<span class="number">1</span>) == <span class="string">'='</span> <span class="keyword">then</span>
      pos = pos + <span class="number">2</span>  <span class="comment">-- skip over two-char op containing '='
</span>    <span class="keyword">elseif</span> c == <span class="string">'='</span> <span class="keyword">and</span> is_compare[s:sub(pos-<span class="number">1</span>,pos-<span class="number">1</span>)] <span class="keyword">then</span>
      pos = pos + <span class="number">1</span>  <span class="comment">-- skip over two-char op containing '='
</span>    <span class="keyword">elseif</span> c:match<span class="string">'^[%)%}%];,=]'</span> <span class="keyword">then</span>
      <span class="keyword">local</span> part = s:sub(posa, pos-<span class="number">1</span>)
      <span class="keyword">return</span> part, pos
    <span class="keyword">elseif</span> c:match<span class="string">'^[%w_]'</span> <span class="keyword">then</span>
      <span class="keyword">local</span> newident,newpos = s:match(<span class="string">'^([%w_]+)()'</span>, pos)
      <span class="keyword">if</span> pos ~= posa <span class="keyword">and</span> <span class="keyword">not</span> wordop[newident] <span class="keyword">then</span> <span class="comment">-- non-first ident
</span>        <span class="keyword">local</span> pose = ((posce == pos) <span class="keyword">and</span> poscs <span class="keyword">or</span> pos) - <span class="number">1</span>
        <span class="keyword">while</span> s:match(<span class="string">'^%s'</span>, pose) <span class="keyword">do</span> pose = pose - <span class="number">1</span> <span class="keyword">end</span>
        <span class="keyword">local</span> ce = s:sub(pose,pose)
        <span class="keyword">if</span> ce:match<span class="string">'[%)%}\'\"%]]'</span> <span class="keyword">or</span>
           ce:match<span class="string">'[%w_]'</span> <span class="keyword">and</span> <span class="keyword">not</span> wordop[lastident]
        <span class="keyword">then</span>
          <span class="keyword">local</span> part = s:sub(posa, pos-<span class="number">1</span>)
          <span class="keyword">return</span> part, pos
        <span class="keyword">end</span>
      <span class="keyword">end</span>
      lastident, pos = newident, newpos
    <span class="keyword">else</span>
      pos = pos + <span class="number">1</span>
    <span class="keyword">end</span>
    pos = s:find(<span class="string">'[%(%{%[%)%}%]\"\';,=%w_%-]'</span>, pos)
  <span class="keyword">end</span>
  <span class="keyword">local</span> part = s:sub(posa, #s)
  <span class="keyword">return</span> part, #s+<span class="number">1</span>
<span class="keyword">end</span>
M.match_expression = match_expression


<span class="comment">-- Match name list (zero or more names).  E.g. "a,b,c"
</span><span class="comment">-- Function interface is similar to match_string,
</span><span class="comment">-- but returns array as match.
</span><span class="keyword">local</span> <span class="keyword">function</span> match_namelist(s, pos)
  pos = pos <span class="keyword">or</span> <span class="number">1</span>
  <span class="keyword">local</span> list = {}
  <span class="keyword">while</span> <span class="number">1</span> <span class="keyword">do</span>
    <span class="keyword">local</span> c = #list == <span class="number">0</span> <span class="keyword">and</span> <span class="string">'^'</span> <span class="keyword">or</span> <span class="string">'^%s*,%s*'</span>
    <span class="keyword">local</span> item, post = s:match(c .. <span class="string">'([%a_][%w_]*)%s*()'</span>, pos)
    <span class="keyword">if</span> item <span class="keyword">then</span> pos = post <span class="keyword">else</span> <span class="keyword">break</span> <span class="keyword">end</span>
    list[#list+<span class="number">1</span>] = item
  <span class="keyword">end</span>
  <span class="keyword">return</span> list, pos
<span class="keyword">end</span>
M.match_namelist = match_namelist


<span class="comment">-- Match expression list (zero or more expressions).  E.g. "a+b,b*c".
</span><span class="comment">-- Function interface is similar to match_string,
</span><span class="comment">-- but returns array as match.
</span><span class="keyword">local</span> <span class="keyword">function</span> match_explist(s, pos)
  pos = pos <span class="keyword">or</span> <span class="number">1</span>
  <span class="keyword">local</span> list = {}
  <span class="keyword">while</span> <span class="number">1</span> <span class="keyword">do</span>
    <span class="keyword">if</span> #list ~= <span class="number">0</span> <span class="keyword">then</span>
      <span class="keyword">local</span> post = s:match(<span class="string">'^%s*,%s*()'</span>, pos)
      <span class="keyword">if</span> post <span class="keyword">then</span> pos = post <span class="keyword">else</span> <span class="keyword">break</span> <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">local</span> item; item, pos = match_expression(s, pos)
    <span class="global">assert</span>(item, <span class="string">'syntax error'</span>)
    list[#list+<span class="number">1</span>] = item
  <span class="keyword">end</span>
  <span class="keyword">return</span> list, pos
<span class="keyword">end</span>
M.match_explist = match_explist


<span class="comment">-- Replace snippets of code in Lua code string &lt;s&gt;
</span><span class="comment">-- using replacement function f(u,sin) --&gt; sout.
</span><span class="comment">-- &lt;u&gt; is the type of snippet ('c' = comment, 's' = string,
</span><span class="comment">-- 'e' = any other code).
</span><span class="comment">-- Snippet is replaced with &lt;sout&gt; (unless &lt;sout&gt; is nil or false, in
</span><span class="comment">-- which case the original snippet is kept)
</span><span class="comment">-- This is somewhat analogous to string.gsub .
</span><span class="keyword">local</span> <span class="keyword">function</span> gsub(s, f)
  <span class="keyword">local</span> pos = <span class="number">1</span>
  <span class="keyword">local</span> posa = <span class="number">1</span>
  <span class="keyword">local</span> sret = <span class="string">''</span>
  <span class="keyword">while</span> <span class="number">1</span> <span class="keyword">do</span>
    pos = s:find(<span class="string">'[%-\'\"%[]'</span>, pos)
    <span class="keyword">if</span> <span class="keyword">not</span> pos <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span>
    <span class="keyword">if</span> s:match(<span class="string">'^%-%-'</span>, pos) <span class="keyword">then</span>
      <span class="keyword">local</span> exp = s:sub(posa, pos-<span class="number">1</span>)
      <span class="keyword">if</span> #exp &gt; <span class="number">0</span> <span class="keyword">then</span> sret = sret .. (f(<span class="string">'e'</span>, exp) <span class="keyword">or</span> exp) <span class="keyword">end</span>
      <span class="keyword">local</span> comment; comment, pos = match_comment(s, pos)
      sret = sret .. (f(<span class="string">'c'</span>, <span class="global">assert</span>(comment)) <span class="keyword">or</span> comment)
      posa = pos
    <span class="keyword">else</span>
      <span class="keyword">local</span> posb = s:find(<span class="string">'^[\'\"%[]'</span>, pos)
      <span class="keyword">local</span> str
      <span class="keyword">if</span> posb <span class="keyword">then</span> str, pos = match_string(s, posb) <span class="keyword">end</span>
      <span class="keyword">if</span> str <span class="keyword">then</span>
        <span class="keyword">local</span> exp = s:sub(posa, posb-<span class="number">1</span>)
        <span class="keyword">if</span> #exp &gt; <span class="number">0</span> <span class="keyword">then</span> sret = sret .. (f(<span class="string">'e'</span>, exp) <span class="keyword">or</span> exp) <span class="keyword">end</span>
        sret = sret .. (f(<span class="string">'s'</span>, str) <span class="keyword">or</span> str)
        posa = pos
      <span class="keyword">else</span>
        pos = pos + <span class="number">1</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="keyword">local</span> exp = s:sub(posa)
  <span class="keyword">if</span> #exp &gt; <span class="number">0</span> <span class="keyword">then</span> sret = sret .. (f(<span class="string">'e'</span>, exp) <span class="keyword">or</span> exp) <span class="keyword">end</span>
  <span class="keyword">return</span> sret
<span class="keyword">end</span>
M.gsub = gsub


<span class="keyword">return</span> M</pre>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.3</a></i>
<i style="float:right;">Last updated 2014-11-01 18:36:39 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
