<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Penlight Documentation</title>
    <link rel="stylesheet" href="../ldoc_fixed.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Penlight</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Source</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../source/app.lua.html">app.lua</a></li>
  <li><a href="../source/array2d.lua.html">array2d.lua</a></li>
  <li><a href="../source/class.lua.html">class.lua</a></li>
  <li><a href="../source/compat.lua.html">compat.lua</a></li>
  <li><a href="../source/comprehension.lua.html">comprehension.lua</a></li>
  <li><a href="../source/config.lua.html">config.lua</a></li>
  <li><a href="../source/data.lua.html">data.lua</a></li>
  <li><a href="../source/date.lua.html">date.lua</a></li>
  <li><a href="../source/dir.lua.html">dir.lua</a></li>
  <li><a href="../source/file.lua.html">file.lua</a></li>
  <li><a href="../source/func.lua.html">func.lua</a></li>
  <li><a href="../source/import_into.lua.html">import_into.lua</a></li>
  <li><a href="../source/init.lua.html">init.lua</a></li>
  <li><a href="../source/input.lua.html">input.lua</a></li>
  <li><a href="../source/lapp.lua.html">lapp.lua</a></li>
  <li><a href="../source/lexer.lua.html">lexer.lua</a></li>
  <li><a href="../source/list.lua.html">list.lua</a></li>
  <li><a href="../source/luabalanced.lua.html">luabalanced.lua</a></li>
  <li><a href="../source/map.lua.html">map.lua</a></li>
  <li><a href="../source/multimap.lua.html">multimap.lua</a></li>
  <li><a href="../source/operator.lua.html">operator.lua</a></li>
  <li><a href="../source/orderedmap.lua.html">orderedmap.lua</a></li>
  <li><a href="../source/path.lua.html">path.lua</a></li>
  <li><a href="../source/permute.lua.html">permute.lua</a></li>
  <li><a href="../source/pretty.lua.html">pretty.lua</a></li>
  <li><a href="../source/seesubst.lua.html">seesubst.lua</a></li>
  <li><a href="../source/seq.lua.html">seq.lua</a></li>
  <li><a href="../source/set.lua.html">set.lua</a></li>
  <li><a href="../source/sip.lua.html">sip.lua</a></li>
  <li><a href="../source/sipscan.lua.html">sipscan.lua</a></li>
  <li><a href="../source/strict.lua.html">strict.lua</a></li>
  <li><a href="../source/stringio.lua.html">stringio.lua</a></li>
  <li><strong>stringx.lua</strong></li>
  <li><a href="../source/symbols.lua.html">symbols.lua</a></li>
  <li><a href="../source/tablex.lua.html">tablex.lua</a></li>
  <li><a href="../source/template.lua.html">template.lua</a></li>
  <li><a href="../source/test-cmp.lua.html">test-cmp.lua</a></li>
  <li><a href="../source/test-data.lua.html">test-data.lua</a></li>
  <li><a href="../source/test-listcallbacks.lua.html">test-listcallbacks.lua</a></li>
  <li><a href="../source/test-pretty.lua.html">test-pretty.lua</a></li>
  <li><a href="../source/test-symbols.lua.html">test-symbols.lua</a></li>
  <li><a href="../source/test.lua.html">test.lua</a></li>
  <li><a href="../source/testapp.lua.html">testapp.lua</a></li>
  <li><a href="../source/testclone.lua.html">testclone.lua</a></li>
  <li><a href="../source/testconfig.lua.html">testconfig.lua</a></li>
  <li><a href="../source/testglobal.lua.html">testglobal.lua</a></li>
  <li><a href="../source/testinputfields.lua.html">testinputfields.lua</a></li>
  <li><a href="../source/testinputfields2.lua.html">testinputfields2.lua</a></li>
  <li><a href="../source/testxml.lua.html">testxml.lua</a></li>
  <li><a href="../source/text.lua.html">text.lua</a></li>
  <li><a href="../source/types.lua.html">types.lua</a></li>
  <li><a href="../source/url.lua.html">url.lua</a></li>
  <li><a href="../source/utils.lua.html">utils.lua</a></li>
  <li><a href="../source/which.lua.html">which.lua</a></li>
  <li><a href="../source/xml.lua.html">xml.lua</a></li>
</ul>
<h2>Libraries</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../libraries/pl.html">pl</a></li>
  <li><a href="../libraries/pl.app.html">pl.app</a></li>
  <li><a href="../libraries/pl.array2d.html">pl.array2d</a></li>
  <li><a href="../libraries/pl.class.html">pl.class</a></li>
  <li><a href="../libraries/pl.compat.html">pl.compat</a></li>
  <li><a href="../libraries/pl.comprehension.html">pl.comprehension</a></li>
  <li><a href="../libraries/pl.config.html">pl.config</a></li>
  <li><a href="../libraries/pl.data.html">pl.data</a></li>
  <li><a href="../libraries/pl.dir.html">pl.dir</a></li>
  <li><a href="../libraries/pl.file.html">pl.file</a></li>
  <li><a href="../libraries/pl.func.html">pl.func</a></li>
  <li><a href="../libraries/pl.import_into.html">pl.import_into</a></li>
  <li><a href="../libraries/pl.input.html">pl.input</a></li>
  <li><a href="../libraries/pl.lapp.html">pl.lapp</a></li>
  <li><a href="../libraries/pl.lexer.html">pl.lexer</a></li>
  <li><a href="../libraries/pl.luabalanced.html">pl.luabalanced</a></li>
  <li><a href="../libraries/pl.operator.html">pl.operator</a></li>
  <li><a href="../libraries/pl.path.html">pl.path</a></li>
  <li><a href="../libraries/pl.permute.html">pl.permute</a></li>
  <li><a href="../libraries/pl.pretty.html">pl.pretty</a></li>
  <li><a href="../libraries/pl.seq.html">pl.seq</a></li>
  <li><a href="../libraries/pl.sip.html">pl.sip</a></li>
  <li><a href="../libraries/pl.strict.html">pl.strict</a></li>
  <li><a href="../libraries/pl.stringio.html">pl.stringio</a></li>
  <li><a href="../libraries/pl.stringx.html">pl.stringx</a></li>
  <li><a href="../libraries/pl.tablex.html">pl.tablex</a></li>
  <li><a href="../libraries/pl.template.html">pl.template</a></li>
  <li><a href="../libraries/pl.test.html">pl.test</a></li>
  <li><a href="../libraries/pl.text.html">pl.text</a></li>
  <li><a href="../libraries/pl.types.html">pl.types</a></li>
  <li><a href="../libraries/pl.url.html">pl.url</a></li>
  <li><a href="../libraries/pl.utils.html">pl.utils</a></li>
  <li><a href="../libraries/pl.xml.html">pl.xml</a></li>
</ul>
<h2>Classes</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../classes/pl.Date.html">pl.Date</a></li>
  <li><a href="../classes/pl.List.html">pl.List</a></li>
  <li><a href="../classes/pl.Map.html">pl.Map</a></li>
  <li><a href="../classes/pl.MultiMap.html">pl.MultiMap</a></li>
  <li><a href="../classes/pl.OrderedMap.html">pl.OrderedMap</a></li>
  <li><a href="../classes/pl.Set.html">pl.Set</a></li>
</ul>
<h2>Manual</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../manual/01-introduction.md.html">Introduction</a></li>
  <li><a href="../manual/02-arrays.md.html">Tables and Arrays</a></li>
  <li><a href="../manual/03-strings.md.html">Strings. Higher-level operations on strings.</a></li>
  <li><a href="../manual/04-paths.md.html">Paths and Directories</a></li>
  <li><a href="../manual/05-dates.md.html">Date and Time</a></li>
  <li><a href="../manual/06-data.md.html">Data</a></li>
  <li><a href="../manual/07-functional.md.html">Functional Programming</a></li>
  <li><a href="../manual/08-additional.md.html">Additional Libraries</a></li>
  <li><a href="../manual/09-discussion.md.html">Technical Choices</a></li>
</ul>
<h2>Examples</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../examples/seesubst.lua.html">seesubst.lua</a></li>
  <li><a href="../examples/sipscan.lua.html">sipscan.lua</a></li>
  <li><a href="../examples/symbols.lua.html">symbols.lua</a></li>
  <li><a href="../examples/test-cmp.lua.html">test-cmp.lua</a></li>
  <li><a href="../examples/test-data.lua.html">test-data.lua</a></li>
  <li><a href="../examples/test-listcallbacks.lua.html">test-listcallbacks.lua</a></li>
  <li><a href="../examples/test-pretty.lua.html">test-pretty.lua</a></li>
  <li><a href="../examples/test-symbols.lua.html">test-symbols.lua</a></li>
  <li><a href="../examples/testapp.lua.html">testapp.lua</a></li>
  <li><a href="../examples/testclone.lua.html">testclone.lua</a></li>
  <li><a href="../examples/testconfig.lua.html">testconfig.lua</a></li>
  <li><a href="../examples/testglobal.lua.html">testglobal.lua</a></li>
  <li><a href="../examples/testinputfields.lua.html">testinputfields.lua</a></li>
  <li><a href="../examples/testinputfields2.lua.html">testinputfields2.lua</a></li>
  <li><a href="../examples/testxml.lua.html">testxml.lua</a></li>
  <li><a href="../examples/which.lua.html">which.lua</a></li>
</ul>

</div>

<div id="content">

    <h2>stringx.lua</h2>
<pre>
<span class="comment">--- Python-style extended string library.
</span><span class="comment">--
</span><span class="comment">-- see 3.6.1 of the Python reference.
</span><span class="comment">-- If you want to make these available as string methods, then say
</span><span class="comment">-- <code>stringx.import()</code> to bring them into the standard <a href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a> table.
</span><span class="comment">--
</span><span class="comment">-- See <a href="../manual/03-strings.md.html#">the Guide</a>
</span><span class="comment">--
</span><span class="comment">-- Dependencies: <a href="../libraries/pl.utils.html#">pl.utils</a>
</span><span class="comment">-- @module pl.stringx
</span><span class="keyword">local</span> utils = <span class="global">require</span> <span class="string">'pl.utils'</span>
<span class="keyword">local</span> <span class="global">string</span> = <span class="global">string</span>
<span class="keyword">local</span> find = <span class="global">string</span>.find
<span class="keyword">local</span> <span class="global">type</span>,<span class="global">setmetatable</span>,<span class="global">getmetatable</span>,<span class="global">ipairs</span>,<span class="global">unpack</span> = <span class="global">type</span>,<span class="global">setmetatable</span>,<span class="global">getmetatable</span>,<span class="global">ipairs</span>,utils.<span class="global">unpack</span>
<span class="keyword">local</span> error,<span class="global">tostring</span> = error,<span class="global">tostring</span>
<span class="keyword">local</span> gsub = <span class="global">string</span>.gsub
<span class="keyword">local</span> rep = <span class="global">string</span>.rep
<span class="keyword">local</span> sub = <span class="global">string</span>.sub
<span class="keyword">local</span> concat = <span class="global">table</span>.concat
<span class="keyword">local</span> escape = utils.escape
<span class="keyword">local</span> ceil = <span class="global">math</span>.ceil
<span class="keyword">local</span> _G = _G
<span class="keyword">local</span> assert_arg,usplit,list_MT = utils.assert_arg,utils.split,utils.stdmt.List
<span class="keyword">local</span> lstrip

<span class="keyword">local</span> <span class="keyword">function</span> assert_string (n,s)
    assert_arg(n,s,<span class="string">'string'</span>)
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> non_empty(s)
    <span class="keyword">return</span> #s &gt; <span class="number">0</span>
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> assert_nonempty_string(n,s)
    assert_arg(n,s,<span class="string">'string'</span>,non_empty,<span class="string">'must be a non-empty string'</span>)
<span class="keyword">end</span>

<span class="keyword">local</span> stringx = {}

<span class="comment">------------------
</span><span class="comment">-- String Predicates
</span><span class="comment">-- @section predicates
</span>
<span class="comment">--- does s only contain alphabetic characters?.
</span><a id="46"></a><span class="comment">-- @string s a string
</span><span class="keyword">function</span> stringx.isalpha(s)
    assert_string(<span class="number">1</span>,s)
    <span class="keyword">return</span> find(s,<span class="string">'^%a+$'</span>) == <span class="number">1</span>
<span class="keyword">end</span>

<span class="comment">--- does s only contain digits?.
</span><a id="53"></a><span class="comment">-- @string s a string
</span><span class="keyword">function</span> stringx.isdigit(s)
    assert_string(<span class="number">1</span>,s)
    <span class="keyword">return</span> find(s,<span class="string">'^%d+$'</span>) == <span class="number">1</span>
<span class="keyword">end</span>

<span class="comment">--- does s only contain alphanumeric characters?.
</span><a id="60"></a><span class="comment">-- @string s a string
</span><span class="keyword">function</span> stringx.isalnum(s)
    assert_string(<span class="number">1</span>,s)
    <span class="keyword">return</span> find(s,<span class="string">'^%w+$'</span>) == <span class="number">1</span>
<span class="keyword">end</span>

<span class="comment">--- does s only contain spaces?.
</span><a id="67"></a><span class="comment">-- @string s a string
</span><span class="keyword">function</span> stringx.isspace(s)
    assert_string(<span class="number">1</span>,s)
    <span class="keyword">return</span> find(s,<span class="string">'^%s+$'</span>) == <span class="number">1</span>
<span class="keyword">end</span>

<span class="comment">--- does s only contain lower case characters?.
</span><a id="74"></a><span class="comment">-- @string s a string
</span><span class="keyword">function</span> stringx.islower(s)
    assert_string(<span class="number">1</span>,s)
    <span class="keyword">return</span> find(s,<span class="string">'^[%l%s]+$'</span>) == <span class="number">1</span>
<span class="keyword">end</span>

<span class="comment">--- does s only contain upper case characters?.
</span><a id="81"></a><span class="comment">-- @string s a string
</span><span class="keyword">function</span> stringx.isupper(s)
    assert_string(<span class="number">1</span>,s)
    <span class="keyword">return</span> find(s,<span class="string">'^[%u%s]+$'</span>) == <span class="number">1</span>
<span class="keyword">end</span>

<span class="comment">--- does string start with the substring?.
</span><span class="comment">-- @string self the string
</span><a id="89"></a><span class="comment">-- @string s2 a string
</span><span class="keyword">function</span> stringx.startswith(self,s2)
    assert_string(<span class="number">1</span>,self)
    assert_string(<span class="number">2</span>,s2)
    <span class="keyword">return</span> find(self,s2,<span class="number">1</span>,<span class="keyword">true</span>) == <span class="number">1</span>
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> _find_all(s,sub,first,last)
    <span class="keyword">if</span> sub == <span class="string">''</span> <span class="keyword">then</span> <span class="keyword">return</span> #s+<span class="number">1</span>,#s <span class="keyword">end</span>
    <span class="keyword">local</span> i1,i2 = find(s,sub,first,<span class="keyword">true</span>)
    <span class="keyword">local</span> res
    <span class="keyword">local</span> k = <span class="number">0</span>
    <span class="keyword">while</span> i1 <span class="keyword">do</span>
        <span class="keyword">if</span> last <span class="keyword">and</span> i1 &gt; last <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span>
        res = i1
        k = k + <span class="number">1</span>
        i1,i2 = find(s,sub,i2+<span class="number">1</span>,<span class="keyword">true</span>)
    <span class="keyword">end</span>
    <span class="keyword">return</span> res,k
<span class="keyword">end</span>

<span class="comment">--- does string end with the given substring?.
</span><span class="comment">-- @string s a string
</span><a id="112"></a><span class="comment">-- @param send a substring or a table of suffixes
</span><span class="keyword">function</span> stringx.endswith(s,send)
    assert_string(<span class="number">1</span>,s)
    <span class="keyword">if</span> <span class="global">type</span>(send) == <span class="string">'string'</span> <span class="keyword">then</span>
        <span class="keyword">return</span> #s &gt;= #send <span class="keyword">and</span> s:find(send, #s-#send+<span class="number">1</span>, <span class="keyword">true</span>) <span class="keyword">and</span> <span class="keyword">true</span> <span class="keyword">or</span> <span class="keyword">false</span>
    <span class="keyword">elseif</span> <span class="global">type</span>(send) == <span class="string">'table'</span> <span class="keyword">then</span>
        <span class="keyword">local</span> endswith = stringx.endswith
        <span class="keyword">for</span> _,suffix <span class="keyword">in</span> <span class="global">ipairs</span>(send) <span class="keyword">do</span>
            <span class="keyword">if</span> endswith(s,suffix) <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">return</span> <span class="keyword">false</span>
    <span class="keyword">else</span>
        error(<span class="string">'argument #2: either a substring or a table of suffixes expected'</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- Strings and Lists
</span><span class="comment">-- @section lists
</span>
<span class="comment">--- concatenate the strings using this string as a delimiter.
</span><span class="comment">-- @string self the string
</span><span class="comment">-- @param seq a table of strings or numbers
</span><a id="134"></a><span class="comment">-- @usage (' '):join {1,2,3} == '1 2 3'
</span><span class="keyword">function</span> stringx.join (self,seq)
    assert_string(<span class="number">1</span>,self)
    <span class="keyword">return</span> concat(seq,self)
<span class="keyword">end</span>

<span class="comment">--- break string into a list of lines
</span><span class="comment">-- @string self the string
</span><a id="142"></a><span class="comment">-- @param keepends (currently not used)
</span><span class="keyword">function</span> stringx.splitlines (self,keepends)
    assert_string(<span class="number">1</span>,self)
    <span class="keyword">local</span> res = usplit(self,<span class="string">'[\r\n]'</span>)
    <span class="comment">-- we are currently hacking around a problem with utils.split (see stringx.split)
</span>    <span class="keyword">if</span> #res == <span class="number">0</span> <span class="keyword">then</span> res = {<span class="string">''</span>} <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="global">setmetatable</span>(res,list_MT)
<span class="keyword">end</span>

<span class="comment">--- split a string into a list of strings using a delimiter.
</span><span class="comment">-- @function split
</span><span class="comment">-- @string self the string
</span><span class="comment">-- @string[opt] re a delimiter (defaults to whitespace)
</span><span class="comment">-- @int n maximum number of results
</span><span class="comment">-- @usage #(('one two'):split()) == 2
</span><span class="comment">-- @usage ('one,two,three'):split(',') == List{'one','two','three'}
</span><a id="158"></a><span class="comment">-- @usage ('one,two,three'):split(',',2) == List{'one','two,three'}
</span><span class="keyword">function</span> stringx.split(self,re,n)
    <span class="keyword">local</span> s = self
    <span class="keyword">local</span> plain = <span class="keyword">true</span>
    <span class="keyword">if</span> <span class="keyword">not</span> re <span class="keyword">then</span> <span class="comment">-- default spaces
</span>        s = lstrip(s)
        plain = <span class="keyword">false</span>
    <span class="keyword">end</span>
    <span class="keyword">local</span> res = usplit(s,re,plain,n)
    <span class="keyword">if</span> re <span class="keyword">and</span> re ~= <span class="string">''</span> <span class="keyword">and</span> find(s,re,-#re,<span class="keyword">true</span>) <span class="keyword">then</span>
        res[#res+<span class="number">1</span>] = <span class="string">""</span>
    <span class="keyword">end</span>
	<span class="keyword">return</span> <span class="global">setmetatable</span>(res,list_MT)
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> tab_expand (self,n)
    <span class="keyword">return</span> (gsub(self,<span class="string">'([^\t]*)\t'</span>, <span class="keyword">function</span>(s)
            <span class="keyword">return</span> s..(<span class="string">' '</span>):rep(n - #s % n)
    <span class="keyword">end</span>))
<span class="keyword">end</span>

<span class="comment">--- replace all tabs in s with n spaces. If not specified, n defaults to 8.
</span><span class="comment">-- with 0.9.5 this now correctly expands to the next tab stop (if you really
</span><span class="comment">-- want to just replace tabs, use :gsub('\t','  ') etc)
</span><span class="comment">-- @string self the string
</span><a id="183"></a><span class="comment">-- @int n number of spaces to expand each tab, (default 8)
</span><span class="keyword">function</span> stringx.expandtabs(self,n)
    assert_string(<span class="number">1</span>,self)
    n = n <span class="keyword">or</span> <span class="number">8</span>
    <span class="keyword">if</span> <span class="keyword">not</span> self:find <span class="string">'\n'</span> <span class="keyword">then</span> <span class="keyword">return</span> tab_expand(self,n) <span class="keyword">end</span>
    <span class="keyword">local</span> res,i = {},<span class="number">1</span>
    <span class="keyword">for</span> line <span class="keyword">in</span> stringx.lines(self) <span class="keyword">do</span>
        res[i] = tab_expand(line,n)
        i = i + <span class="number">1</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="global">table</span>.concat(res,<span class="string">'\n'</span>)
<span class="keyword">end</span>

<span class="comment">--- Finding and Replacing
</span><span class="comment">-- @section find
</span>
<span class="comment">--- find index of first instance of sub in s from the left.
</span><span class="comment">-- @string self the string
</span><span class="comment">-- @string sub substring
</span><a id="202"></a><span class="comment">-- @int  i1 start index
</span><span class="keyword">function</span> stringx.lfind(self,sub,i1)
    assert_string(<span class="number">1</span>,self)
    assert_string(<span class="number">2</span>,sub)
    <span class="keyword">local</span> idx = find(self,sub,i1,<span class="keyword">true</span>)
    <span class="keyword">if</span> idx <span class="keyword">then</span> <span class="keyword">return</span> idx <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">nil</span> <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- find index of first instance of sub in s from the right.
</span><span class="comment">-- @string self the string
</span><span class="comment">-- @string sub substring
</span><span class="comment">-- @int first first index
</span><a id="214"></a><span class="comment">-- @int last last index
</span><span class="keyword">function</span> stringx.rfind(self,sub,first,last)
    assert_string(<span class="number">1</span>,self)
    assert_string(<span class="number">2</span>,sub)
    <span class="keyword">local</span> idx = _find_all(self,sub,first,last)
    <span class="keyword">if</span> idx <span class="keyword">then</span> <span class="keyword">return</span> idx <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">nil</span> <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- replace up to n instances of old by new in the string s.
</span><span class="comment">-- if n is not present, replace all instances.
</span><span class="comment">-- @string s the string
</span><span class="comment">-- @string old the target substring
</span><span class="comment">-- @string new the substitution
</span><span class="comment">-- @int[opt] n optional maximum number of substitutions
</span><span class="comment">-- @return result string
</span><a id="229"></a><span class="comment">-- @return the number of substitutions
</span><span class="keyword">function</span> stringx.replace(s,old,new,n)
    assert_string(<span class="number">1</span>,s)
    assert_string(<span class="number">1</span>,old)
    <span class="keyword">return</span> (gsub(s,escape(old),new:gsub(<span class="string">'%%'</span>,<span class="string">'%%%%'</span>),n))
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> copy(self)
    <span class="keyword">return</span> self..<span class="string">''</span>
<span class="keyword">end</span>

<span class="comment">--- count all instances of substring in string.
</span><span class="comment">-- @string self the string
</span><a id="242"></a><span class="comment">-- @string sub substring
</span><span class="keyword">function</span> stringx.count(self,sub)
    assert_string(<span class="number">1</span>,self)
    <span class="keyword">local</span> i,k = _find_all(self,sub,<span class="number">1</span>)
    <span class="keyword">return</span> k
<span class="keyword">end</span>

<span class="comment">--- Stripping and Justifying
</span><span class="comment">-- @section strip
</span>
<span class="keyword">local</span> <span class="keyword">function</span> _just(s,w,ch,left,right)
    <span class="keyword">local</span> n = #s
    <span class="keyword">if</span> w &gt; n <span class="keyword">then</span>
        <span class="keyword">if</span> <span class="keyword">not</span> ch <span class="keyword">then</span> ch = <span class="string">' '</span> <span class="keyword">end</span>
        <span class="keyword">local</span> f1,f2
        <span class="keyword">if</span> left <span class="keyword">and</span> right <span class="keyword">then</span>
            <span class="keyword">local</span> ln = ceil((w-n)/<span class="number">2</span>)
            <span class="keyword">local</span> rn = w - n - ln
            f1 = rep(ch,ln)
            f2 = rep(ch,rn)
        <span class="keyword">elseif</span> right <span class="keyword">then</span>
            f1 = rep(ch,w-n)
            f2 = <span class="string">''</span>
        <span class="keyword">else</span>
            f2 = rep(ch,w-n)
            f1 = <span class="string">''</span>
        <span class="keyword">end</span>
        <span class="keyword">return</span> f1..s..f2
    <span class="keyword">else</span>
        <span class="keyword">return</span> copy(s)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- left-justify s with width w.
</span><span class="comment">-- @string self the string
</span><span class="comment">-- @int w width of justification
</span><a id="278"></a><span class="comment">-- @string[opt=''] ch padding character
</span><span class="keyword">function</span> stringx.ljust(self,w,ch)
    assert_string(<span class="number">1</span>,self)
    assert_arg(<span class="number">2</span>,w,<span class="string">'number'</span>)
    <span class="keyword">return</span> _just(self,w,ch,<span class="keyword">true</span>,<span class="keyword">false</span>)
<span class="keyword">end</span>

<span class="comment">--- right-justify s with width w.
</span><span class="comment">-- @string s the string
</span><span class="comment">-- @int w width of justification
</span><a id="288"></a><span class="comment">-- @string[opt=''] ch padding character
</span><span class="keyword">function</span> stringx.rjust(s,w,ch)
    assert_string(<span class="number">1</span>,s)
    assert_arg(<span class="number">2</span>,w,<span class="string">'number'</span>)
    <span class="keyword">return</span> _just(s,w,ch,<span class="keyword">false</span>,<span class="keyword">true</span>)
<span class="keyword">end</span>

<span class="comment">--- center-justify s with width w.
</span><span class="comment">-- @string s the string
</span><span class="comment">-- @int w width of justification
</span><a id="298"></a><span class="comment">-- @string[opt=''] ch padding character
</span><span class="keyword">function</span> stringx.center(s,w,ch)
    assert_string(<span class="number">1</span>,s)
    assert_arg(<span class="number">2</span>,w,<span class="string">'number'</span>)
    <span class="keyword">return</span> _just(s,w,ch,<span class="keyword">true</span>,<span class="keyword">true</span>)
<span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> _strip(s,left,right,chrs)
    <span class="keyword">if</span> <span class="keyword">not</span> chrs <span class="keyword">then</span>
        chrs = <span class="string">'%s'</span>
    <span class="keyword">else</span>
        chrs = <span class="string">'['</span>..escape(chrs)..<span class="string">']'</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> left <span class="keyword">then</span>
        <span class="keyword">local</span> i1,i2 = find(s,<span class="string">'^'</span>..chrs..<span class="string">'*'</span>)
        <span class="keyword">if</span> i2 &gt;= i1 <span class="keyword">then</span>
            s = sub(s,i2+<span class="number">1</span>)
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> right <span class="keyword">then</span>
        <span class="keyword">local</span> i1,i2 = find(s,chrs..<span class="string">'*$'</span>)
        <span class="keyword">if</span> i2 &gt;= i1 <span class="keyword">then</span>
            s = sub(s,<span class="number">1</span>,i1-<span class="number">1</span>)
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> s
<span class="keyword">end</span>

<span class="comment">--- trim any whitespace on the left of s.
</span><span class="comment">-- @string self the string
</span><span class="comment">-- @string[opt='%x'] chrs default any whitespace character,
</span><a id="329"></a><span class="comment">--  but can be a string of characters to be trimmed
</span><span class="keyword">function</span> stringx.lstrip(self,chrs)
    assert_string(<span class="number">1</span>,self)
    <span class="keyword">return</span> _strip(self,<span class="keyword">true</span>,<span class="keyword">false</span>,chrs)
<span class="keyword">end</span>
lstrip = stringx.lstrip

<span class="comment">--- trim any whitespace on the right of s.
</span><span class="comment">-- @string s the string
</span><span class="comment">-- @string[opt='%x'] chrs default any whitespace character,
</span><a id="339"></a><span class="comment">--  but can be a string of characters to be trimmed
</span><span class="keyword">function</span> stringx.rstrip(s,chrs)
    assert_string(<span class="number">1</span>,s)
    <span class="keyword">return</span> _strip(s,<span class="keyword">false</span>,<span class="keyword">true</span>,chrs)
<span class="keyword">end</span>

<span class="comment">--- trim any whitespace on both left and right of s.
</span><span class="comment">-- @string self the string
</span><span class="comment">-- @string[opt='%x'] chrs default any whitespace character,
</span><a id="348"></a><span class="comment">--  but can be a string of characters to be trimmed
</span><span class="keyword">function</span> stringx.strip(self,chrs)
    assert_string(<span class="number">1</span>,self)
    <span class="keyword">return</span> _strip(self,<span class="keyword">true</span>,<span class="keyword">true</span>,chrs)
<span class="keyword">end</span>

<span class="comment">--- Partioning Strings
</span><span class="comment">-- @section partioning
</span>
<span class="comment">--- split a string using a pattern. Note that at least one value will be returned!
</span><span class="comment">-- @string self the string
</span><span class="comment">-- @string[opt='%s'] re a Lua string pattern (defaults to whitespace)
</span><span class="comment">-- @return the parts of the string
</span><a id="361"></a><span class="comment">-- @usage  a,b = line:splitv('=')
</span><span class="keyword">function</span> stringx.splitv (self,re)
    assert_string(<span class="number">1</span>,self)
    <span class="keyword">return</span> utils.splitv(self,re)
<span class="keyword">end</span>

<span class="comment">-- The partition functions split a string  using a delimiter into three parts:
</span><span class="comment">-- the part before, the delimiter itself, and the part afterwards
</span><span class="keyword">local</span> <span class="keyword">function</span> _partition(p,delim,fn)
    <span class="keyword">local</span> i1,i2 = fn(p,delim)
    <span class="keyword">if</span> <span class="keyword">not</span> i1 <span class="keyword">or</span> i1 == -<span class="number">1</span> <span class="keyword">then</span>
        <span class="keyword">return</span> p,<span class="string">''</span>,<span class="string">''</span>
    <span class="keyword">else</span>
        <span class="keyword">if</span> <span class="keyword">not</span> i2 <span class="keyword">then</span> i2 = i1 <span class="keyword">end</span>
        <span class="keyword">return</span> sub(p,<span class="number">1</span>,i1-<span class="number">1</span>),sub(p,i1,i2),sub(p,i2+<span class="number">1</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- partition the string using first occurance of a delimiter
</span><span class="comment">-- @string self the string
</span><span class="comment">-- @string ch delimiter
</span><span class="comment">-- @return part before ch
</span><span class="comment">-- @return ch
</span><a id="384"></a><span class="comment">-- @return part after ch
</span><span class="keyword">function</span> stringx.partition(self,ch)
    assert_string(<span class="number">1</span>,self)
    assert_nonempty_string(<span class="number">2</span>,ch)
    <span class="keyword">return</span> _partition(self,ch,stringx.lfind)
<span class="keyword">end</span>

<span class="comment">--- partition the string p using last occurance of a delimiter
</span><span class="comment">-- @string self the string
</span><span class="comment">-- @string ch delimiter
</span><span class="comment">-- @return part before ch
</span><span class="comment">-- @return ch
</span><a id="396"></a><span class="comment">-- @return part after ch
</span><span class="keyword">function</span> stringx.rpartition(self,ch)
    assert_string(<span class="number">1</span>,self)
    assert_nonempty_string(<span class="number">2</span>,ch)
    <span class="keyword">return</span> _partition(self,ch,stringx.rfind)
<span class="keyword">end</span>

<span class="comment">--- return the 'character' at the index.
</span><span class="comment">-- @string self the string
</span><span class="comment">-- @int idx an index (can be negative)
</span><a id="406"></a><span class="comment">-- @return a substring of length 1 if successful, empty string otherwise.
</span><span class="keyword">function</span> stringx.at(self,idx)
    assert_string(<span class="number">1</span>,self)
    assert_arg(<span class="number">2</span>,idx,<span class="string">'number'</span>)
    <span class="keyword">return</span> sub(self,idx,idx)
<span class="keyword">end</span>

<span class="comment">--- Miscelaneous
</span><span class="comment">-- @section misc
</span>
<span class="comment">--- return an interator over all lines in a string
</span><span class="comment">-- @string self the string
</span><a id="418"></a><span class="comment">-- @return an iterator
</span><span class="keyword">function</span> stringx.lines (self)
    assert_string(<span class="number">1</span>,self)
    <span class="keyword">local</span> s = self
    <span class="keyword">if</span> <span class="keyword">not</span> s:find <span class="string">'\n$'</span> <span class="keyword">then</span> s = s..<span class="string">'\n'</span> <span class="keyword">end</span>
    <span class="keyword">return</span> s:gmatch(<span class="string">'([^\n]*)\n'</span>)
<span class="keyword">end</span>

<span class="comment">--- iniital word letters uppercase ('title case').
</span><span class="comment">-- Here 'words' mean chunks of non-space characters.
</span><span class="comment">-- @string self the string
</span><a id="429"></a><span class="comment">-- @return a string with each word's first letter uppercase
</span><span class="keyword">function</span> stringx.title(self)
    <span class="keyword">return</span> (self:gsub(<span class="string">'(%S)(%S*)'</span>,<span class="keyword">function</span>(f,r)
        <span class="keyword">return</span> f:upper()..r:lower()
    <span class="keyword">end</span>))
<span class="keyword">end</span>

stringx.capitalize = stringx.title

<span class="keyword">local</span> elipsis = <span class="string">'...'</span>
<span class="keyword">local</span> n_elipsis = #elipsis

<span class="comment">--- return a shorted version of a string.
</span><span class="comment">-- @string self the string
</span><span class="comment">-- @int sz the maxinum size allowed
</span><a id="444"></a><span class="comment">-- @bool tail true if we want to show the end of the string (head otherwise)
</span><span class="keyword">function</span> stringx.shorten(self,sz,tail)
    <span class="keyword">if</span> #self &gt; sz <span class="keyword">then</span>
        <span class="keyword">if</span> sz &lt; n_elipsis <span class="keyword">then</span> <span class="keyword">return</span> elipsis:sub(<span class="number">1</span>,sz) <span class="keyword">end</span>
        <span class="keyword">if</span> tail <span class="keyword">then</span>
            <span class="keyword">local</span> i = #self - sz + <span class="number">1</span> + n_elipsis
            <span class="keyword">return</span> elipsis .. self:sub(i)
        <span class="keyword">else</span>
            <span class="keyword">return</span> self:sub(<span class="number">1</span>,sz-n_elipsis) .. elipsis
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="keyword">function</span> stringx.import(dont_overload)
    utils.import(stringx,<span class="global">string</span>)
<span class="keyword">end</span>

<span class="keyword">return</span> stringx</pre>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.3</a></i>
<i style="float:right;">Last updated 2014-11-01 18:36:39 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
