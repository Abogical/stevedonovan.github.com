<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Penlight Documentation</title>
    <link rel="stylesheet" href="../ldoc_fixed.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Penlight</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Source</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../source/app.lua.html">app.lua</a></li>
  <li><a href="../source/array2d.lua.html">array2d.lua</a></li>
  <li><a href="../source/class.lua.html">class.lua</a></li>
  <li><a href="../source/compat.lua.html">compat.lua</a></li>
  <li><strong>comprehension.lua</strong></li>
  <li><a href="../source/config.lua.html">config.lua</a></li>
  <li><a href="../source/data.lua.html">data.lua</a></li>
  <li><a href="../source/date.lua.html">date.lua</a></li>
  <li><a href="../source/dir.lua.html">dir.lua</a></li>
  <li><a href="../source/file.lua.html">file.lua</a></li>
  <li><a href="../source/func.lua.html">func.lua</a></li>
  <li><a href="../source/import_into.lua.html">import_into.lua</a></li>
  <li><a href="../source/init.lua.html">init.lua</a></li>
  <li><a href="../source/input.lua.html">input.lua</a></li>
  <li><a href="../source/lapp.lua.html">lapp.lua</a></li>
  <li><a href="../source/lexer.lua.html">lexer.lua</a></li>
  <li><a href="../source/list.lua.html">list.lua</a></li>
  <li><a href="../source/luabalanced.lua.html">luabalanced.lua</a></li>
  <li><a href="../source/map.lua.html">map.lua</a></li>
  <li><a href="../source/multimap.lua.html">multimap.lua</a></li>
  <li><a href="../source/operator.lua.html">operator.lua</a></li>
  <li><a href="../source/orderedmap.lua.html">orderedmap.lua</a></li>
  <li><a href="../source/path.lua.html">path.lua</a></li>
  <li><a href="../source/permute.lua.html">permute.lua</a></li>
  <li><a href="../source/pretty.lua.html">pretty.lua</a></li>
  <li><a href="../source/seesubst.lua.html">seesubst.lua</a></li>
  <li><a href="../source/seq.lua.html">seq.lua</a></li>
  <li><a href="../source/set.lua.html">set.lua</a></li>
  <li><a href="../source/sip.lua.html">sip.lua</a></li>
  <li><a href="../source/sipscan.lua.html">sipscan.lua</a></li>
  <li><a href="../source/strict.lua.html">strict.lua</a></li>
  <li><a href="../source/stringio.lua.html">stringio.lua</a></li>
  <li><a href="../source/stringx.lua.html">stringx.lua</a></li>
  <li><a href="../source/symbols.lua.html">symbols.lua</a></li>
  <li><a href="../source/tablex.lua.html">tablex.lua</a></li>
  <li><a href="../source/template.lua.html">template.lua</a></li>
  <li><a href="../source/test-cmp.lua.html">test-cmp.lua</a></li>
  <li><a href="../source/test-data.lua.html">test-data.lua</a></li>
  <li><a href="../source/test-listcallbacks.lua.html">test-listcallbacks.lua</a></li>
  <li><a href="../source/test-pretty.lua.html">test-pretty.lua</a></li>
  <li><a href="../source/test-symbols.lua.html">test-symbols.lua</a></li>
  <li><a href="../source/test.lua.html">test.lua</a></li>
  <li><a href="../source/testapp.lua.html">testapp.lua</a></li>
  <li><a href="../source/testclone.lua.html">testclone.lua</a></li>
  <li><a href="../source/testconfig.lua.html">testconfig.lua</a></li>
  <li><a href="../source/testglobal.lua.html">testglobal.lua</a></li>
  <li><a href="../source/testinputfields.lua.html">testinputfields.lua</a></li>
  <li><a href="../source/testinputfields2.lua.html">testinputfields2.lua</a></li>
  <li><a href="../source/testxml.lua.html">testxml.lua</a></li>
  <li><a href="../source/text.lua.html">text.lua</a></li>
  <li><a href="../source/types.lua.html">types.lua</a></li>
  <li><a href="../source/url.lua.html">url.lua</a></li>
  <li><a href="../source/utils.lua.html">utils.lua</a></li>
  <li><a href="../source/which.lua.html">which.lua</a></li>
  <li><a href="../source/xml.lua.html">xml.lua</a></li>
</ul>
<h2>Libraries</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../libraries/pl.html">pl</a></li>
  <li><a href="../libraries/pl.app.html">pl.app</a></li>
  <li><a href="../libraries/pl.array2d.html">pl.array2d</a></li>
  <li><a href="../libraries/pl.class.html">pl.class</a></li>
  <li><a href="../libraries/pl.compat.html">pl.compat</a></li>
  <li><a href="../libraries/pl.comprehension.html">pl.comprehension</a></li>
  <li><a href="../libraries/pl.config.html">pl.config</a></li>
  <li><a href="../libraries/pl.data.html">pl.data</a></li>
  <li><a href="../libraries/pl.dir.html">pl.dir</a></li>
  <li><a href="../libraries/pl.file.html">pl.file</a></li>
  <li><a href="../libraries/pl.func.html">pl.func</a></li>
  <li><a href="../libraries/pl.import_into.html">pl.import_into</a></li>
  <li><a href="../libraries/pl.input.html">pl.input</a></li>
  <li><a href="../libraries/pl.lapp.html">pl.lapp</a></li>
  <li><a href="../libraries/pl.lexer.html">pl.lexer</a></li>
  <li><a href="../libraries/pl.luabalanced.html">pl.luabalanced</a></li>
  <li><a href="../libraries/pl.operator.html">pl.operator</a></li>
  <li><a href="../libraries/pl.path.html">pl.path</a></li>
  <li><a href="../libraries/pl.permute.html">pl.permute</a></li>
  <li><a href="../libraries/pl.pretty.html">pl.pretty</a></li>
  <li><a href="../libraries/pl.seq.html">pl.seq</a></li>
  <li><a href="../libraries/pl.sip.html">pl.sip</a></li>
  <li><a href="../libraries/pl.strict.html">pl.strict</a></li>
  <li><a href="../libraries/pl.stringio.html">pl.stringio</a></li>
  <li><a href="../libraries/pl.stringx.html">pl.stringx</a></li>
  <li><a href="../libraries/pl.tablex.html">pl.tablex</a></li>
  <li><a href="../libraries/pl.template.html">pl.template</a></li>
  <li><a href="../libraries/pl.test.html">pl.test</a></li>
  <li><a href="../libraries/pl.text.html">pl.text</a></li>
  <li><a href="../libraries/pl.types.html">pl.types</a></li>
  <li><a href="../libraries/pl.url.html">pl.url</a></li>
  <li><a href="../libraries/pl.utils.html">pl.utils</a></li>
  <li><a href="../libraries/pl.xml.html">pl.xml</a></li>
</ul>
<h2>Classes</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../classes/pl.Date.html">pl.Date</a></li>
  <li><a href="../classes/pl.List.html">pl.List</a></li>
  <li><a href="../classes/pl.Map.html">pl.Map</a></li>
  <li><a href="../classes/pl.MultiMap.html">pl.MultiMap</a></li>
  <li><a href="../classes/pl.OrderedMap.html">pl.OrderedMap</a></li>
  <li><a href="../classes/pl.Set.html">pl.Set</a></li>
</ul>
<h2>Manual</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../manual/01-introduction.md.html">Introduction</a></li>
  <li><a href="../manual/02-arrays.md.html">Tables and Arrays</a></li>
  <li><a href="../manual/03-strings.md.html">Strings. Higher-level operations on strings.</a></li>
  <li><a href="../manual/04-paths.md.html">Paths and Directories</a></li>
  <li><a href="../manual/05-dates.md.html">Date and Time</a></li>
  <li><a href="../manual/06-data.md.html">Data</a></li>
  <li><a href="../manual/07-functional.md.html">Functional Programming</a></li>
  <li><a href="../manual/08-additional.md.html">Additional Libraries</a></li>
  <li><a href="../manual/09-discussion.md.html">Technical Choices</a></li>
</ul>
<h2>Examples</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../examples/seesubst.lua.html">seesubst.lua</a></li>
  <li><a href="../examples/sipscan.lua.html">sipscan.lua</a></li>
  <li><a href="../examples/symbols.lua.html">symbols.lua</a></li>
  <li><a href="../examples/test-cmp.lua.html">test-cmp.lua</a></li>
  <li><a href="../examples/test-data.lua.html">test-data.lua</a></li>
  <li><a href="../examples/test-listcallbacks.lua.html">test-listcallbacks.lua</a></li>
  <li><a href="../examples/test-pretty.lua.html">test-pretty.lua</a></li>
  <li><a href="../examples/test-symbols.lua.html">test-symbols.lua</a></li>
  <li><a href="../examples/testapp.lua.html">testapp.lua</a></li>
  <li><a href="../examples/testclone.lua.html">testclone.lua</a></li>
  <li><a href="../examples/testconfig.lua.html">testconfig.lua</a></li>
  <li><a href="../examples/testglobal.lua.html">testglobal.lua</a></li>
  <li><a href="../examples/testinputfields.lua.html">testinputfields.lua</a></li>
  <li><a href="../examples/testinputfields2.lua.html">testinputfields2.lua</a></li>
  <li><a href="../examples/testxml.lua.html">testxml.lua</a></li>
  <li><a href="../examples/which.lua.html">which.lua</a></li>
</ul>

</div>

<div id="content">

    <h2>comprehension.lua</h2>
<pre>
<span class="comment">--- List comprehensions implemented in Lua.
</span><span class="comment">--
</span><span class="comment">-- See the [wiki page](http://lua-users.org/wiki/ListComprehensions)
</span><span class="comment">--
</span><span class="comment">--    local C= require 'pl.comprehension' . new()
</span><span class="comment">--
</span><span class="comment">--    C ('x for x=1,10') ()
</span><span class="comment">--    ==&gt; {1,2,3,4,5,6,7,8,9,10}
</span><span class="comment">--    C 'x^2 for x=1,4' ()
</span><span class="comment">--    ==&gt; {1,4,9,16}
</span><span class="comment">--    C '{x,x^2} for x=1,4' ()
</span><span class="comment">--    ==&gt; {{1,1},{2,4},{3,9},{4,16}}
</span><span class="comment">--    C '2*x for x' {1,2,3}
</span><span class="comment">--    ==&gt; {2,4,6}
</span><span class="comment">--    dbl = C '2*x for x'
</span><span class="comment">--    dbl {10,20,30}
</span><span class="comment">--    ==&gt; {20,40,60}
</span><span class="comment">--    C 'x for x if x % 2 == 0' {1,2,3,4,5}
</span><span class="comment">--    ==&gt; {2,4}
</span><span class="comment">--    C '{x,y} for x = 1,2 for y = 1,2' ()
</span><span class="comment">--    ==&gt; {{1,1},{1,2},{2,1},{2,2}}
</span><span class="comment">--    C '{x,y} for x for y' ({1,2},{10,20})
</span><span class="comment">--    ==&gt; {{1,10},{1,20},{2,10},{2,20}}
</span><span class="comment">--    assert(C 'sum(x^2 for x)' {2,3,4} == 2^2+3^2+4^2)
</span><span class="comment">--
</span><span class="comment">-- (c) 2008 David Manura. Licensed under the same terms as Lua (MIT license).
</span><span class="comment">--
</span><span class="comment">-- Dependencies: <a href="../libraries/pl.utils.html#">pl.utils</a>, <a href="../libraries/pl.luabalanced.html#">pl.luabalanced</a>
</span><span class="comment">--
</span><span class="comment">-- See <a href="../manual/07-functional.md.html#List_Comprehensions">the Guide</a>
</span><span class="comment">-- @module pl.comprehension
</span>
<span class="keyword">local</span> utils = <span class="global">require</span> <span class="string">'pl.utils'</span>

<span class="keyword">local</span> status,lb = <span class="global">pcall</span>(<span class="global">require</span>, <span class="string">"pl.luabalanced"</span>)
<span class="keyword">if</span> <span class="keyword">not</span> status <span class="keyword">then</span>
    lb = <span class="global">require</span> <span class="string">'luabalanced'</span>
<span class="keyword">end</span>

<span class="keyword">local</span> math_max = <span class="global">math</span>.max
<span class="keyword">local</span> table_concat = <span class="global">table</span>.concat

<span class="comment">-- fold operations
</span><span class="comment">-- http://en.wikipedia.org/wiki/Fold_(higher-order_function)
</span><span class="keyword">local</span> ops = {
  list = {init=<span class="string">' {} '</span>, accum=<span class="string">' __result[#__result+1] = (%s) '</span>},
  <span class="global">table</span> = {init=<span class="string">' {} '</span>, accum=<span class="string">' local __k, __v = %s __result[__k] = __v '</span>},
  sum = {init=<span class="string">' 0 '</span>, accum=<span class="string">' __result = __result + (%s) '</span>},
  min = {init=<span class="string">' nil '</span>, accum=<span class="string">' local __tmp = %s '</span> ..
                             <span class="string">' if __result then if __tmp &lt; __result then '</span> ..
                             <span class="string">'__result = __tmp end else __result = __tmp end '</span>},
  max = {init=<span class="string">' nil '</span>, accum=<span class="string">' local __tmp = %s '</span> ..
                             <span class="string">' if __result then if __tmp &gt; __result then '</span> ..
                             <span class="string">'__result = __tmp end else __result = __tmp end '</span>},
}


<span class="comment">-- Parses comprehension string expr.
</span><span class="comment">-- Returns output expression list &lt;out&gt; string, array of for types
</span><span class="comment">-- ('=', 'in' or nil) &lt;fortypes&gt;, array of input variable name
</span><span class="comment">-- strings &lt;invarlists&gt;, array of input variable value strings
</span><span class="comment">-- &lt;invallists&gt;, array of predicate expression strings &lt;preds&gt;,
</span><span class="comment">-- operation name string &lt;opname&gt;, and number of placeholder
</span><span class="comment">-- parameters &lt;max_param&gt;.
</span><span class="comment">--
</span><span class="comment">-- The is equivalent to the mathematical set-builder notation:
</span><span class="comment">--
</span><span class="comment">--   &lt;opname&gt; { &lt;out&gt; | &lt;invarlist&gt; in &lt;invallist&gt; , &lt;preds&gt; }
</span><span class="comment">--
</span><span class="comment">-- @usage   "x^2 for x"                 -- array values
</span><span class="comment">-- @usage  "x^2 for x=1,10,2"          -- numeric for
</span><span class="comment">-- @usage  "k^v for k,v in pairs(_1)"  -- iterator for
</span><span class="comment">-- @usage  "(x+y)^2 for x for y if x &gt; y"  -- nested
</span><span class="comment">--
</span><span class="keyword">local</span> <span class="keyword">function</span> parse_comprehension(expr)
  <span class="keyword">local</span> t = {}
  <span class="keyword">local</span> pos = <span class="number">1</span>

  <span class="comment">-- extract opname (if exists)
</span>  <span class="keyword">local</span> opname
  <span class="keyword">local</span> tok, post = expr:match(<span class="string">'^%s*([%a_][%w_]*)%s*%(()'</span>, pos)
  <span class="keyword">local</span> pose = #expr + <span class="number">1</span>
  <span class="keyword">if</span> tok <span class="keyword">then</span>
    <span class="keyword">local</span> tok2, posb = lb.match_bracketed(expr, post-<span class="number">1</span>)
    <span class="global">assert</span>(tok2, <span class="string">'syntax error'</span>)
    <span class="keyword">if</span> expr:match(<span class="string">'^%s*$'</span>, posb) <span class="keyword">then</span>
      opname = tok
      pose = posb - <span class="number">1</span>
      pos = post
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  opname = opname <span class="keyword">or</span> <span class="string">"list"</span>

  <span class="comment">-- extract out expression list
</span>  <span class="keyword">local</span> out; out, pos = lb.match_explist(expr, pos)
  <span class="global">assert</span>(out, <span class="string">"syntax error: missing expression list"</span>)
  out = table_concat(out, <span class="string">', '</span>)

  <span class="comment">-- extract "for" clauses
</span>  <span class="keyword">local</span> fortypes = {}
  <span class="keyword">local</span> invarlists = {}
  <span class="keyword">local</span> invallists = {}
  <span class="keyword">while</span> <span class="number">1</span> <span class="keyword">do</span>
    <span class="keyword">local</span> post = expr:match(<span class="string">'^%s*for%s+()'</span>, pos)
    <span class="keyword">if</span> <span class="keyword">not</span> post <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span>
    pos = post

    <span class="comment">-- extract input vars
</span>    <span class="keyword">local</span> iv; iv, pos = lb.match_namelist(expr, pos)
    <span class="global">assert</span>(#iv &gt; <span class="number">0</span>, <span class="string">'syntax error: zero variables'</span>)
    <span class="keyword">for</span> _,ident <span class="keyword">in</span> <span class="global">ipairs</span>(iv) <span class="keyword">do</span>
      <span class="global">assert</span>(<span class="keyword">not</span> ident:match<span class="string">'^__'</span>,
             <span class="string">"identifier "</span> .. ident .. <span class="string">" may not contain __ prefix"</span>)
    <span class="keyword">end</span>
    invarlists[#invarlists+<span class="number">1</span>] = iv

    <span class="comment">-- extract '=' or 'in' (optional)
</span>    <span class="keyword">local</span> fortype, post = expr:match(<span class="string">'^(=)%s*()'</span>, pos)
    <span class="keyword">if</span> <span class="keyword">not</span> fortype <span class="keyword">then</span> fortype, post = expr:match(<span class="string">'^(in)%s+()'</span>, pos) <span class="keyword">end</span>
    <span class="keyword">if</span> fortype <span class="keyword">then</span>
      pos = post
      <span class="comment">-- extract input value range
</span>      <span class="keyword">local</span> il; il, pos = lb.match_explist(expr, pos)
      <span class="global">assert</span>(#il &gt; <span class="number">0</span>, <span class="string">'syntax error: zero expressions'</span>)
      <span class="global">assert</span>(fortype ~= <span class="string">'='</span> <span class="keyword">or</span> #il == <span class="number">2</span> <span class="keyword">or</span> #il == <span class="number">3</span>,
             <span class="string">'syntax error: numeric for requires 2 or three expressions'</span>)
      fortypes[#invarlists] = fortype
      invallists[#invarlists] = il
    <span class="keyword">else</span>
      fortypes[#invarlists] = <span class="keyword">false</span>
      invallists[#invarlists] = <span class="keyword">false</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="global">assert</span>(#invarlists &gt; <span class="number">0</span>, <span class="string">'syntax error: missing "for" clause'</span>)

  <span class="comment">-- extract "if" clauses
</span>  <span class="keyword">local</span> preds = {}
  <span class="keyword">while</span> <span class="number">1</span> <span class="keyword">do</span>
    <span class="keyword">local</span> post = expr:match(<span class="string">'^%s*if%s+()'</span>, pos)
    <span class="keyword">if</span> <span class="keyword">not</span> post <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span>
    pos = post
    <span class="keyword">local</span> pred; pred, pos = lb.match_expression(expr, pos)
    <span class="global">assert</span>(pred, <span class="string">'syntax error: predicated expression not found'</span>)
    preds[#preds+<span class="number">1</span>] = pred
  <span class="keyword">end</span>

  <span class="comment">-- extract number of parameter variables (name matching "_%d+")
</span>  <span class="keyword">local</span> stmp = <span class="string">''</span>; lb.gsub(expr, <span class="keyword">function</span>(u, sin)  <span class="comment">-- strip comments/strings
</span>    <span class="keyword">if</span> u == <span class="string">'e'</span> <span class="keyword">then</span> stmp = stmp .. <span class="string">' '</span> .. sin .. <span class="string">' '</span> <span class="keyword">end</span>
  <span class="keyword">end</span>)
  <span class="keyword">local</span> max_param = <span class="number">0</span>; stmp:gsub(<span class="string">'[%a_][%w_]*'</span>, <span class="keyword">function</span>(s)
    <span class="keyword">local</span> s = s:match(<span class="string">'^_(%d+)$'</span>)
    <span class="keyword">if</span> s <span class="keyword">then</span> max_param = math_max(max_param, <span class="global">tonumber</span>(s)) <span class="keyword">end</span>
  <span class="keyword">end</span>)

  <span class="keyword">if</span> pos ~= pose <span class="keyword">then</span>
    <span class="global">assert</span>(<span class="keyword">false</span>, <span class="string">"syntax error: unrecognized "</span> .. expr:sub(pos))
  <span class="keyword">end</span>

  <span class="comment">--DEBUG:
</span>  <span class="comment">--print('----\n', string.format("%q", expr), string.format("%q", out), opname)
</span>  <span class="comment">--for k,v in ipairs(invarlists) do print(k,v, invallists[k]) end
</span>  <span class="comment">--for k,v in ipairs(preds) do print(k,v) end
</span>
  <span class="keyword">return</span> out, fortypes, invarlists, invallists, preds, opname, max_param
<span class="keyword">end</span>


<span class="comment">-- Create Lua code string representing comprehension.
</span><span class="comment">-- Arguments are in the form returned by parse_comprehension.
</span><span class="keyword">local</span> <span class="keyword">function</span> code_comprehension(
    out, fortypes, invarlists, invallists, preds, opname, max_param
)
  <span class="keyword">local</span> op = <span class="global">assert</span>(ops[opname])
  <span class="keyword">local</span> code = op.accum:gsub(<span class="string">'%%s'</span>,  out)

  <span class="keyword">for</span> i=#preds,<span class="number">1</span>,-<span class="number">1</span> <span class="keyword">do</span> <span class="keyword">local</span> pred = preds[i]
    code = <span class="string">' if '</span> .. pred .. <span class="string">' then '</span> .. code .. <span class="string">' end '</span>
  <span class="keyword">end</span>
  <span class="keyword">for</span> i=#invarlists,<span class="number">1</span>,-<span class="number">1</span> <span class="keyword">do</span>
    <span class="keyword">if</span> <span class="keyword">not</span> fortypes[i] <span class="keyword">then</span>
      <span class="keyword">local</span> arrayname = <span class="string">'__in'</span> .. i
      <span class="keyword">local</span> idx = <span class="string">'__idx'</span> .. i
      code =
        <span class="string">' for '</span> .. idx .. <span class="string">' = 1, #'</span> .. arrayname .. <span class="string">' do '</span> ..
        <span class="string">' local '</span> .. invarlists[i][<span class="number">1</span>] .. <span class="string">' = '</span> .. arrayname .. <span class="string">'['</span>..idx..<span class="string">'] '</span> ..
        code .. <span class="string">' end '</span>
    <span class="keyword">else</span>
      code =
        <span class="string">' for '</span> ..
        table_concat(invarlists[i], <span class="string">', '</span>) ..
        <span class="string">' '</span> .. fortypes[i] .. <span class="string">' '</span> ..
        table_concat(invallists[i], <span class="string">', '</span>) ..
        <span class="string">' do '</span> .. code .. <span class="string">' end '</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  code = <span class="string">' local __result = ( '</span> .. op.init .. <span class="string">' ) '</span> .. code
  <span class="keyword">return</span> code
<span class="keyword">end</span>


<span class="comment">-- Convert code string represented by code_comprehension
</span><span class="comment">-- into Lua function.  Also must pass ninputs = #invarlists,
</span><span class="comment">-- max_param, and invallists (from parse_comprehension).
</span><span class="comment">-- Uses environment env.
</span><span class="keyword">local</span> <span class="keyword">function</span> wrap_comprehension(code, ninputs, max_param, invallists, env)
  <span class="global">assert</span>(ninputs &gt; <span class="number">0</span>)
  <span class="keyword">local</span> ts = {}
  <span class="keyword">for</span> i=<span class="number">1</span>,max_param <span class="keyword">do</span>
    ts[#ts+<span class="number">1</span>] = <span class="string">'_'</span> .. i
  <span class="keyword">end</span>
  <span class="keyword">for</span> i=<span class="number">1</span>,ninputs <span class="keyword">do</span>
    <span class="keyword">if</span> <span class="keyword">not</span> invallists[i] <span class="keyword">then</span>
      <span class="keyword">local</span> name = <span class="string">'__in'</span> .. i
      ts[#ts+<span class="number">1</span>] = name
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="keyword">if</span> #ts &gt; <span class="number">0</span> <span class="keyword">then</span>
    code = <span class="string">' local '</span> .. table_concat(ts, <span class="string">', '</span>) .. <span class="string">' = ... '</span> .. code
  <span class="keyword">end</span>
  code = code .. <span class="string">' return __result '</span>
  <span class="comment">--print('DEBUG:', code)
</span>  <span class="keyword">local</span> f, err = utils.<span class="global">load</span>(code,<span class="string">'tmp'</span>,<span class="string">'t'</span>,env)
  <span class="keyword">if</span> <span class="keyword">not</span> f <span class="keyword">then</span> <span class="global">assert</span>(<span class="keyword">false</span>, err .. <span class="string">' with generated code '</span> .. code) <span class="keyword">end</span>
  <span class="keyword">return</span> f
<span class="keyword">end</span>


<span class="comment">-- Build Lua function from comprehension string.
</span><span class="comment">-- Uses environment env.
</span><span class="keyword">local</span> <span class="keyword">function</span> build_comprehension(expr, env)
  <span class="keyword">local</span> out, fortypes, invarlists, invallists, preds, opname, max_param
    = parse_comprehension(expr)
  <span class="keyword">local</span> code = code_comprehension(
    out, fortypes, invarlists, invallists, preds, opname, max_param)
  <span class="keyword">local</span> f = wrap_comprehension(code, #invarlists, max_param, invallists, env)
  <span class="keyword">return</span> f
<span class="keyword">end</span>


<span class="comment">-- Creates new comprehension cache.
</span><span class="comment">-- Any list comprehension function created are set to the environment
</span><span class="comment">-- env (defaults to caller of new).
</span><span class="keyword">local</span> <span class="keyword">function</span> new(env)
  <span class="comment">-- Note: using a single global comprehension cache would have had
</span>  <span class="comment">-- security implications (e.g. retrieving cached functions created
</span>  <span class="comment">-- in other environments).
</span>  <span class="comment">-- The cache lookup function could have instead been written to retrieve
</span>  <span class="comment">-- the caller's environment, lookup up the cache private to that
</span>  <span class="comment">-- environment, and then looked up the function in that cache.
</span>  <span class="comment">-- That would avoid the need for this &lt;new&gt; call to
</span>  <span class="comment">-- explicitly manage caches; however, that might also have an undue
</span>  <span class="comment">-- performance penalty.
</span>
  <span class="keyword">if</span> <span class="keyword">not</span> env <span class="keyword">then</span>
    env = utils.<span class="global">getfenv</span>(<span class="number">2</span>)
  <span class="keyword">end</span>

  <span class="keyword">local</span> mt = {}
  <span class="keyword">local</span> cache = <span class="global">setmetatable</span>({}, mt)

  <span class="comment">-- Index operator builds, caches, and returns Lua function
</span>  <span class="comment">-- corresponding to comprehension expression string.
</span>  <span class="comment">--
</span>  <span class="comment">-- Example: f = comprehension['x^2 for x']
</span>  <span class="comment">--
</span>  <span class="keyword">function</span> mt:__index(expr)
    <span class="keyword">local</span> f = build_comprehension(expr, env)
    self[expr] = f  <span class="comment">-- cache
</span>    <span class="keyword">return</span> f
  <span class="keyword">end</span>

  <span class="comment">-- Convenience syntax.
</span>  <span class="comment">-- Allows comprehension 'x^2 for x' instead of comprehension['x^2 for x'].
</span>  mt.__call = mt.__index

  cache.new = new

  <span class="keyword">return</span> cache
<span class="keyword">end</span>


<span class="keyword">local</span> comprehension = {}
comprehension.new = new

<span class="keyword">return</span> comprehension</pre>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.3</a></i>
<i style="float:right;">Last updated 2014-11-01 18:36:39 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
