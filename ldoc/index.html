<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<title>LDoc - A Lua Documentation Tool</title>
	<link rel="stylesheet" type="text/css" href="default.css" />
</head>
<body>
<h1  id="T1">LDoc - A Lua Documentation Tool</h1>

<ul>
    <li><a href="#T2">LDoc as an improved LuaDoc</a></li>
    <li><a href="#T3">LDoc is Extensible</a></li>
    <li><a href="#T4">Inferring more from Code</a></li>
    <li><a href="#T5">Supporting Extension modules written in C</a></li>
    <li><a href="#T6">Basic Usage</a></li>
    <li><a href="#T7">@see References</a></li>
    <li><a href="#T8">Processing Single Modules</a></li>
    <li><a href="#T9">Sections</a></li>
    <li><a href="#T10">Dumping and getting Help about a Module</a></li>
    <li><a href="#T11">Generating HTML</a></li>
</ul>



<h2  id="T2">LDoc as an improved LuaDoc</h2>

<p>Generally, LuaDoc style documentation will be accepted.</p>

<p>Only 'doc comments' are parsed; these can be started with at least 3 hyphens, or by a empty comment line with at least 3 hypens:</p>

<pre><code>-----------------
-- This will also do.
</code></pre>

<p>LDoc only does 'module' documentation, so the idea of 'files' is redundant. (If you want to document a script, there is a project-level type 'script' for that.)  By default it will process any file ending in <code>.lua</code> or <code>.luadoc</code>.</p>

<p>A stricter requirement is that any such file <em>must</em> start with a 'doc comment'.</p>

<p>You may use block comments, like so:</p>

<pre><code>--[[--
A simple function.
@param a first parm
@param b second parm
]]

function simple(a,b)
</code></pre>

<p>This is useful for the initial module comment, which has the job of explaining the overall use of a module.</p>

<h2  id="T3">LDoc is Extensible</h2>

<p>LDoc tries to be faithful to LuaDoc, but provides some extensions.</p>

<p>'@function zero<em>fun' is short for the common sequence '@class function \ @name zero</em>fun'. In general, any type ('function','table',etc) can be used as a tag:</p>

<pre><code>--- zero function. Two new ldoc features here; item types
-- can be used directly as tags, and aliases for tags
-- can be defined in config.ld.
-- @function zero_fun
-- @p k1 first
-- @p k2 second
</code></pre>

<p>Here an alias for 'param' has been defined. If a file <code>config.ld</code> is found in the source, then it will be loaded as Lua data. For example, the configuration for the above module provides a title and defines an alias for 'param':</p>

<pre><code>title = "testmod docs"
project = "testmod"
alias("p","param")
</code></pre>

<p>Extra tag types can be defined:</p>

<pre><code>new_type("macro","Macros")
</code></pre>

<p>And then used as any other tag:</p>

<pre><code>-----
-- A useful macro. This is an example of a custom 'kind'.
-- @macro first_macro
-- @see second_function
</code></pre>

<p>This will also create a new module section called 'Macros'.</p>

<h2  id="T4">Inferring more from Code</h2>

<p>The qualified name of a function will be inferred from any <code>function</code> keyword following the doc comment. LDoc goes further with code analysis, however.</p>

<p>Instead of:</p>

<pre><code>--- first table.
-- @table one
-- @field A alpha
-- @field B beta
M.one = {
    A = 1,
    B = 2;
}
</code></pre>

<p>you can write:</p>

<pre><code>--- first table
-- @table one
M.one = {
    A = 1, -- alpha
    B = 2; -- beta
}
</code></pre>

<p>Simularly, function parameter comments can be directly used:</p>

<pre><code>------------
-- third function. Can also provide parameter comments inline,
-- provided they follow this pattern.
function mod1.third_function(
    alpha, -- correction A
    beta, -- correction B
    gamma -- factor C
    )
    ...
end
</code></pre>

<h2  id="T5">Supporting Extension modules written in C</h2>

<p>LDoc can process C/C++ files:</p>

<pre><code>/***
Create a table with given array and hash slots.
@function createtable
@param narr initial array slots, default 0
@param nrec initial hash slots, default 0
@return the new table
*/
static int l_createtable (lua_State *L) {
....
</code></pre>

<p>Both <code>/**</code> and <code>///</code> are recognized as starting a comment block. Otherwise, the tags are processed in exactly the same way. It is necessary to specify that this is a function with a given name, since this cannot be reliably be inferred from code.</p>

<p>An unknown extension can be associated with a language using a call like <code>add_language_extension('lc','c')</code> in <code>config.ld</code>. (Currently the language can only be 'c' or 'lua'.)</p>

<p>See 'tests/examples/mylib.c' for the full example.</p>

<h2  id="T6">Basic Usage</h2>

<p>The command-line options are:</p>

<pre><code>ldoc, a documentation generator for Lua, vs 0.2 Beta
  -d,--dir (default docs) output directory
  -o,--output  (default 'index') output name
  -v,--verbose          verbose
  -q,--quiet            suppress output
  -m,--module           module docs as text
  -s,--style (default !) directory for style sheet (ldoc.css)
  -l,--template (default !) directory for template (ldoc.ltp)
  -p,--project (default ldoc) project name
  -t,--title (default Reference) page title
  -f,--format (default plain) formatting - can be markdown or plain
  -b,--package  (default .) top-level package basename (needed for module(...))
  -x,--ext (default html) output file extension
  --dump                debug output dump
  &lt;file&gt; (string) source file or directory containing source
</code></pre>

<p>For example, to process all files in the 'lua' directory:</p>

<pre><code>$ ldoc lua
output written to docs/
</code></pre>

<p>Thereafter the <code>docs</code> directory will contain <code>index.html</code> which points to individual modules in the <code>modules</code> subdirectory.  The <code>--dir</code> flag can specify where the output is generated, and will ensure that the directory exists. The output structure is like LuaDoc: there is an <code>index.html</code> and the individual modules are in the <code>modules</code> subdirectory.</p>

<p>If your modules use <code>module(...)</code> then the module name has to be deduced. If <code>ldoc</code> is run from the root of the package, then this deduction does not need any help - e.g. if your package was <code>foo</code> then <code>ldoc foo</code> will work as expected. If we were actually in the <code>foo</code> directory then <code>ldoc -b .. .</code> will correctly deduce the module names.</p>

<p>For new-style modules, that don't use <code>module()</code>, it is recommended that the module comment has an explicit <code>@module PACKAGE.NAME</code>. If it does not, then <code>ldoc</code> will still attempt to deduce the module name, but may need help with <code>--package</code> as above.</p>

<p>It is common to use an alias for the package name with new-style modules. Here an alias is explicitly specified, so that <code>ldoc</code> knows that functions qualified with <code>A</code> are part of the module <code>simple_alias</code>:</p>

<pre><code>------------
-- A new-style module.
-- @alias A

local simple_alias = {}
local A = simple_alias

--- return the answer. And complete the description
function A.answer()
  return 42
end

return simple_alias
</code></pre>

<p>(Here the actual module name is deduced from the file name, just like with <code>module(...)</code>)</p>

<p>It's semi-standard to use 'M' or '_M' for the module alias; LDoc will recognize these automatically.</p>

<p>By default, comments are treated verbatim and traditionally contain HTML. This is irritating for the human reader of the comments and tedious for the writer, so there is an option to use <a href="http://daringfireball.net/projects/markdown">Markdown</a>; <code>--format markdown</code>. This requires <a href="http://www.frykholm.se/files/markdown.lua">markdown.lua</a> by Niklas Frykholm to be installed (this can be most easily done with <code>luarocks install markdown</code>.)  <code>format = 'markdown'</code> can be used in your <code>config.ld</code>.</p>

<p>A special case is if you simply say 'ldoc .'. Then there <em>must</em> be a <code>config.ld</code> file available in the directory, and it can specify the file:</p>

<pre><code>file = "mymod.lua"
title = "mymod documentation"
description = "mymod does some simple but useful things"
</code></pre>

<p><code>file</code> can of course point to a directory, just as with the <code>--file</code> option. This mode makes it particularly easy for the user to build the documentation, by allowing you to specify everything explicitly in the configuration.</p>

<h2  id="T7">@see References</h2>

<p>The example at <code>tests/complex</code> shows how @see references are interpreted:</p>

<pre><code>complex.util.parse
complex.convert.basic
complex.util
complex.display
complex
</code></pre>

<p>You may of course use the full name of a module or function, but can omit the top-level namespace - e.g. can refer to the module <code>util</code> and the function <code>display.display_that</code> directly. Within a module, you can directly use a function name, e.g. in <code>display</code> you can say <code>display_this</code>.</p>

<p>What applies to functions also applies to any module-level item like tables. New module-level items can be defined and they will work according to these rules.</p>

<p>If a reference is not found within the project, LDoc checks to see if it is a reference to a Lua standard function or table, and links to the online Lua manual.</p>

<h2  id="T8">Processing Single Modules</h2>

<p><code>--output</code> can be used to give the output file a different name. This is useful for the special case when a single module file is specified. Here an index would be redundant, so the single HTML file generated contains the module documentation.</p>

<pre><code>$ ldoc mylib.lua --&gt; results in docs/index.html
$ ldoc --output mylib mylib.lua --&gt; results in docs/mylib.html
$ ldoc --output mylib --dir html mylib.lua --&gt; results in html/mylib.html
</code></pre>


<h2  id="T9">Sections</h2>

<p>The default sections used by LDoc are 'Functions', 'Tables' and 'Fields', corresponding to the built-in types 'function', 'table' and 'field'. If <code>config.ld</code> contains something like <code>new_type("macro","Macros")</code> then this adds a new section 'Macros' which contains items of 'macro' type - 'macro' is registered as a new valid tag name.  The default template then presents items under their corresponding section titles, in order of definition.</p>

<p>New with this release is the idea of <em>explicit</em> sections. The need occurs when a module has a lot of functions that need to be put into logical sections.</p>

<pre><code>--- File functions.
-- Useful utilities for opening foobar format files.
-- @section file

--- open a file
...

--- read a file
...

--- Encoding operations.
-- Encoding foobar output in different ways.
-- @section encoding

...
</code></pre>

<p>A section doc-comment has the same structure as a normal doc-comment; the summary is used as the new section title, and the description will be output at the start of the function details for that section.</p>

<p>In any case, sections appear under 'Contents' on the left-hand side. See the <a href="http://stevedonovan.github.com/winapi/api.html">winapi</a> documentation for an example of how this looks.</p>

<p>Arguably a module writer should not write such very long modules, but it is not the job of the documentation tool to limit the programmer!</p>

<p>A specialized kind of section is <code>type</code>: it is used for documenting classes. The functions (or fields) within a type section are considered to be the methods of that class.</p>

<pre><code>--- A File class.
-- @type File

....
--- get the modification time.
-- @return standard time since epoch
function File:mtime()
...
</code></pre>

<h2  id="T10">Dumping and getting Help about a Module</h2>

<p>There is an option to simply dump the results of parsing modules. Consider the C example `tests/example/mylib.c':</p>

<pre><code>$ ldoc --dump mylib.c
----
module: mylib   A sample C extension.
Demonstrates using ldoc's C/C++ support. Can either use /// or /*** */ etc.

function        createtable(narr, nrec)
Create a table with given array and hash slots.
narr     initial array slots, default 0
nrec     initial hash slots, default 0

function        solve(a, b, c)
Solve a quadratic equation.
a        coefficient of x^2
b        coefficient of x
c        constant
return  {"first root","second root"}
</code></pre>

<p>This is useful to quickly check for problems; here we see that <code>createable</code> did not have a return tag.</p>

<p>There is a more customizable way to process the data, using the <code>--filter</code> parameter. This is understood to be a fully qualified function (module + name). For example, try</p>

<pre><code>$ ldoc --filter pl.pretty.dump mylib.c
</code></pre>

<p>to see a raw dump of the data.</p>

<p>LDoc takes this idea of data dumping one step further. If used with the <code>-m</code> flag it will look up an installed Lua module and parse it. If it has been marked up in LuaDoc-style then you will get a handy summary of the contents:</p>

<pre><code>$ ldoc -m pl.pretty
----
module: pl.pretty       Pretty-printing Lua tables.
* read(s) - read a string representation of a Lua table.
* write(tbl, space, not_clever) - Create a string representation of a Lua table.

* dump(t, ...) - Dump a Lua table out to a file or stdout.
</code></pre>

<p>You can specify a fully qualified function to get more information:</p>

<pre><code>$ ldoc -m pl.pretty.write

function        write(tbl, space, not_clever)
create a string representation of a Lua table.
tbl      {table} Table to serialize to a string.
space    {string} (optional) The indent to use.
               Defaults to two spaces.
not_clever       {bool} (optional) Use for plain output, e.g {['key']=1}.
               Defaults to false.
</code></pre>

<p>LDoc knows about the basic Lua libraries, so that it can be used as a handy console reference:</p>

<pre><code>$&gt; ldoc -m assert

function        assert(v, message)
Issues an error when the value of its argument `v` is false (i.e.,
 nil or false); otherwise, returns all its arguments.
`message` is an error
 message; when absent, it defaults to "assertion failed!"
v
message
</code></pre>

<p>Thanks to mitchell's <a href="http://code.google.com/p/textadept/">TextAdept</a> project, LDoc has a set of <code>.luadoc</code> files for all the standard tables, plus <a href="http://keplerproject.github.com/luafilesystem/">LuaFileSystem</a> and <a href="http://www.inf.puc-rio.br/~roberto/lpeg/lpeg.html">LPeg</a>.</p>

<pre><code>$&gt; ldoc -m lfs.lock

function        lock(filehandle, mode, start, length)
Locks a file or a part of it.
This function works on open files; the file
 handle should be specified as the first argument. The string mode could be
 either r (for a read/shared lock) or w (for a write/exclusive lock). The
 optional arguments start and length can be used to specify a starting point
 and its length; both should be numbers.
 Returns true if the operation was successful; in case of error, it returns
 nil plus an error string.
filehandle
mode
start
length
</code></pre>

<h2  id="T11">Generating HTML</h2>

<p>LDoc, like LuaDoc, generates output HTML using a template, in this case <code>ldoc.ltp</code>. This is expanded by the powerful but simple preprocessor devised originally by <a href="http://lua-users.org/wiki/SlightlyLessSimpleLuaPreprocessor">Rici Lake</a> which is now part of Penlight. There are two rules - any line starting with '#' is Lua code, which can also be embedded with '$(...)'.</p>

<pre><code>&lt;h2&gt;Contents&lt;/h2&gt;
&lt;ul&gt;
# for kind,items in module.kinds() do
&lt;li&gt;&lt;a href="#$(no_spaces(kind))"&gt;$(kind)&lt;/a&gt;&lt;/li&gt;
# end
&lt;/ul&gt;
</code></pre>

<p>This is then styled with <code>ldoc.css</code>. Currently the template and stylesheet is very much based on LuaDoc, so the results are mostly equivalent; the main change that the template has been more generalized. The default location (indicated by '!') is the directory of <code>ldoc.lua</code>.</p>

<p>You may customize how you generate your documentation by specifying an alternative style sheet and/or template, which can be deployed with your project. The parameters are <code>--style</code> and <code>--template</code>, which give the directories where <code>ldoc.css</code> and <code>ldoc.ltp</code> are to be found. If <code>config.ld</code> contains these variables, they are interpreted slightly differently; if they are true, then it means 'use the same directory as config.ld'; otherwise they must be a valid directory relative to the ldoc invocation. An example of fully customized documentation is `tests/example/style': this is what you could call 'minimal Markdown style' where there is no attempt to tag things (except emphasizing parameter names). The narrative ought to be sufficient, if it is written appropriately.</p>

<p>Of course, there's no reason why LDoc must always generate HTML. `--ext' defines what output extension to use; this can also be set in the configuration file. So it's possible to write a template that converts LDoc output to LaTex, for instance.</p>

</body></html>