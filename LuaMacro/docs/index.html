<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<title>LuaMacro - a macro preprocessor for Lua</title>
	<link rel="stylesheet" type="text/css" href="default.css" />
</head>
<body>
<h2  id="T1">LuaMacro - a macro preprocessor for Lua</h2>

<ul>
    <li><a href="#T2">Basic Macro Substitution</a></li>
    <li><a href="#T3">Using macro.define</a></li>
    <li><a href="#T4">Dynamically controlling macro expansion</a></li>
    <li><a href="#T5">Operator Macros</a></li>
    <li><a href="#T6">Pass-Through Macros</a></li>
    <li><a href="#T7">Preprocessing C</a></li>
    <li><a href="#T8">Implementation</a>
    <ul>
        <li><a href="#T9">Token Lists</a></li>
        <li><a href="#T10">Program Structure</a></li>
    </ul></li>
</ul>



<p>This is a library and driver script for preprocessing and evaluating Lua code. Lexical macros can be defined, which may be simple C-preprocessor style macros or macros that change their expansion depending on the context.</p>

<p>It is a new, rewritten version of the <a href="http://luaforge.net/projects/luamacro/">Luaforge</a> project of the same name, which required the <a href="http://www.tecgraf.puc-rio.br/~lhf/ftp/lua/#tokenf">token filter patch</a> by Luiz Henrique de Figueiredo. This patch allowed Lua scripts to filter the raw token stream before the compiler stage. Within the limits imposed by the lexical filter approach this worked pretty well.  However, the token filter patch is unlikely to ever become part of mainline Lua, either in its original or <a href="http://lua-users.org/lists/lua-l/2010-02/msg00325.html">revised</a> form. So the most portable option becomes precompilation, but Lua bytecode is not designed to be platform-independent and in any case changes faster than the surface syntax of the language. So using LuaMacro with LuaJIT would have required re-applying the patch, and remaining within the ghetto of specialized, experimental use.</p>

<p>This implementation uses a <a href="http://www.inf.puc-rio.br/~roberto/lpeg.html">LPeg</a> lexical analyser originally by <a href="http://lua-users.org/wiki/LpegRecipes">Peter Odding</a> to tokenize Lua source, and builds up a preprocessed string explicitly, which then can be loaded in the usual way. This is not as efficient as the original, but it can be used by anyone with a Lua interpreter, whether it is Lua 5.1, 5.2 or LuaJIT 2. An advantage of fully building the output is that it becomes much easier to debug macros when you can actually see the generated results. (Another example of a LPeg-based Lua macro preprocessor is <a href="http://luaforge.net/projects/luma/">Luma</a>)</p>

<p>It is not possible to discuss macros in Lua without mentioning Fabien Fleutot's <a href="metalua.luaforge.net/">Metalua</a> which is an alternative Lua compiler which supports syntactical macros that can work on the AST (Abstract Syntax Tree) itself of Lua. This is clearly a technically superior way to extend Lua syntax, but again has the disadvantage of being a direct-to-bytecode compiler. (Perhaps it's also a matter of taste, since I find it easier to think about extending Lua on the lexical level.)</p>

<p>My renewed interest in Lua lexical macros came from some discussions on the Lua mailing list about numerically optimal Lua code using LuaJIT. We have been spoiled by modern optimizing C/C++ compilers, where hand-optimization is often discouraged, but LuaJIT is new and requires some assistance. For instance, unrolling short loops can make a dramatic difference, but Lua does not provide the key concept of constant value to assist the compiler. So a very straightforward use of a macro preprocessor is to provide named constants in the old-fashioned C way. Very efficient code can be generated by generalizing the idea of 'varargs' into a statically-compiled 'tuple' type.</p>

<pre><code>tuple(3) A,B
</code></pre>

<p>The assigment <code>A = B</code> is expanded as:</p>

<pre><code>A_1,A_2,A_3 = B_1,B_2,B_3
</code></pre>

<p>I will show how the expansion can be made context-sensitive, so that the loop-unrolling macro <code>do_</code> changes this behaviour:</p>

<pre><code>do_(i,1,3,
    A = 0.5*B
)
</code></pre>

<p>expands to:</p>

<pre><code>A_1 = 0.5*B_1
A_2 = 0.5*B_2
A_3 = 0.5*B_3
</code></pre>

<p>Another use is crafting DSLs, particularly for end-user scripting. For instance, people may be more comfortable with <code>forall x in t do</code> rather than <code>for _,x in ipairs(t) do</code>; there is less to explain in the first form and it translates directly to the second form. Another example comes from this common pattern:</p>

<pre><code>some_action(function()
  ...
end)
</code></pre>

<p>Using the following macro:</p>

<pre><code>def_ block (function() _END_CLOSE_
</code></pre>

<p>we can write:</p>

<pre><code>some_action block
   ...
end
</code></pre>

<p>A criticism of traditional lexical macros is that they don't respect the scoping rules of the language itself. Bad experiences with the C preprocessor lead many to regard them as part of the prehistory of computing. The macros described here can be lexically scoped, and can be as 'hygenic' as necessary, since their expansion can be finely controlled with Lua itself.</p>

<p>For me, a more serious charge against 'macro magic' is that it can lead to a private dialect of the language (the original Bourne shell was written in C 'skinned' to look like Algol 68.)  This often indicates a programmer uncomfortable with a language, who wants it to look like something more familiar. Relying on a preprocessor may mean that programmers need to immerse themselves in the idioms of the new language.</p>

<p>That being said, macros can extend a language so that it can be more expressive for a particular task, particularly if the users are not professional programmers.</p>

<h3  id="T2">Basic Macro Substitution</h3>

<p>To install LuaMacro, expand the archive and make a script or batch file that points to <code>luam.lua</code>, for instance:</p>

<pre><code>lua /home/frodo/luamacro/luam.lua %*
</code></pre>

<p>(Or '$*' if not on Windows.) Then put this file on your executable path.</p>

<p>Any Lua code loaded with <code>luam</code> goes through four distinct steps:</p>

<ul>
    <li>loading and defining macros</li>
    <li>preprocessing</li>
    <li>compilation</li>
    <li>execution</li>
</ul>

<p>The last two steps happen within Lua itself, but always occur, even though the Lua compiler is fast enough that we mostly do not bother to save the generated bytecode.</p>

<p>For example, consider this <code>hello.lua</code>:</p>

<pre><code>print(HELLO)
</code></pre>

<p>and <code>hello-def.lua</code>:</p>

<pre><code>local macro = require 'macro'
macro.define 'HELLO "Hello, World!"'
</code></pre>

<p>To run the program:</p>

<pre><code>$&gt; luam -lhello-def hello.lua
Hello, World!
</code></pre>

<p>So the module <code>hello-def.lua</code> is first loaded (compiled and executed, but not preprocessed) and only then <code>hello.lua</code> can be preprocessed and then loaded.</p>

<p>Naturaly, there are easier ways to use LuaMacro, but I want to emphasize the sequence of macro loading, preprocessing and script loading. <code>luam</code> has a <code>-d</code> flag, meaning 'dump', which is very useful when debugging the output of the preprocessing step:</p>

<pre><code>$&gt; luam -d -lhello-def hello.lua
print("Hello, World!")
</code></pre>

<p><code>hello2.lua</code> is a more sensible first program:</p>

<pre><code>require_ 'hello-def'
print(HELLO)
</code></pre>

<p>You cannot use the Lua <code>require</code> function at this point, since <code>require</code> is only executed when the program starts executing and we want the macro definitions to be available during the current compilation. <code>require_</code> is the macro version, which loads the file at compile-time.</p>

<p>There is also <code>include_</code>, which is analogous to <code>#include</code> in <code>cpp</code>. It takes a file path in quotes, and directly inserts the contents of the file into the current compilation. Although tempting to use, it will not work here because again the macro definitions will not be available at compile-time.</p>

<p><code>hello3.lua</code> fits much more into the C preprocessor paradigm, which uses the <code>def_</code> macro:</p>

<pre><code>def_ HELLO "Hello, World!"
print(HELLO)
</code></pre>

<p>(Like <code>cpp</code>, such macro definitions end with the line; however, there is no equivalent of `` to extend the definition over multiple lines.)</p>

<p>With 2.1, an alternative syntax <code>def_ (name body)</code> is also available, which can be embedded inside a macro expression:</p>

<pre><code>def_ OF_ def_ (of elseif _value ==)
</code></pre>

<p>Or even extend over several lines:</p>

<pre><code>def_ (complain(msg,n)
  for i = 1,n do
    print msg
  end
)
</code></pre>

<p><code>def_</code> works pretty much like <code>#define</code>, for instance, <code>def_ SQR(x) ((x)*(x))</code>. A number of C-style favourites can be defined, like <code>assert_</code> using <code>_STR_</code>, which is a predefined macro that 'stringifies' its argument.</p>

<pre><code>def_ assert_(condn) assert(condn,_STR_(condn))
</code></pre>

<p><code>def_</code> macros are <em>lexically scoped</em>:</p>

<pre><code>local X = 1
if something then
    def_ X 42
    assert(X == 42)
end
assert(X == 1)
</code></pre>

<p>LuaMacro keeps track of Lua block structure - in particular it knows when a particular lexical scope has just been closed.  This is how the <code>_END_CLOSE_</code> built-in macro works</p>

<pre><code>def_ block (function() _END_CLOSE_

my_fun block
  do_something_later()
end
</code></pre>

<p>When the current scope closes with <code>end</code>, LuaMacro appends the necessary ')' to make this syntax valid.</p>

<p>A common use of macros in both C and Lua is to inline optimized code for a case. The Lua function <code>assert()</code> always evaluates its second argument, which is not always optimal:</p>

<pre><code>def_ ASSERT(condn,expr) if condn then else error(expr) end

ASSERT(2 == 1,"damn! ".. 2 .." is not equal to ".. 1)
</code></pre>

<p>If the message expression is expensive to execute, then this can give better performance at the price of some extra code. <code>ASSERT</code> is now a statement, not a function, however.</p>

<h3  id="T3">Using macro.define</h3>

<p><code>macro.define</code> is less convenient than <code>def_</code> but much more powerful. The extended form allows the substitution to be a <em>function</em> which is called in-place at compile time:</p>

<pre><code>macro.define('DATE',function()
    return '"'..os.date('%c')..'"'
end)
</code></pre>

<p>Any text which is returned will be tokenized and inserted into the output stream. The explicit quoting here is needed to ensure that <code>DATE</code> will be replaced by the string "04/30/11 09:57:53".  ('%c' gives you the current locale's version of the date; for a proper version of this macro, best to use <code>os.date</code> <a href="http://www.lua.org/pil/22.1.html">with more explicit formats</a> .)</p>

<p>This function can also return nothing, which allows you to write macro code purely for its <em>side-effects</em>.</p>

<p>Non-operator characters like <code>@</code>,<code>$</code>, etc can be used as macros. For example, say you like shell-like notation <code>$HOME</code> for expanding environment variables in your scripts.</p>

<pre><code>macro.define '$(x) os.getenv(_STR_(x))'
</code></pre>

<p>A script can now say <code>$(PATH)</code> and get the expected expansion, Make-style. But we can do better and support <code>$PATH</code> directly:</p>

<pre><code>macro.define('$',function(get)
    local var = get:name()
    return 'os.getenv("'..var..'")'
end)
</code></pre>

<p>If a macro has no parameters, then the substitution function receives a 'getter' object. This provides methods for extracting various token types from the input stream. Here the <code>$</code> macro must be immediately followed by an identifier.</p>

<p>We can do better, and define <code>$</code> so that something like <code>$(pwd)</code> has the same meaning as the Unix shell:</p>

<pre><code>macro.define('$',function(get)
   local t,v = get()
   if t == 'iden' then
      return 'os.getenv("'..v..'")'
   elseif t == '(' then
      local rest = get:upto ')'
      return 'os.execute("'..tostring(rest)..'")'
   end
end)
</code></pre>

<p>(The getter <code>get</code> is callable, and returns the type and value of the next token.)</p>

<p>It is probably a silly example, but it illustrates how a macro can be overloaded based on its lexical context. Much of the expressive power of LuaMacro comes from allowing macros to fetch their own parameters in this way. It allows us to define new syntax and go beyond 'pseudo-functions', which is more important for a conventional-syntax language like Lua, rather than Lisp where everything looks like a function.</p>

<p>It is entirely possible for macros to create macros; that is what <code>def_</code> does. Consider how to add the concept of <code>const</code> declarations to Lua:</p>

<pre><code>const N,M = 10,20
</code></pre>

<p>Here is one solution:</p>

<pre><code>macro.define ('const',function(get)
    get() -- skip the space
    local vars,values = get:names '=',get:list '\n'
    for i,name in ipairs(vars) do
        macro.assert(values[i],'each constant must be assigned!')
        macro.define_scoped(name,tostring(values[i]))
    end
end)
</code></pre>

<p>The key to making these constants well-behaved is <code>define_scoped</code>, which installs a block handler which resets the macro to its original value, which is usually <code>nil</code>. This test script shows how the scoping works:</p>

<pre><code>require_ 'const'
do
  const N,M = 10,20
  do
     const N = 5
     assert(N == 5)
  end
  assert(N == 10 and M == 20)
end
assert(N == nil and M == nil)
</code></pre>


<p>If we were designing a DSL intended for non-technical users, then we cannot just say to them 'learn the language properly - go read PiL!'. It would be easier to explain:</p>

<pre><code>forall x in {10,20,30} do
</code></pre>

<p>than the equivalent generic <code>for</code> loop. <code>forall</code> can be implemented fairly simply as a macro:</p>

<pre><code>macro.define('forall',function(get)
  local var = get:name()
  local t,v = get:next() -- will be 'in'
  local rest = tostring(get:upto 'do')
  return ('for _,%s in ipairs(%s) do'):format(var,rest)
end)
</code></pre>

<p>That is, first get the loop variable, skip <code>in</code>, grab everything up to <code>do</code> and output the corresponding <code>for</code> statement.</p>

<p>Useful macros can often be built using these new forms. For instance, here is a simple list comprehension macro:</p>

<pre><code>macro.define('L(expr,select) '..
    '(function() local res = {} '..
    '  forall select do res[#res+1] = expr end '..
    'return res end)()'
)
</code></pre>

<p>For example, <code>L(x^2,x in t)</code> will make a list of the squares of all elements in <code>t</code>.</p>

<p>(<code>macro.forall</code> defines more sophisticated <code>forall</code> statements and list comprehension expressions, but the principle is the same.)</p>

<p>There is a second argument passed to the substitution function, which is a 'putter' object - an object for building token lists. For example, a useful shortcut for anonymous functions:</p>

<pre><code>M.define ('\\',function(get,put)
    local args, body = get:names('('), get:list()
    return put:keyword 'function' '(' : names(args) ')' :
        keyword 'return' : list(body) : space() : keyword 'end'
end)
</code></pre>

<p>The <code>put</code> object has methods for appending particular kinds of tokens, such as keywords and strings, and is also callable for operator tokens. These always return the object itself, so the output can be built up with chaining.</p>

<p>Consider <code>\x,y(x+y)</code>: the <code>names</code> getter grabs a comma-separated list of names upto the given token; the <code>list</code> getter grabs a general argument list. It returns a list of token lists and by default stops at ')'.  This 'lambda' notation was suggested by Luiz Henrique de Figueiredo as something easily parsed by any token-filtering approach - an alternative notation <code>|x,y| x+y</code> has been <a href="http://lua-users.org/lists/lua-l/2009-12/msg00071.html">suggested</a> but is generally impossible to implement using a lexical scanner, since it would have to parse the function body as an expression. The <code>\\</code> macro also has the advantage that the operator precedence is explicit: in the case of <code>\\(42,'answer')</code> it is immediately clear that this is a function of no arguments which returns two values.</p>

<p>(Although I would not necessarily suggest that lambdas are a good thing in production code, they can be useful in iteractive exploration and within tests.)</p>

<p>Macros with explicit parameters can define a substitution function, but this function receives the values themselves, not the getter and putter objects. These values are <em>token lists</em> and must be converted into the expected types using the token list methods:</p>

<pre><code>macro.define('test_(var,start,finish)',function(var,start,finish)
    var,start,finish = var:get_iden(),start:get_number(),finish:get_number()
    print(var,start,finish)
end)
</code></pre>


<p>Since no <code>put</code> object is received, such macros need to construct their own:</p>

<pre><code>    local put = M.Putter()
    ...
    return put
</code></pre>

<p>(They can of course still just return the substitution as text.)</p>

<h3  id="T4">Dynamically controlling macro expansion</h3>

<p>Consider this loop-unrolling macro:</p>

<pre><code>do_(i,1,3,
   y = y + 1
)
</code></pre>

<p>which will expand as</p>

<pre><code>y = y + 1
y = y + 2
y = y + 3
</code></pre>

<p>For each iteration, it needs to define a local macro <code>i</code> which expands to 1,2 and 3.</p>

<pre><code>macro.define('do_(v,s,f,stat)',function(var,start,finish,statements)
    local put = macro.Putter()
    var,start,finish = var:iden(),start:number(),finish:number()
    macro.push_token_stack('do_',var)
    for i = start, finish do
        -- output `set_ &lt;var&gt; &lt;value&gt; `
        put:name 'set_':name(var):number(i):space()
        put:tokens(statements)
    end
    -- output `undef_ &lt;var&gt; &lt;value&gt;`
    put:name 'undef_':name(var)
    -- output `_POP_ 'do_'`
    put:name '_DROP_':string 'do_'
    return put
end)
</code></pre>

<p>Ignoring the macro stack manipulation for a moment, it works by inserting <code>set_</code> macro assignments into the output. That is, the raw output looks like this:</p>

<pre><code>set_ i 1
y = y + i
set_ i 2
y = y + i
set_ i 2
y = y + i
undef_ i
_DROP_ 'do_'
</code></pre>

<p>It's important here to understand that LuaMacro does not do <em>recursive</em> substitution. Rather, the output of macros is pushed out to the stream which is then further substituted, etc. So we do need these little helper macros to set the loop variable at each point.</p>

<p>Using the macro stack allows macros to be aware that they are expanding inside a <code>do_</code> macro invocation.  Consider <code>tuple</code>, which is another macro which creates macros:</p>

<pre><code>tuple(3) A,B
A = B
</code></pre>

<p>which would expand as</p>

<pre><code>local A_1,A_2,A_3,B_1,B_2,B_3
A_1,A_2,A_3 = B_1,B_2,B_3
</code></pre>

<p>But we would like</p>

<pre><code>do_(i,1,3,
  A = B/2
)
</code></pre>

<p>to expand as</p>

<pre><code>A_1 = B_1/2
A_2 = B_2/2
A_2 = B_2/2
</code></pre>

<p>And here is the definition:</p>

<pre><code>macro.define('tuple',function(get)
    get:expecting '('
    local N = get:number()
    get:expecting ')'
    get:expecting 'space'
    local names = get:names '\n'
    for _,name in ipairs(names) do
        macro.define(name,function(get,put)
            local loop_var = macro.value_of_macro_stack 'do_'
            if loop_var then
                local loop_idx = tonumber(macro.get_macro_value(loop_var))
                return put:name (name..'_'..loop_idx)
            else
                local out = {}
                for i = 1,N do
                    out[i] = name..'_'..i
                end
                return put:names(out)
            end
        end)
    end
end)
</code></pre>

<p>The first expansion case happens if we are not within a <code>do_</code> macro; a simple list of names is outputted.  Otherwise, we know what the loop variable is, and can directly ask for its value.</p>

<h3  id="T5">Operator Macros</h3>

<p>You can of course define <code>@</code> to be a macro; a new feature allows you to add new operator tokens:</p>

<pre><code>macro.define_tokens {'##','@-'}
</code></pre>

<p>which can then be used with <code>macro.define</code>, but also now with <code>def_</code>. It's now possible to define a list comprehension syntax that reads more naturally, e.g. <code>{|x^2| i=1,10}</code> by making <code>{|</code> into a new token.</p>

<p>Up to now, making a Lua operator token such as <code>.</code> into a macro was not so useful. Such a macro may now return an extra value which indicates that the operator should simply 'pass through' as is.  Consider defining a <code>with</code> statement:</p>

<pre><code>with A do
    .x = 1
    .y = 2
end
</code></pre>

<p>I've deliberately indicated the fields using a dot (a rare case of Visual Basic syntax being superior to Delphi).  So it is necessary to overload '.' and look at the previous token: if it isn't a case like <code>name.</code> or <code>].</code> then we prepend the table.</p>

<pre><code>M.define('with',function(get,put)
  M.define_scoped('.',function()
    local lt,lv = M.peek(-1,true) --  peek before the period...
    if lt ~= 'iden' and lt ~= ']' then
      return '_var.'
    else
      return nil,true -- pass through
    end
  end)
  local expr = get:upto 'do'
  return 'do local _var = '..tostring(expr)..'; '
end)
</code></pre>

<p>Again, scoping means that this behaviour is completely local to the with-block.</p>

<p>A more elaborate experiment is <code>cskin.lua</code> in the tests directory. This translates a curly-bracket form into standard Lua, and at its heart is defining '{' and '}' as macros. You have to keep a brace stack, because these tokens still have their old meaning. The table constructor in this example must still work, while the trailing brace must be converted to <code>end</code>.</p>

<pre><code>if (a &gt; b) {
   t = {a,b}
}
</code></pre>

<h3  id="T6">Pass-Through Macros</h3>

<p>Normally a macro replaces the name (plus any arguments) with the substitution. It is sometimes useful to pass the name through, but not to push the name into the token stream - otherwise we will get an endless expansion.</p>

<pre><code>macro.define('fred',function()
  print 'fred was found'
  return nil, true
end)
</code></pre>

<p>This has absolutely no effect on the preprocessed text ('fred' remains 'fred', but has a side-effect. This happens if the substitution function returns a second <code>true</code> value.  You can look at the immediate lexical environment with <code>peek</code>:</p>

<pre><code>macro.define('fred',function(get)
    local t,v = get:peek(1)
    if t == 'string' then
        local str = get:string()
        return 'fred_'..str
    end
    return nil,true
end)
</code></pre>

<p>Pass-through macros are useful when each macro corresponds to a Lua variable; they allow such variables to have a dual role.</p>

<p>An example would be Python-style lists. The <a href="http://stevedonovan.github.com/Penlight/api/modules/pl.List.html">Penlight List</a> class has the same functionality as the built-in Python list, but does not have any syntactical support:</p>

<pre><code>&gt; List = require 'pl.List'
&gt; ls = List{10,20,20}
&gt; = ls:slice(1,2)
{10,20}
&gt; ls:slice_assign(1,2,{10,11,20,21})
&gt; = ls
{10,11,20,21,30}
</code></pre>

<p>It would be cool if we could add a little bit of custom syntax to make this more natural.  What we first need is a 'macro factory' which outputs the code to create the lists, and also suitable macros with the same names.</p>

<pre><code>-- list &lt;var-list&gt; [ = &lt;init-list&gt; ]
M.define ('list',function(get)
    get() -- skip space
    -- 'list' acts as a 'type' followed by a variable list, which may be
    -- followed by initial values
    local values
    local vars,endt = get:names (function(t,v)
        return t == '=' or (t == 'space' and v:find '\n')
    end)
    -- there is an initialization list
    if endt[1] == '=' then
        values,endt = get:list '\n'
    else
        values = {}
    end
    -- build up the initialization list
    for i,name in ipairs(vars) do
       M.define_scoped(name,list_check)
       values[i] = 'List('..tostring(values[i] or '')..')'
    end
    local lcal = M._interactive and '' or 'local '
    local res = lcal..table.concat(vars,',')..' = '..table.concat(values,',')..tostring(endt)
    return res
end)
</code></pre>

<p>Note that this is a fairly re-usable pattern; it requires the type constructor (<code>List</code> in this case) and a type-specific macro function (<code>list_check</code>). The only tricky bit is handling the two cases, so the <code>names</code> method finds the end using a function, not a simple token.  <code>names</code>, like <code>list</code>, returns the list and the token that ended the list, so we can use <code>endt</code> to check.</p>

<pre><code>list a = {1,2,3}
list b
</code></pre>

<p>becomes</p>

<pre><code>local a = List({1,2,3})
local b = List()
</code></pre>

<p>unless we are in interactive mode, where <code>local</code> is not appropriate!</p>

<p>Each of these list macro/variables may be used in several ways:</p>

<ul>
    <li>directly <code>a</code> - no action!</li>
    <li><code>a[i]</code> - plain table index</li>
    <li><code>a[i:j]</code> - a list slice. Will be <code>a:slice(i,j)</code> normally, but must
    be <code>a:slice_assign(i,j,RHS)</code> if on the right-hand side of an assignment.</li>
</ul>

<p>The substitution function checks these cases by appropriate look-ahead:</p>

<pre><code>function list_check (get,put)
    local t,v = get:peek(1)
    if t ~= '[' then return nil, true end -- pass-through; plain var reference
    get:expecting '['
    local args = get:list(']',':')
    -- it's just plain table access
    if #args == 1 then return '['..tostring(args[1])..']',true end

    -- two items separated by a colon; use sensible defaults
    M.assert(#args == 2, "slice has two arguments!")
    local start,finish = tostring(args[1]),tostring(args[2])
    if start == '' then start = '1' end
    if finish == '' then finish = '-1' end

    -- look ahead to see if we're on the left hand side of an assignment
    if get:peek(1) == '=' then
       get:next() -- skip '='
       local rest,eoln = get:upto '\n'
       rest,eoln = tostring(rest),tostring(eoln)
       return (':slice_assign(%s,%s,%s)%s'):format(start,finish,rest,eoln),true
    else
        return (':slice(%s,%s)'):format(start,finish),true
    end
end
</code></pre>

<p>This can be used interactively, like so (it requires the Penlight list library.)</p>

<pre><code>$&gt; luam  -llist -i
Lua 5.1.4  Copyright (C) 1994-2008 Lua.org, PUC-Rio
Lua Macro 2.3.0 Copyright (C) 2007-2011 Steve Donovan
&gt; list a = {'one','two'}
&gt; = a:map(\x(x:sub(1,1)))
{o,t}
&gt; a:append 'three'
&gt; a:append 'four'
&gt; = a
{one,two,three,four}
&gt; = a[2:3]
{two,three}
&gt; = a[2:2] = {'zwei','twee'}
{one,zwei,twee,three,four}
&gt; = a[1:2]..{'five'}
{one,zwei,five}
</code></pre>

<h3  id="T7">Preprocessing C</h3>

<p>With the 2.2 release, LuaMacro can preprocess C files, by the inclusion of a C LPeg lexer based on work by Peter Odding. This may seem a semi-insane pursuit, given that C already has a preprocessor, (which is widely considered a misfeature.)  However, the macros we are talking about are clever, they can maintain state, and can be scoped lexically.</p>

<p>One of the irritating things about C is the need to maintain separate include files. It would be better if we could write a module like this:</p>


<pre><code>// dll.c
#include "dll.h"

export {
    typedef struct {
        int ival;
    } MyStruct;
}

export int one(MyStruct *ms) {
    return ms-&gt;ival + 1
}

export int two(MyStruct *ms) {
    return 2*ms-&gt;ival;
}
</code></pre>

<p>and have the preprocessor generate an apppropriate header file:</p>


<pre><code>#ifndef DLL_H
#define DLL_H
typedef struct {
        int ival;
    } MyStruct;

int one(MyStruct *ms) ;
int two(MyStruct *ms) ;
#endif
</code></pre>

<p>The macro <code>export</code> is straightforward:</p>


<pre><code>M.define('export',function(get)
    local t,v = get:next()
    local decl,out
    if v == '{' then
        decl = tostring(get:upto '}')
        f:write(decl,'\n')
    else
        decl = v .. ' ' .. tostring(get:upto '{')
        f:write(decl,';\n')
        out = decl .. '{'
    end
    return out
end)
</code></pre>

<p>It looks ahead and if it finds a <code>{}</code> block it writes it wholesale to a file stream; otherwise writes everything upto a block opening.</p>

<p><code>tests/cexport.lua</code> shows how this idea can be extended, so that the generated header is only updated when it changes.</p>

<p>To preprocess C with <code>luam</code>, you need to specify the <code>-C</code> flag:</p>

<pre><code>luam -C -lcexport dll.lc &gt; dll.c
</code></pre>

<p>Have a look at <a href="modules/macro.lc.html">lc</a> which defines a simplified way to write Lua bindings in C.</p>

<p>This was used for the <a href="https://github.com/stevedonovan/winapi">winapi</a> project to preprocess <a href="https://github.com/stevedonovan/winapi/blob/master/winapi.l.c">this file</a> into standard C.</p>


<h3  id="T8">Implementation</h3>

<p>It is not usually necessary to understand the underlying representation of token lists, but I present it here as a guide to understanding the code.</p>

<h4  id="T9">Token Lists</h4>

<p>The token list representation of the expression <code>x+1</code> is:</p>

<pre><code>{{'iden','x'},{'+','+'},{'number','1'}}
</code></pre>

<p>which is the form returned by the LPeg lexical analyser. Please note that there are also 'space' and 'comment' tokens in the stream, which is a big difference from the token-filter standard.</p>

<p>The <code>TokenList</code> type defines <code>__tostring</code> and some helper methods for these lists.</p>

<p>The following macro is an example of the lower-level coding needed without the usual helpers:</p>

<pre><code>local macro = require 'macro'
macro.define('qw',function(get,put)
  local append = table.insert
  local t,v = get()
  local res = {{'{','{'}}
  t,v = get:next()
  while t ~= ')' do
    if t ~= ',' then
      append(res,{'string','"'..v..'"'})
      append(res,{',',','})
    end
    t,v = get:next()
  end
  append(res,{'}','}'})
  return res
end)
</code></pre>

<p>We're just using the getter <code>next</code> method to skip any irritating whitespace, but building up the substitution without a putter, just manipulating the raw token list.  <code>qw</code> takes a plain list of words, separated by spaces (and maybe commas) and makes it into a list of strings. That is,</p>

<pre><code>qw(one two three)
</code></pre>

<p>becomes</p>

<pre><code>{'one','two','three'}
</code></pre>

<h4  id="T10">Program Structure</h4>

<p>The main loop of <code>macro.substitute</code> (towards end of <code>macro.lua</code>) summarizes the operation of LuaMacro:</p>

<p>There are two macro tables, <code>imacro</code> for classic name macros, and <code>smacro</code> for operator style macros. They contain macro tables, which must have a <code>subst</code> field containing the substitution and may have a <code>parms</code> field, which means that they must be followed by their arguments in parentheses.</p>

<p>A keywords table is chiefly used to track block scope, e.g. <code>do</code>,<code>if</code>,<code>function</code>,etc means 'increase block level' and <code>end</code>,<code>until</code> means 'decrease block level'. At this point, any defined block handlers for this level will be evaluated and removed. These may insert tokens into the stream, like macros. This is how something like <code>_END_CLOSE_</code> is implemented: the <code>end</code> causes the block level to decrease, which fires a block handler which passes <code>end</code> through and inserts a closing <code>)</code>.</p>

<p>Any keyword may also have an associated keyword handler, which works rather like a macro substitution, except that the keyword itself is always passed through first. (Allowing keywords as regular macros would generally be a bad idea because of the recursive substitution problem.)</p>

<p>The macro <code>subst</code> field may be a token list or a function. if it is a function then that function is called, with the parameters as token lists if the macro defined formal parameters, or with getter and setter objects if not. If the result is text then it is parsed into a token list.</p>

</body></html>