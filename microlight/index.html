<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>ldoc</h1>


<h2>Contents</h2>
<ul>
<li><a href="#String_utilties">String utilties</a></li>
<li><a href="#File_and_Path_functions">File and Path functions</a></li>
<li><a href="#Extended_table_functions">Extended table functions</a></li>
<li><a href="#Functional_helpers">Functional helpers</a></li>
<li><a href="#Classes">Classes</a></li>
</ul>


<h2>Modules</h2>
<ul>
  <li><strong>ml</strong></li>
</ul>

</div>

<div id="content">

<h1>Module <code>ml</code></h1>

<p>Microlight - a very compact Lua utilities module</p>
<p> Steve Donovan, 2012; License MIT</p>

<h2><a href="#String_utilties">String utilties</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#split">split&nbsp;(s, re, n)</a></td>
	<td class="summary">split a string into a list of strings separated by a delimiter.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#escape">escape&nbsp;(s)</a></td>
	<td class="summary">escape any 'magic' characters in a string</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#expand">expand&nbsp;(s, subst)</a></td>
	<td class="summary">expand a string containing any ${var} or $var.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#readfile">readfile&nbsp;(filename, is_bin)</a></td>
	<td class="summary">return the contents of a file as a string</td>
	</tr>
</table>
<h2><a href="#File_and_Path_functions">File and Path functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#exists">exists&nbsp;(filename)</a></td>
	<td class="summary">Does a file exist?</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#splitpath">splitpath&nbsp;(P)</a></td>
	<td class="summary">split a file path.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#splitext">splitext&nbsp;(P)</a></td>
	<td class="summary">given a path, return the root part and the extension part.</td>
	</tr>
</table>
<h2><a href="#Extended_table_functions">Extended table functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#tstring">tstring&nbsp;(t)</a></td>
	<td class="summary">return a string representation of a Lua value.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#tdump">tdump&nbsp;(t, ...)</a></td>
	<td class="summary">dump a Lua value to a file object.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#imap">imap&nbsp;(f, t, ...)</a></td>
	<td class="summary">map a function over a list.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#imap2">imap2&nbsp;(f, t1, t2)</a></td>
	<td class="summary">map a function over two lists.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#foreach">foreach&nbsp;(t, f, ...)</a></td>
	<td class="summary">call a function repeatedly.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#ifilter">ifilter&nbsp;(t, pred, ...)</a></td>
	<td class="summary">filter a list using a predicate.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#ifind">ifind&nbsp;(t, pred, ...)</a></td>
	<td class="summary">find an item in a list using a predicate.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#indexof">indexof&nbsp;(t, value)</a></td>
	<td class="summary">return the index of an item in a list.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#sub">sub&nbsp;(t, i1, i2)</a></td>
	<td class="summary">return a slice of a list.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#icopy">icopy&nbsp;(dest, src, idest, isrc, nsrc)</a></td>
	<td class="summary">copy a list into another.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#indexby">indexby&nbsp;(t, keys)</a></td>
	<td class="summary">make a list of indexed values.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#import">import&nbsp;(t, ...)</a></td>
	<td class="summary">add the key/value pairs of <code>other</code> to <code>t</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#extend">extend&nbsp;(t, other)</a></td>
	<td class="summary">extend a list using values from another.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#makemap">makemap&nbsp;(t, tv)</a></td>
	<td class="summary">make a map from a list.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#keys">keys&nbsp;(t)</a></td>
	<td class="summary">extract the keys of a table as a list.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#subset">subset&nbsp;(t, other)</a></td>
	<td class="summary">is <code>other</code> a subset of <code>t</code>?</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#tequal">tequal&nbsp;(t, other)</a></td>
	<td class="summary">are these two tables equal?</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#collect">collect&nbsp;(iter, select)</a></td>
	<td class="summary">collect the values of an iterator into a list.</td>
	</tr>
</table>
<h2><a href="#Functional_helpers">Functional helpers</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#bind1">bind1&nbsp;(f, v)</a></td>
	<td class="summary">bind the value <code>v</code> to the first argument of function <code>f</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#bind2">bind2&nbsp;(f, v)</a></td>
	<td class="summary">bind the value <code>v</code> to the second argument of function <code>f</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#compose">compose&nbsp;(f1, f2)</a></td>
	<td class="summary">compose two functions.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#binop">binop&nbsp;(key, op)</a></td>
	<td class="summary">make a binary comparison function.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#callable">callable&nbsp;(obj)</a></td>
	<td class="summary">is the object either a function or a callable object?.</td>
	</tr>
</table>
<h2><a href="#Classes">Classes</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#class">class&nbsp;(base)</a></td>
	<td class="summary">create a class with an optional base class.</td>
	</tr>
</table>

<br/>
<br/>


    <h2><a name="String_utilties"></a>String utilties</h2>
    


    <dl class="function">
    <dt>
    <a name = "split"></a>
    <strong>split&nbsp;(s, re, n)</strong>
    </dt>
    <dd>
    split a string into a list of strings separated by a delimiter. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>s</em></code>:  The input string</li>
       <li><code><em>re</em></code>:  A Lua string pattern; defaults to '%s+'</li>
       <li><code><em>n</em></code>:  optional maximum number of splits</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        a list
    </ol>


</dd>
    <dt>
    <a name = "escape"></a>
    <strong>escape&nbsp;(s)</strong>
    </dt>
    <dd>
    escape any 'magic' characters in a string 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>s</em></code>:  The input string</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        an escaped string
    </ol>


</dd>
    <dt>
    <a name = "expand"></a>
    <strong>expand&nbsp;(s, subst)</strong>
    </dt>
    <dd>
    expand a string containing any ${var} or $var. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>s</em></code>:  the string</li>
       <li><code><em>subst</em></code>:  either a table or a function (as in <code>string.gsub</code>)</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        expanded string
    </ol>


</dd>
    <dt>
    <a name = "readfile"></a>
    <strong>readfile&nbsp;(filename, is_bin)</strong>
    </dt>
    <dd>
    return the contents of a file as a string 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>filename</em></code>:  The file path</li>
       <li><code><em>is_bin</em></code>:  open in binary mode, default false</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        file contents
    </ol>


</dd>
</dl>
    <h2><a name="File_and_Path_functions"></a>File and Path functions</h2>
    


    <dl class="function">
    <dt>
    <a name = "exists"></a>
    <strong>exists&nbsp;(filename)</strong>
    </dt>
    <dd>
    Does a file exist? 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>filename</em></code>:  a file path</li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">exists 'readme' or exists 'readme.txt' or exists 'readme.md'</pre>
    </ul>

    <h3>Returns:</h3>
    <ol>
        the file path, otherwise nil
    </ol>


</dd>
    <dt>
    <a name = "splitpath"></a>
    <strong>splitpath&nbsp;(P)</strong>
    </dt>
    <dd>
    split a file path. 
 if there's no directory part, the first value will be the empty string

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>P</em></code>:  A file path</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        <li>the directory part</li>
        <li>the file part</li>
    </ol>


</dd>
    <dt>
    <a name = "splitext"></a>
    <strong>splitext&nbsp;(P)</strong>
    </dt>
    <dd>
    given a path, return the root part and the extension part. 
 if there's no extension part, the second value will be empty

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>P</em></code>:  A file path</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        <li>the name part</li>
        <li>the extension</li>
    </ol>


</dd>
</dl>
    <h2><a name="Extended_table_functions"></a>Extended table functions</h2>
     'list' here is shorthand for 'list-like table'; these functions
 only operate over the numeric <code>1..#t</code> range of a table and are
 particularly efficient for this purpose.
    <dl class="function">
    <dt>
    <a name = "tstring"></a>
    <strong>tstring&nbsp;(t)</strong>
    </dt>
    <dd>
    return a string representation of a Lua value. 
 Cycles are detected, and a limit on number of items can be imposed.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  the table</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        a string
    </ol>


</dd>
    <dt>
    <a name = "tdump"></a>
    <strong>tdump&nbsp;(t, ...)</strong>
    </dt>
    <dd>
    dump a Lua value to a file object. 
 With no second argument, dumps to standard output.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  the table</li>
       <li><code><em>...</em></code>:  the file object (anything supporting f.write)</li>
    </ul>




</dd>
    <dt>
    <a name = "imap"></a>
    <strong>imap&nbsp;(f, t, ...)</strong>
    </dt>
    <dd>
    map a function over a list. 
 The output must always be the same length as the input, so
 any <code>nil</code> values are mapped to <code>false</code>.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>f</em></code>:  a function of one or more arguments</li>
       <li><code><em>t</em></code>:  the list</li>
       <li><code><em>...</em></code>:  any extra arguments to the function</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        a list with elements <code>f(t[i],...)</code>
    </ol>


</dd>
    <dt>
    <a name = "imap2"></a>
    <strong>imap2&nbsp;(f, t1, t2)</strong>
    </dt>
    <dd>
    map a function over two lists. 
 The output must always be the same length as the input, so
 any <code>nil</code> values are mapped to <code>false</code>.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>f</em></code>:  a function of two or more arguments</li>
       <li><code><em>t1</em></code>:  first list</li>
       <li><code><em>t2</em></code>:  second list</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        a list with elements <code>f(t1[i],t2[i],...)</code>
    </ol>


</dd>
    <dt>
    <a name = "foreach"></a>
    <strong>foreach&nbsp;(t, f, ...)</strong>
    </dt>
    <dd>
    call a function repeatedly. 
 The first argument of the function will be the values
 from a list, if specified.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  either a count or a list</li>
       <li><code><em>f</em></code>:  a function to be repeatedly called</li>
       <li><code><em>...</em></code>:  any extra arguments to the function</li>
    </ul>




</dd>
    <dt>
    <a name = "ifilter"></a>
    <strong>ifilter&nbsp;(t, pred, ...)</strong>
    </dt>
    <dd>
    filter a list using a predicate. 
 If <code>pred</code> is absent, then we provide a default which
 filters out any <code>false</code> values.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  a table</li>
       <li><code><em>pred</em></code>:  the predicate function</li>
       <li><code><em>...</em></code>:  any extra arguments to the predicate</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        a list such that <code>pred(t[i])</code> is true
    </ol>


</dd>
    <dt>
    <a name = "ifind"></a>
    <strong>ifind&nbsp;(t, pred, ...)</strong>
    </dt>
    <dd>
    find an item in a list using a predicate. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  the list</li>
       <li><code><em>pred</em></code>:  a function of at least one argument</li>
       <li><code><em>...</em></code>:  any extra arguments</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        the item value
    </ol>


</dd>
    <dt>
    <a name = "indexof"></a>
    <strong>indexof&nbsp;(t, value)</strong>
    </dt>
    <dd>
    return the index of an item in a list. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  the list</li>
       <li><code><em>value</em></code>:  item value</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        index, otherwise <code>nil</code>
    </ol>


</dd>
    <dt>
    <a name = "sub"></a>
    <strong>sub&nbsp;(t, i1, i2)</strong>
    </dt>
    <dd>
    return a slice of a list. 
 Like string.sub, the end index may be negative.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  the list</li>
       <li><code><em>i1</em></code>:  the start index</li>
       <li><code><em>i2</em></code>:  the end index, default #t</li>
    </ul>




</dd>
    <dt>
    <a name = "icopy"></a>
    <strong>icopy&nbsp;(dest, src, idest, isrc, nsrc)</strong>
    </dt>
    <dd>
    copy a list into another. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>dest</em></code>:  destination list</li>
       <li><code><em>src</em></code>:  source list</li>
       <li><code><em>idest</em></code>:  start index in destination, default 1</li>
       <li><code><em>isrc</em></code>:  start index in source, default 1</li>
       <li><code><em>nsrc</em></code>:  number of elements to copy, default #src</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        the first list
    </ol>


</dd>
    <dt>
    <a name = "indexby"></a>
    <strong>indexby&nbsp;(t, keys)</strong>
    </dt>
    <dd>
    make a list of indexed values. 
 Generalized table indexing

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  a table</li>
       <li><code><em>keys</em></code>:  a list of keys or indices</li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">indexby({one=1,two=2},{'one'}) == {1}</pre>
    </ul>

    <h3>Returns:</h3>
    <ol>
        a list <code>L</code> such that <code>L[keys[i]]</code>
    </ol>


</dd>
    <dt>
    <a name = "import"></a>
    <strong>import&nbsp;(t, ...)</strong>
    </dt>
    <dd>
    add the key/value pairs of <code>other</code> to <code>t</code>. 
 For sets, this is their union. For the same keys,
 the values from the first table will be overwritten.
 If <code>other</code> is a string, then it becomes the result of <code>require</code>
 With only one argument, the second argument is assumed to be
 the <code>ml</code> table itself.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  table to be updated</li>
       <li><code><em>...</em></code>:  table</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        the updated table
    </ol>


</dd>
    <dt>
    <a name = "extend"></a>
    <strong>extend&nbsp;(t, other)</strong>
    </dt>
    <dd>
    extend a list using values from another. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  the list to be extended</li>
       <li><code><em>other</em></code>:  a list</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        the extended list
    </ol>


</dd>
    <dt>
    <a name = "makemap"></a>
    <strong>makemap&nbsp;(t, tv)</strong>
    </dt>
    <dd>
    make a map from a list. 
 In its simplest form, this makes a <em>set</em> from a list; each value
 becomes a key. The default value of that key is the original
 list index. These values can also be provided directly.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  a list of values that become the keys</li>
       <li><code><em>tv</em></code>:  optional list that become the values</li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">makemap{'one','two'} == {one=1,two=2}</pre></li>
        <li><pre class="example">makemap({'power','glory'},{20,30}) == {power=20,glory=30}</pre></li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        a table where the keys are the values
    </ol>


</dd>
    <dt>
    <a name = "keys"></a>
    <strong>keys&nbsp;(t)</strong>
    </dt>
    <dd>
    extract the keys of a table as a list. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  a table</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        a list of keys
    </ol>


</dd>
    <dt>
    <a name = "subset"></a>
    <strong>subset&nbsp;(t, other)</strong>
    </dt>
    <dd>
    is <code>other</code> a subset of <code>t</code>? 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  a set</li>
       <li><code><em>other</em></code>:  a possible subset</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        true or false
    </ol>


</dd>
    <dt>
    <a name = "tequal"></a>
    <strong>tequal&nbsp;(t, other)</strong>
    </dt>
    <dd>
    are these two tables equal? 
 This is shallow equality.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  a table</li>
       <li><code><em>other</em></code>:  a table</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        true or false
    </ol>


</dd>
    <dt>
    <a name = "collect"></a>
    <strong>collect&nbsp;(iter, select)</strong>
    </dt>
    <dd>
    collect the values of an iterator into a list. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>iter</em></code>:  an iterator returning one or more values</li>
       <li><code><em>select</em></code>:  (optional) Either a number of values to collect, or <code>true</code>
 meaning collect values as a tuple, or a function to process/filter values.</li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">collect(math.random,3) == {0.23,0.75,0.13}</pre>
    </ul>

    <h3>Returns:</h3>
    <ol>
        a list of values.
    </ol>


</dd>
</dl>
    <h2><a name="Functional_helpers"></a>Functional helpers</h2>
    


    <dl class="function">
    <dt>
    <a name = "bind1"></a>
    <strong>bind1&nbsp;(f, v)</strong>
    </dt>
    <dd>
    bind the value <code>v</code> to the first argument of function <code>f</code>. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>f</em></code>:  a function of at least one argument</li>
       <li><code><em>v</em></code>:  a value</li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">(bind1(string.match,'hello')('^hell') == 'hell'</pre>
    </ul>

    <h3>Returns:</h3>
    <ol>
        a function of one less argument
    </ol>


</dd>
    <dt>
    <a name = "bind2"></a>
    <strong>bind2&nbsp;(f, v)</strong>
    </dt>
    <dd>
    bind the value <code>v</code> to the second argument of function <code>f</code>. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>f</em></code>:  a function of at least one argument</li>
       <li><code><em>v</em></code>:  a value</li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">(bind2(string.match,'^hell')('hello') == 'hell'</pre>
    </ul>

    <h3>Returns:</h3>
    <ol>
        a function of one less argument
    </ol>


</dd>
    <dt>
    <a name = "compose"></a>
    <strong>compose&nbsp;(f1, f2)</strong>
    </dt>
    <dd>
    compose two functions. 
 For instance, <code>printf</code> can be defined as <code>compose(io.write,string.format)</code>

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>f1</em></code>:  a function</li>
       <li><code><em>f2</em></code>:  a function</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        <code>f1(f2(...))</code>
    </ol>


</dd>
    <dt>
    <a name = "binop"></a>
    <strong>binop&nbsp;(key, op)</strong>
    </dt>
    <dd>
    make a binary comparison function. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>key</em></code>:  in structure or array to be compared</li>
       <li><code><em>op</em></code>:  '&lt;' for less than, '==' for equals, and otherwise a binary function.</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        a comparison function
    </ol>


</dd>
    <dt>
    <a name = "callable"></a>
    <strong>callable&nbsp;(obj)</strong>
    </dt>
    <dd>
    is the object either a function or a callable object?. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>obj</em></code>:  Object to check.</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        true if callable
    </ol>


</dd>
</dl>
    <h2><a name="Classes"></a>Classes</h2>
    


    <dl class="function">
    <dt>
    <a name = "class"></a>
    <strong>class&nbsp;(base)</strong>
    </dt>
    <dd>
    create a class with an optional base class. 
 The resulting table can be called to make a new object, which invokes
 an optional constructor named <code>_init</code>. If the base
 class has a constructor, you can call it as the <code>super()</code> method.
 Every class has a <code>_class</code> and a maybe-nil <code>_base</code> field, which can
 be accessed through the object.
 All metamethods are inherited.
 The class is given a function <code>Klass.class_of(obj)</code>.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>base</em></code>:  optional base class</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        the metatable representing the class
    </ol>


</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.1</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
