<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>ldoc</h1>


<h2>Contents</h2>
<ul>
<li><a href="#String_utilties">String utilties</a></li>
<li><a href="#File_and_Path_functions">File and Path functions</a></li>
<li><a href="#Extended_table_functions">Extended table functions</a></li>
<li><a href="#Functional_helpers">Functional helpers</a></li>
<li><a href="#Classes">Classes</a></li>
</ul>


<h2>Modules</h2>
<ul>
  <li><strong>ml</strong></li>
</ul>

</div>

<div id="content">

<h1>Module <code>ml</code></h1>

<p>Microlight - a very compact Lua utilities module</p>
<p> Steve Donovan, 2012; License MIT</p>

<h2><a href="#String_utilties">String utilties</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#split">split&nbsp;(s, re, n)</a></td>
	<td class="summary">split a string into a array of strings separated by a delimiter.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#escape">escape&nbsp;(s)</a></td>
	<td class="summary">escape any 'magic' characters in a string</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#expand">expand&nbsp;(s, subst)</a></td>
	<td class="summary">expand a string containing any ${var} or $var.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#readfile">readfile&nbsp;(filename, is_bin)</a></td>
	<td class="summary">return the contents of a file as a string</td>
	</tr>
</table>
<h2><a href="#File_and_Path_functions">File and Path functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#exists">exists&nbsp;(filename)</a></td>
	<td class="summary">Does a file exist?</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#splitpath">splitpath&nbsp;(P)</a></td>
	<td class="summary">split a file path.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#splitext">splitext&nbsp;(P)</a></td>
	<td class="summary">given a path, return the root part and the extension part.</td>
	</tr>
</table>
<h2><a href="#Extended_table_functions">Extended table functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#tstring">tstring&nbsp;(t, stupid)</a></td>
	<td class="summary">return a string representation of a Lua value.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#imap">imap&nbsp;(f, t, ...)</a></td>
	<td class="summary">map a function over a array.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#imap2">imap2&nbsp;(f, t1, t2, ...)</a></td>
	<td class="summary">map a function over two arrays.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#ifilter">ifilter&nbsp;(t, pred, ...)</a></td>
	<td class="summary">filter a array using a predicate.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#ifind">ifind&nbsp;(t, pred, ...)</a></td>
	<td class="summary">find an item in a array using a predicate.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#indexof">indexof&nbsp;(t, value, cmp)</a></td>
	<td class="summary">return the index of an item in a array.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#sub">sub&nbsp;(t, i1, i2)</a></td>
	<td class="summary">return a slice of a array.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#removerange">removerange&nbsp;(tbl, start, finish)</a></td>
	<td class="summary">delete a range of values from a array.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#insertvalues">insertvalues&nbsp;(dest, index, src, overwrite)</a></td>
	<td class="summary">copy values from `src` into `dest` starting at `index`.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#extend">extend&nbsp;(t, other)</a></td>
	<td class="summary">extend a array using values from another.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#indexby">indexby&nbsp;(t, keys)</a></td>
	<td class="summary">make a array of indexed values.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#range">range&nbsp;(x1, x2, d)</a></td>
	<td class="summary">create an array of numbers from start to end.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#import">import&nbsp;(t, other)</a></td>
	<td class="summary">add the key/value pairs of `other` to `t`.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#makemap">makemap&nbsp;(t, tv)</a></td>
	<td class="summary">make a table from a array of keys and a array of values.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#invert">invert&nbsp;(t)</a></td>
	<td class="summary">make a set from a array.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#keys">keys&nbsp;(t)</a></td>
	<td class="summary">extract the keys of a table as a array.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#issubset">issubset&nbsp;(t, other)</a></td>
	<td class="summary">are all the keys of `other` in `t`?</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#count">count&nbsp;(t)</a></td>
	<td class="summary">return the number of keys in this table.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#equal_keys">equal_keys&nbsp;(t, other)</a></td>
	<td class="summary">do these tables have the same keys?</td>
	</tr>
</table>
<h2><a href="#Functional_helpers">Functional helpers</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#throw">throw&nbsp;(f, quit)</a></td>
	<td class="summary">create a function which will throw an error on failure.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#bind1">bind1&nbsp;(f, v)</a></td>
	<td class="summary">bind the value `v` to the first argument of function `f`.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#bind2">bind2&nbsp;(f, v)</a></td>
	<td class="summary">bind the value `v` to the second argument of function `f`.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#compose">compose&nbsp;(f1, f2)</a></td>
	<td class="summary">compose two functions.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#callable">callable&nbsp;(obj)</a></td>
	<td class="summary">is the object either a function or a callable object?.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#memoize">memoize&nbsp;(func)</a></td>
	<td class="summary">'memoize' a function (cache returned value for next call).</td>
	</tr>
</table>
<h2><a href="#Classes">Classes</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#class">class&nbsp;(base)</a></td>
	<td class="summary">create a class with an optional base class.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Array">Array</a></td>
	<td class="summary">a simple Array class.</td>
	</tr>
</table>

<br/>
<br/>


    <h2><a name="String_utilties"></a>String utilties</h2>
    
    <dl class="function">
    <dt>
    <a name = "split"></a>
    <strong>split&nbsp;(s, re, n)</strong>
    </dt>
    <dd>
    split a string into a array of strings separated by a delimiter. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>s</em></code>:  The input string</li>
       <li><code><em>re</em></code>:  A Lua string pattern; defaults to '%s+'</li>
       <li><code><em>n</em></code>:  optional maximum number of splits</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        a array
    </ol>


</dd>
    <dt>
    <a name = "escape"></a>
    <strong>escape&nbsp;(s)</strong>
    </dt>
    <dd>
    escape any 'magic' characters in a string 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>s</em></code>:  The input string</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        an escaped string
    </ol>


</dd>
    <dt>
    <a name = "expand"></a>
    <strong>expand&nbsp;(s, subst)</strong>
    </dt>
    <dd>
    expand a string containing any ${var} or $var. 
 However, you should pick _either one_ consistently!

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>s</em></code>:  the string</li>
       <li><code><em>subst</em></code>:  either a table or a function (as in `string.gsub`)</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        expanded string
    </ol>


</dd>
    <dt>
    <a name = "readfile"></a>
    <strong>readfile&nbsp;(filename, is_bin)</strong>
    </dt>
    <dd>
    return the contents of a file as a string 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>filename</em></code>:  The file path</li>
       <li><code><em>is_bin</em></code>:  open in binary mode, default false</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        file contents
    </ol>


</dd>
</dl>
    <h2><a name="File_and_Path_functions"></a>File and Path functions</h2>
    
    <dl class="function">
    <dt>
    <a name = "exists"></a>
    <strong>exists&nbsp;(filename)</strong>
    </dt>
    <dd>
    Does a file exist? 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>filename</em></code>:  a file path</li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">exists 'readme' or exists 'readme.txt' or exists 'readme.md'</pre>
    </ul>

    <h3>Returns:</h3>
    <ol>
        the file path, otherwise nil
    </ol>


</dd>
    <dt>
    <a name = "splitpath"></a>
    <strong>splitpath&nbsp;(P)</strong>
    </dt>
    <dd>
    split a file path. 
 if there's no directory part, the first value will be the empty string

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>P</em></code>:  A file path</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        <li>the directory part</li>
        <li>the file part</li>
    </ol>


</dd>
    <dt>
    <a name = "splitext"></a>
    <strong>splitext&nbsp;(P)</strong>
    </dt>
    <dd>
    given a path, return the root part and the extension part. 
 if there's no extension part, the second value will be empty

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>P</em></code>:  A file path</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        <li>the name part</li>
        <li>the extension</li>
    </ol>


</dd>
</dl>
    <h2><a name="Extended_table_functions"></a>Extended table functions</h2>
    
 'array' here is shorthand for 'array-like table'; these functions
 only operate over the numeric `1..#t` range of a table and are
 particularly efficient for this purpose.
    <dl class="function">
    <dt>
    <a name = "tstring"></a>
    <strong>tstring&nbsp;(t, stupid)</strong>
    </dt>
    <dd>
    return a string representation of a Lua value. 
 Cycles are detected, and a limit on number of items can be imposed.
 Use `stupid` if you want something correct for serialization, e.g. `{['function']=true}`

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  the table</li>
       <li><code><em>stupid</em></code>:  put out all keys as [..]</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        a string
    </ol>


</dd>
    <dt>
    <a name = "imap"></a>
    <strong>imap&nbsp;(f, t, ...)</strong>
    </dt>
    <dd>
    map a function over a array. 
 The output must always be the same length as the input, so
 any `nil` values are mapped to `false`.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>f</em></code>:  a function of one or more arguments</li>
       <li><code><em>t</em></code>:  the array</li>
       <li><code><em>...</em></code>:  any extra arguments to the function</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        a array with elements `f(t[i],...)`
    </ol>


</dd>
    <dt>
    <a name = "imap2"></a>
    <strong>imap2&nbsp;(f, t1, t2, ...)</strong>
    </dt>
    <dd>
    map a function over two arrays. 
 The output must always be the same length as the input, so
 any `nil` values are mapped to `false`.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>f</em></code>:  a function of two or more arguments</li>
       <li><code><em>t1</em></code>:  first array</li>
       <li><code><em>t2</em></code>:  second array</li>
       <li><code><em>...</em></code>:  any extra arguments to the function</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        a array with elements `f(t1[i],t2[i],...)`
    </ol>


</dd>
    <dt>
    <a name = "ifilter"></a>
    <strong>ifilter&nbsp;(t, pred, ...)</strong>
    </dt>
    <dd>
    filter a array using a predicate. 
 If `pred` is absent, then we provide a default which
 filters out any `false` values.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  a table</li>
       <li><code><em>pred</em></code>:  the predicate function</li>
       <li><code><em>...</em></code>:  any extra arguments to the predicate</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        a array such that `pred(t[i])` is true
    </ol>


</dd>
    <dt>
    <a name = "ifind"></a>
    <strong>ifind&nbsp;(t, pred, ...)</strong>
    </dt>
    <dd>
    find an item in a array using a predicate. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  the array</li>
       <li><code><em>pred</em></code>:  a function of at least one argument</li>
       <li><code><em>...</em></code>:  any extra arguments</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        the item value
    </ol>


</dd>
    <dt>
    <a name = "indexof"></a>
    <strong>indexof&nbsp;(t, value, cmp)</strong>
    </dt>
    <dd>
    return the index of an item in a array. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  the array</li>
       <li><code><em>value</em></code>:  item value</li>
       <li><code><em>cmp</em></code>:  optional comparison function (default is `v==value`)</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        index, otherwise `nil`
    </ol>


</dd>
    <dt>
    <a name = "sub"></a>
    <strong>sub&nbsp;(t, i1, i2)</strong>
    </dt>
    <dd>
    return a slice of a array. 
 Like string.sub, the end index may be negative.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  the array</li>
       <li><code><em>i1</em></code>:  the start index</li>
       <li><code><em>i2</em></code>:  the end index, default #t</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        a array such that `t[i]` for `i` from `i1` to `i2` inclusive
    </ol>


</dd>
    <dt>
    <a name = "removerange"></a>
    <strong>removerange&nbsp;(tbl, start, finish)</strong>
    </dt>
    <dd>
    delete a range of values from a array. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>tbl</em></code>:  the array</li>
       <li><code><em>start</em></code>:  start index</li>
       <li><code><em>finish</em></code>:  end index (like `ml.sub`)</li>
    </ul>




</dd>
    <dt>
    <a name = "insertvalues"></a>
    <strong>insertvalues&nbsp;(dest, index, src, overwrite)</strong>
    </dt>
    <dd>
    copy values from `src` into `dest` starting at `index`. 
 By default, it inserts into `dest` and moves up elements of `src`
 to make room.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>dest</em></code>:  destination array</li>
       <li><code><em>index</em></code>:  start index in destination</li>
       <li><code><em>src</em></code>:  source array</li>
       <li><code><em>overwrite</em></code>:  write over values</li>
    </ul>




</dd>
    <dt>
    <a name = "extend"></a>
    <strong>extend&nbsp;(t, other)</strong>
    </dt>
    <dd>
    extend a array using values from another. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  the array to be extended</li>
       <li><code><em>other</em></code>:  a array</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        the extended array
    </ol>


</dd>
    <dt>
    <a name = "indexby"></a>
    <strong>indexby&nbsp;(t, keys)</strong>
    </dt>
    <dd>
    make a array of indexed values. 
 Generalized table indexing

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  a table</li>
       <li><code><em>keys</em></code>:  a array of keys or indices</li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">indexby({one=1,two=2},{'one'}) == {1}</pre>
    </ul>

    <h3>Returns:</h3>
    <ol>
        a array `L` such that `L[keys[i]]`
    </ol>


</dd>
    <dt>
    <a name = "range"></a>
    <strong>range&nbsp;(x1, x2, d)</strong>
    </dt>
    <dd>
    create an array of numbers from start to end. 
 With one argument it goes `1..x1`. `d` may be a
 floating-point fraction

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>x1</em></code>:  start value</li>
       <li><code><em>x2</em></code>:  end value</li>
       <li><code><em>d</em></code>:  increment (default 1)</li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <li><pre class="example">range(2,10) == {2,3,4,5,6,7,8,9,10}</pre></li>
        <li><pre class="example">range(5) == {1,2,3,4,5}</pre></li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        array of numbers
    </ol>


</dd>
    <dt>
    <a name = "import"></a>
    <strong>import&nbsp;(t, other)</strong>
    </dt>
    <dd>
    add the key/value pairs of `other` to `t`. 
 For sets, this is their union. For the same keys,
 the values from the first table will be overwritten.
 If `other` is a string, then it becomes the result of `require`
 With only one argument, the second argument is assumed to be
 the `ml` table itself.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  table to be updated</li>
       <li><code><em>other</em></code>:  table</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        the updated table
    </ol>


</dd>
    <dt>
    <a name = "makemap"></a>
    <strong>makemap&nbsp;(t, tv)</strong>
    </dt>
    <dd>
    make a table from a array of keys and a array of values. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  a array of keys</li>
       <li><code><em>tv</em></code>:  a array of values</li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">makemap({'power','glory'},{20,30}) == {power=20,glory=30}</pre>
    </ul>

    <h3>Returns:</h3>
    <ol>
        a table where `{[t[i]]=tv[i]}`
    </ol>


</dd>
    <dt>
    <a name = "invert"></a>
    <strong>invert&nbsp;(t)</strong>
    </dt>
    <dd>
    make a set from a array. 
 The values are the original array indices.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  a array of values</li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">invert{'one','two'} == {one=1,two=2}</pre>
    </ul>

    <h3>Returns:</h3>
    <ol>
        a table where the keys are the indices in the array.
    </ol>


</dd>
    <dt>
    <a name = "keys"></a>
    <strong>keys&nbsp;(t)</strong>
    </dt>
    <dd>
    extract the keys of a table as a array. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  a table</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        a array of keys
    </ol>


</dd>
    <dt>
    <a name = "issubset"></a>
    <strong>issubset&nbsp;(t, other)</strong>
    </dt>
    <dd>
    are all the keys of `other` in `t`? 
 Only compares keys!

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  a set</li>
       <li><code><em>other</em></code>:  a possible subset</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        true or false
    </ol>


</dd>
    <dt>
    <a name = "count"></a>
    <strong>count&nbsp;(t)</strong>
    </dt>
    <dd>
    return the number of keys in this table. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  a table</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        key count, (which is set cardinality)
    </ol>


</dd>
    <dt>
    <a name = "equal_keys"></a>
    <strong>equal_keys&nbsp;(t, other)</strong>
    </dt>
    <dd>
    do these tables have the same keys? 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  a table</li>
       <li><code><em>other</em></code>:  a table</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        true or false
    </ol>


</dd>
</dl>
    <h2><a name="Functional_helpers"></a>Functional helpers</h2>
    
    <dl class="function">
    <dt>
    <a name = "throw"></a>
    <strong>throw&nbsp;(f, quit)</strong>
    </dt>
    <dd>
    create a function which will throw an error on failure. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>f</em></code>:  a function that returns nil,err if it fails</li>
       <li><code><em>quit</em></code>:  exit the script immediately with the error (default false)</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        an equivalent function that raises an error
    </ol>


</dd>
    <dt>
    <a name = "bind1"></a>
    <strong>bind1&nbsp;(f, v)</strong>
    </dt>
    <dd>
    bind the value `v` to the first argument of function `f`. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>f</em></code>:  a function of at least one argument</li>
       <li><code><em>v</em></code>:  a value</li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">(bind1(string.match,'hello')('^hell') == 'hell'</pre>
    </ul>

    <h3>Returns:</h3>
    <ol>
        a function of one less argument
    </ol>


</dd>
    <dt>
    <a name = "bind2"></a>
    <strong>bind2&nbsp;(f, v)</strong>
    </dt>
    <dd>
    bind the value `v` to the second argument of function `f`. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>f</em></code>:  a function of at least one argument</li>
       <li><code><em>v</em></code>:  a value</li>
    </ul>

    <h3>Usage:</h3>
    <ul>
        <pre class="example">(bind2(string.match,'^hell')('hello') == 'hell'</pre>
    </ul>

    <h3>Returns:</h3>
    <ol>
        a function of one less argument
    </ol>


</dd>
    <dt>
    <a name = "compose"></a>
    <strong>compose&nbsp;(f1, f2)</strong>
    </dt>
    <dd>
    compose two functions. 
 For instance, `printf` can be defined as `compose(io.write,string.format)`

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>f1</em></code>:  a function</li>
       <li><code><em>f2</em></code>:  a function</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        `f1(f2(...))`
    </ol>


</dd>
    <dt>
    <a name = "callable"></a>
    <strong>callable&nbsp;(obj)</strong>
    </dt>
    <dd>
    is the object either a function or a callable object?. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>obj</em></code>:  Object to check.</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        true if callable
    </ol>


</dd>
    <dt>
    <a name = "memoize"></a>
    <strong>memoize&nbsp;(func)</strong>
    </dt>
    <dd>
    'memoize' a function (cache returned value for next call). 
 This is useful if you have a function which is relatively expensive,
 but you don't know in advance what values will be required, so
 building a table upfront is wasteful/impossible.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>func</em></code>:  a function of at least one argument</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        a function with at least one argument, which is used as the key.
    </ol>


</dd>
</dl>
    <h2><a name="Classes"></a>Classes</h2>
    
    <dl class="function">
    <dt>
    <a name = "class"></a>
    <strong>class&nbsp;(base)</strong>
    </dt>
    <dd>
    create a class with an optional base class. 
 The resulting table can be called to make a new object, which invokes
 an optional constructor named `_init`. If the base
 class has a constructor, you can call it as the `super()` method.
 Every class has a `_class` and a maybe-nil `_base` field, which can
 be accessed through the object.
 All metamethods are inherited.
 The class is given a function `Klass.class_of(obj)`.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>base</em></code>:  optional base class</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        the metatable representing the class
    </ol>


</dd>
    <dt>
    <a name = "Array"></a>
    <strong>Array</strong>
    </dt>
    <dd>
    a simple Array class. 





</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.2</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
